<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title></title>
        <link>undefined</link>
        <description>undefined</description>
        <lastBuildDate>Sun, 28 Nov 2021 09:21:02 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>Joplin Pages Publisher</generator>
        <item>
            <title><![CDATA[day04-包装类、String类、引用类型小结、综合案例]]></title>
            <guid>d767741cd5104e96b42272a8dc668c46</guid>
            <pubDate>Fri, 26 Nov 2021 15:04:47 GMT</pubDate>
            <content:encoded><![CDATA[<h2 id="第一章biginteger类">第一章：BigInteger类</h2>
<h3 id="11-biginteger类概述及使用了解">1.1 BigInteger类概述及使用【了解】</h3>
<ol>
<li>java.math.BigInteger(类)：</li>
</ol>
<blockquote>
<p>它可以表示"任意大的整数"，通常可以将一个"字符串"转换为一
个"整数"，并可以进行运算。<br />
<strong>long以内的整数运算，使用"基本类型"就可以。如果超出了long的范围，就需要使用
BigInteger运算。</strong></p>
</blockquote>
<ol start="2">
<li>构造方法：</li>
</ol>
<blockquote>
<p>public BigInteger(String val)</p>
</blockquote>
<ol start="3">
<li>成员方法：</li>
</ol>
<blockquote>
<ol>
<li>BigInteger <strong>add</strong>(BigInteger value) 返回其值为 (this + val) 的 BigInteger，超大整数加法运算</li>
<li>BigInteger <strong>subtract</strong>(BigInteger value)返回其值为 (this - val) 的 BigInteger，超大整数减法运算</li>
<li>BigInteger <strong>multiply</strong>(BigInteger value) 返回其值为 (this * val) 的 BigInteger，超大整数乘法运算</li>
<li>BigInteger <strong>divide</strong>(BigInteger value) 返回其值为 (this / val) 的 BigInteger，超大整数除法运算，除不尽取整数部分</li>
<li>BigInteger public BigInteger <strong>remainder</strong>(BigInteger val)：返回值为(this % val)</li>
</ol>
</blockquote>
<p><img src="/_resources/2e00300939b146f4a90eab0c1f580027.png" /></p>
<h2 id="第二章bigdecimal类">第二章：BigDecimal类</h2>
<h3 id="21-bigdecimal解决浮点运算的问题">2.1 BigDecimal解决浮点运算的问题</h3>
<ol>
<li>之前我们使用"基本数据类型的float和double"进行浮点运算时，会出现：精度丢失的问题。</li>
</ol>
<p>例如： double a = 0.09;</p>
<p>double b = 0.01;</p>
<p>System.out.println(a + b);// 0.09999999999999999(将十进制小数转换为二进制小数的过程导致的)</p>
<p><strong>所以：以后再涉及到"浮点运算"，不要使用基本数据类型，改用BigDecimal！！！！</strong></p>
<p><strong>2. 构造方法：</strong></p>
<blockquote>
<p><strong>1. BigDecimal(double val)：【不建议使用】，参数是一个double值，在转存时仍然会出现精度丢失的问题。</strong><br />
<strong>2. public BigDecimal(String val)：【建议】，不会出现精度丢失的问题。</strong></p>
</blockquote>
<p><strong>3. 成员方法：</strong>
<img src="/_resources/6425ac7251fb4db085e66f589ccbe83a.png" /></p>
<h2 id="第三章-arrays类">第三章 Arrays类</h2>
<h3 id="31-arrays类概述及使用">3.1 Arrays类概述及使用</h3>
<ol>
<li>java.util.Arrays(类)：它里面包含了一些对数组操作的方法。</li>
</ol>
<p>它的方法都是"静态"的，使用的时候，通过类名就可以直接访问方法。</p>
<ol start="2">
<li>常用方法：</li>
</ol>
<blockquote>
<ol>
<li>public static String toString(int[] a)：可以将一个int[]数组转换为一个String。</li>
<li>public static void sort(int[] a)：对参数数组进行"升序排序(小到大)"</li>
<li>示例代码：</li>
</ol>
</blockquote>
<p><img src="/_resources/453e25927ac244239c9b5d0952fb4734.png" /></p>
<h2 id="第四章包装类">第四章：包装类</h2>
<h3 id="41-包装类的概念">4.1 包装类的概念</h3>
<ol>
<li>
<p>Java四类八种的基本数据类型，都对应有"包装类"：</p>
<table>
<thead>
<tr>
<th style="text-align:center">基本类型</th>
<th style="text-align:center">包装类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">byte</td>
<td style="text-align:center">Byte</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">Short</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">Integer</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">Long</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">Float</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">Dobule</td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">Character</td>
</tr>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center">Boolean</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>这些包装类型的"每个对象"都可以封装一个此类型的"数据"，它们的作用：它们内部也包含了一些方法，可以对此类型数据做操作。</p>
</li>
<li>
<p>以Integer为例：</p>
</li>
</ol>
<ul>
<li>A. Integer的构造方法：【了解，不建议使用，改用此类内部的一些"静态方法"】</li>
</ul>
<blockquote>
<ol>
<li>Integer(int val)：将一个int值转换为一个Integer对象。</li>
<li>Integer(String val)：将一个String转换为一个Integer对象。</li>
</ol>
</blockquote>
<ul>
<li>B. Integer的常用方法：【建议使用，代替构造方法】</li>
</ul>
<blockquote>
<ol>
<li>public static Integer valueOf(int i)：将一个int值转换为一个Integer对象。【了解】</li>
<li>public static Integer valueOf(String s)：将一个String转换为一个Integer对象。【了解】</li>
<li>public int intValue()：普通成员方法，必须通过对象名调用。获取此Integer对象内部的int值。【了解】</li>
<li>public static int parseInt(String s)：可以将一个String转换为int值【掌握】</li>
<li>public static String toString(int i)：可以将一个int值转换为String类型【掌握】</li>
<li>示例代码：</li>
</ol>
</blockquote>
<p><img src="/_resources/668a2c361c3f45f6b6302fcb71c2f290.png" /></p>
<h3 id="42-自动装箱和自动拆箱重点">4.2 自动装箱和自动拆箱【重点】</h3>
<ol>
<li>自动装箱：将一个"基本类型"的值，直接赋给一个它的"包装类型"的变量，这个过程叫：自动装箱。</li>
</ol>
<p>Integer intObj = 10;//语法糖，编译后：Integer intObj = Integer.valueOf(10);</p>
<ol start="2">
<li>自动拆箱：将一个"包装类型"，直接赋给一个它的"基本类型"的变量，这个过程叫：自动拆箱。</li>
</ol>
<p>int a = intObj;//语法糖，编译后：int a = intObj.intValue();</p>
<p><ins>intObj;//先拆箱，然后</ins>，然后再装箱</p>
<ol start="3">
<li>作用：使用ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();比较方便。</li>
</ol>
<p><img src="/_resources/4dcb1e3d657d4a16bfb61103d30a382c.png" /></p>
<ol start="4">
<li>强烈建议：我们的"实体Bean(例如：Student类、Phone类、Cat类…)“这些类中的"成员属性”，如果之前用的是"基本类型"，都建议改为它们的"包装类型"</li>
</ol>
<p><img src="/_resources/539e2b02b2ed4cfbbe1a8e6e27e23851.png" /></p>
<ol start="5">
<li>一个面试题：</li>
</ol>
<p><img src="/_resources/226c141771e3434a8635b4b7b7bdb2e9.png" /></p>
<ol>
<li>通过这里例子大家要知道：包装类型，如果判断是否相等，不要用==判断，不自动拆箱，仍然判断的是地址</li>
</ol>
<p>其它情况：+、-、*、/、%、或者判断大小等，都会自动拆箱，然后再做运算，只有"判断相等"，不要用==</p>
<p>所以：包装类型，如果要判断相等，用它们的equals()方法。</p>
<ol start="2">
<li>以下包装类内部都有缓存：</li>
</ol>
<p>Byte、Short、Integer、Long、Character(ASCII范围：0-127)</p>
<h3 id="43-包装类常见应用">4.3 包装类常见应用</h3>
<ol>
<li>将一个字符串，转换为某种基本类型的数据，这时我们需要使用"包装类"：【重点掌握】</li>
</ol>
<p>例如：</p>
<p>String strAge = “24”;</p>
<p>int age = Integer.<strong>parseInt</strong>(strAge);</p>
<p>除Character外，其它七种包装类都有parseXxxx(String s)：可以将字符串转换为对应类型：</p>
<p>Byte.<strong>parseByte</strong>(String s)</p>
<p>Short.<strong>parseShort</strong>(String s)</p>
<p>Integer.<strong>parseInt</strong>(String s)</p>
<p>Long.<strong>parseLong</strong>(String s)</p>
<p>Float.<strong>parseFloat</strong>(String s)</p>
<p>Double.<strong>parseDouble</strong>(String s)</p>
<p>Boolean.<strong>parseBoolean</strong>(String s)</p>
<ol start="2">
<li>将某种类型的数据转换为字符串：</li>
</ol>
<p>int a = 10;</p>
<p>String str = Integer.<strong>toString</strong>(a);</p>
<p>任何包装类都有toString(基本类型 n)，都可以将一个基本类型，转换为字符串。</p>
<h2 id="第五章string类的更多方法">第五章：String类的更多方法</h2>
<h3 id="501-string类_concat_字符串连接了解">5.01 String类_concat_字符串连接【了解】</h3>
<ol>
<li>我们之前学过字符串拼接，使用+符号，或者使用：StringBuilder，String类本身也提供一个方法concat，也可以做字符串拼接，但没有StringBuilder的效率高，所以，仍然建议大家使用StringBuilder。</li>
</ol>
<p><img src="/_resources/9a055d44694440bf9d7e6680be7c5822.png" /></p>
<ol start="2">
<li>
<p>说明：</p>
<ol>
<li>
<p>concat方法只能和String类型做拼接，比+符号和StringBuilder受限；</p>
</li>
<li>
<p>效率上：最低：+符号；其次concat；最高：StringBuilder【建议】</p>
</li>
</ol>
</li>
</ol>
<h3 id="502-string类_contains_判断包含">5.02 String类_contains_判断包含</h3>
<ol>
<li>原型：public boolean contains(CharSequence s)：判断参数，在当前字符串中是否存在</li>
</ol>
<p>记住：在学习类库中的方法时，如果形参是一个"接口"或者"抽象类"类型，就要找他们的"子类"，并传入一个子类对象。</p>
<p><img src="/_resources/343ba8f101834bc5b503abeccab37935.png" /></p>
<h3 id="503-string类_-startswith_endswith_判断是否以指定的字符串开头_结尾">5.03 String类_ startsWith_endsWith_判断是否以指定的字符串开头_结尾</h3>
<blockquote>
<ol>
<li>public boolean startsWith(String prefix)：判断当前字符串是否以参数字符串开头。</li>
<li>public boolean endsWith(String suffix)：判断当前字符串是否以参数字符串结尾。</li>
</ol>
</blockquote>
<p><img src="/_resources/4054c9740e99449a84ee7a9d90e921fe.png" /></p>
<h3 id="504-string类_indexof_判断字符串第一次出现的位置">5.04 String类_indexOf_判断字符串第一次出现的位置</h3>
<blockquote>
<ol>
<li>public int indexOf(String str)：从头开始检索参数字符串，并返回参数字符串出现的索引位置，如果没有出现，返回-1</li>
</ol>
</blockquote>
<p><img src="/_resources/d1cbd15d662b4665bbdf4b2b1b81ec39.png" /></p>
<h3 id="505-string类_lastindexof_判断字符串最后一次出现的位置">5.05 String类_lastIndexOf_判断字符串最后一次出现的位置</h3>
<blockquote>
<ol>
<li>public int lastIndexOf(String str)：判断字符串最后一次出现的索引位置。</li>
</ol>
</blockquote>
<p><img src="/_resources/e7757b27656e4f8288dcafe5599287e1.png" /></p>
<h3 id="506-string类_tochararray_将字符串转换为字符数组">5.06 String类_toCharArray_将字符串转换为字符数组</h3>
<blockquote>
<ol>
<li>public char[] toCharArray()：将当前字符串转换为char[]数组。</li>
</ol>
</blockquote>
<p><img src="/_resources/0d476f41777e4ef698e09bf017b55684.png" /></p>
<h3 id="507-string类_tolowercase和touppercase_将字符串转换为小写和大写">5.07 String类_toLowerCase和toUpperCase_将字符串转换为小写和大写</h3>
<blockquote>
<ol>
<li>public String toLowerCase()：将字符串中的英文字母转换为小写。</li>
<li>public String toUpperCase()：将字符串中的英文字母转换为大写。</li>
</ol>
</blockquote>
<p><img src="/_resources/345ddf2625d342fb867959144a6f9f51.png" /></p>
<h3 id="508-string类_trim_去掉前后空格">5.08 String类_trim_去掉前后空格</h3>
<blockquote>
<ol>
<li>public String trim()：删除前后的空格，并返回一个新字符串。但不去掉中间的空格。</li>
</ol>
</blockquote>
<p><img src="/_resources/ce1940387d3947eeb0337d2d531e36c9.png" /></p>
<h3 id="509-string类_split_以指定的分隔符切割字符串">5.09 String类_split_以指定的分隔符切割字符串</h3>
<blockquote>
<ol>
<li>public String[] split(String regex)：以参数为分隔符，切割字符串</li>
</ol>
</blockquote>
<p><img src="/_resources/41d8c06e83614a69877950041285c597.png" /></p>
<h2 id="第六章引用类型使用小结">第六章：引用类型使用小结</h2>
<h3 id="61类-抽象类-接口作为参数和返回值">6.1"类"、“抽象类”、"接口"作为参数和返回值</h3>
<ol>
<li>方法的参数：</li>
<li>方法的返回值：</li>
</ol>
<p><img src="/_resources/2cd72cf45e6d43739899308d534dc253.png" /></p>
<h3 id="62类-抽象类-接口作为成员属性">6.2"类"、“抽象类”、"接口"作为成员属性</h3>
<p><img src="/_resources/eca9778f72454fe1be321dee053649c3.png" /></p>
<hr />
<h2 id="第六章总结">第六章：总结</h2>
<p><strong>1. 能够说出BigInteger可以解决的问题</strong></p>
<blockquote>
<p><strong>对于"大于long型的整数"可以使用BigInteger存储，并运算。</strong></p>
</blockquote>
<p><strong>2. 能够说出BigDecimal可以解决的问题</strong></p>
<blockquote>
<p><strong>浮点运算时，精度丢失的问题</strong></p>
</blockquote>
<p><strong>3. 能够使用Arrays类的sort方法</strong></p>
<blockquote>
<p><strong>int[] arr = {1,432,4,325,243,154,363,43,7657};</strong><br />
<strong>Arrays.sort(arr);//排序</strong><br />
<strong>for(int i = 0;i &lt; arr.length ; i++){</strong><br />
<strong>System.out.println(arr[i]);//排序后的</strong><br />
<strong>}</strong></p>
</blockquote>
<p><strong>4. 能够使用Arrays类的toString方法</strong></p>
<blockquote>
<p><strong>int[] arr = {1,432,52,43,2653,52};</strong><br />
<strong>System.out.println(Arrays.toString(arr));</strong></p>
</blockquote>
<p><strong>5. 能够说出自动装箱、自动拆箱的概念</strong></p>
<blockquote>
<p><strong>1. 自动装箱：将基本类型的值直接赋给包装类型</strong><br />
<strong>Integer intObj = 10;</strong><br />
<strong>2. 自动拆箱：将包装类型直接赋给基本类型</strong><br />
<strong>int</strong><br />
<strong>n = intObj;</strong></p>
</blockquote>
<p><strong>6. 能够将基本类型转换为对应的字符串</strong></p>
<blockquote>
<p><strong>int a = 10;</strong><br />
<strong>String s = a + “”;//第一种方式</strong><br />
<strong>String s1 = Integer.toString(a);//第二种方式</strong></p>
</blockquote>
<p><strong>7. 能够将字符串转换为对应的基本类型</strong></p>
<blockquote>
<p><strong>String s = “24”;</strong><br />
<strong>int age = Integer.parseInt(s);</strong></p>
</blockquote>
<p><strong>8. 能够说出String类常用方法的功能及使用</strong></p>
<blockquote>
<p><strong>一共讲了10个</strong></p>
</blockquote>
<p><strong>9. 能够在不同的位置使用引用类型</strong></p>
<blockquote>
<p><strong>1. 方法的形参、返回值都可以是：类、抽象类、接口类型【见demo16】</strong><br />
<strong>2. 方法的成员属性，也可以是：类、抽象类、接口类型【见demo17】</strong></p>
</blockquote>
<h2 id="第七章复习">第七章：复习</h2>
<h3 id="1-练习">1. 练习：</h3>
<ul>
<li>
<ol>
<li>请用户输入一个生日字符串，例如：”1998-3-5”，请编程计算到今年，用户多少周岁？不考虑生日 用String和包装类做。今年不要用2020。</li>
</ol>
</li>
<li>
<ol start="2">
<li>有以下字符串： String str = ”jfewjavajfiewgjavajfioewjgjava”; 请编程计算字符串中共出现多少次”java” 用substring()实现一个版本；substring() + indexOf()</li>
</ol>
</li>
</ul>
<div><pre class="hljs"><code>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> “jfewjavajfiewgjavajfioewjgjavajava”;
    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>){
        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> str.indexOf(“java”);
        <span class="hljs-keyword">if</span>(index != -<span class="hljs-number">1</span>){
            count++;
            str = str.substring(index + <span class="hljs-number">1</span>);
        }<span class="hljs-keyword">else</span>{
            <span class="hljs-keyword">break</span>;
        }
    }
    System.out.println(count);</code></pre></div>
<hr />
<div><pre class="hljs"><code> 用indexOf()实现一个版本；参考API--&gt;String类的<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> indexOf​(String s, <span class="hljs-type">int</span> fromIndex)方法，不需要substring() </code></pre></div>
<hr />
<div><pre class="hljs"><code>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> “jfewjavajfiewgjavajfioewjgjavajava”;
    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//</span>
    <span class="hljs-type">int</span> <span class="hljs-variable">startIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> ((index = str.indexOf(“java”, startIndex)) != -<span class="hljs-number">1</span>) {
        count++;
        startIndex = index + <span class="hljs-number">1</span>;
    }
    System.out.println(count);</code></pre></div>
<hr />
<h2 id="第八章综合案例-学员管理系统_继承版">第八章：综合案例-学员管理系统_继承版</h2>
<p>4.1 学员管理系统_项目演示</p>
<p>4.2 学员管理系统_类结构设计</p>
<p>4.3 学员管理系统_创建项目<br />
1).com.itheima.main包：放启动类：MainApp，包含main()方法<br />
2).com.itheima.superclass包：放父类：Person类<br />
3).com.itheima.student包：放Student模块相关的类，本项目中只有一个Student实体类<br />
4).com.itheima.teacher包：放Teacher模块相关的类，本项目中只有一个Teacher实体类<br />
5).com.itheima.utils包：放工具类。</p>
<p>4.4 学员管理系统_创建基础实体类</p>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.superclass;

<span class="hljs-keyword">import</span> com.itheima.utils.Utils;


<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<span class="hljs-comment">//编号</span>
    <span class="hljs-keyword">private</span> String name;<span class="hljs-comment">//姓名</span>
    <span class="hljs-keyword">private</span> String sex;<span class="hljs-comment">//性别</span>
    <span class="hljs-keyword">private</span> String birthday;<span class="hljs-comment">//出生日期</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<span class="hljs-comment">//年龄--通过出生日期换算</span>
    <span class="hljs-comment">//构造方法</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> {
    }
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(<span class="hljs-type">int</span> id,String name, String sex, String birthday)</span>  {
        <span class="hljs-built_in">this</span>.id = id;
        <span class="hljs-built_in">this</span>.name = name;
        <span class="hljs-built_in">this</span>.sex = sex;
        <span class="hljs-built_in">this</span>.birthday = birthday;
    }
    <span class="hljs-comment">//getter/setter</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> id;
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> {
        <span class="hljs-built_in">this</span>.id = id;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> {
        <span class="hljs-built_in">this</span>.name = name;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSex</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> sex;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSex</span><span class="hljs-params">(String sex)</span> {
        <span class="hljs-built_in">this</span>.sex = sex;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getBirthday</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> birthday;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBirthday</span><span class="hljs-params">(String birthday)</span> {
        <span class="hljs-built_in">this</span>.birthday = birthday;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span>  {
        <span class="hljs-comment">//通过生日计算年龄</span>
        age = Utils.birthdayToAge(<span class="hljs-built_in">this</span>.getBirthday());
        <span class="hljs-keyword">return</span> age;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> {
        <span class="hljs-built_in">this</span>.age = age;
    }

    <span class="hljs-comment">//重写toString，同时作为模板</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span>  id + <span class="hljs-string">"\t\t"</span> +
                name + <span class="hljs-string">"\t\t"</span> +
                sex + <span class="hljs-string">"\t\t"</span> +
                birthday + <span class="hljs-string">"\t"</span> +
                <span class="hljs-built_in">this</span>.getAge() + <span class="hljs-string">"\t\t"</span> +
                <span class="hljs-string">" 我是一名："</span> + getType() + <span class="hljs-string">" 我的工作是："</span> + getWork();
    }
    <span class="hljs-comment">//模板用到的两个方法</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title function_">getWork</span><span class="hljs-params">()</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title function_">getType</span><span class="hljs-params">()</span>;
}
</code></pre></div>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.student;

<span class="hljs-keyword">import</span> com.itheima.superclass.Person;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> {
    }
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String name, String sex, String birthday)</span> {
        <span class="hljs-built_in">super</span>(id, name, sex, birthday);
    }
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getWork</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"学习Java"</span>;
    }
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getType</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"学生"</span>;
    }
}
</code></pre></div>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.teacher;

<span class="hljs-keyword">import</span> com.itheima.superclass.Person;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Teacher</span><span class="hljs-params">()</span> {
    }
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Teacher</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String name, String sex, String birthday)</span> {
        <span class="hljs-built_in">super</span>(id, name, sex, birthday);
    }
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getWork</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"讲课"</span>;
    }
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getType</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"老师"</span>;
    }
}
</code></pre></div>
<p>4.5 学员管理系统_工具类Utils的说明</p>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.utils;

<span class="hljs-keyword">import</span> com.itheima.superclass.Person;

<span class="hljs-keyword">import</span> java.text.ParseException;
<span class="hljs-keyword">import</span> java.text.SimpleDateFormat;
<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Calendar;
<span class="hljs-keyword">import</span> java.util.Date;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Utils</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> stuId ;<span class="hljs-comment">//学员ID的初始值</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> teaId ;<span class="hljs-comment">//教师ID的初始值</span>
    <span class="hljs-keyword">static</span> {
        stuId = <span class="hljs-number">0</span>;
        teaId = <span class="hljs-number">0</span>;
        <span class="hljs-comment">//后期可以改为从文件/数据库读取初始值</span>
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">birthdayToAge</span><span class="hljs-params">(String birthday)</span>  {
        <span class="hljs-type">Date</span> <span class="hljs-variable">birthDate</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">try</span> {
            birthDate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">"yyyy-MM-dd"</span>).parse(birthday);
        } <span class="hljs-keyword">catch</span> (ParseException e) {
            e.printStackTrace();
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
        }
        <span class="hljs-comment">//获取当前系统时间</span>
        <span class="hljs-type">Calendar</span> <span class="hljs-variable">cal</span> <span class="hljs-operator">=</span> Calendar.getInstance();

        <span class="hljs-type">Calendar</span> <span class="hljs-variable">birthCalendar</span> <span class="hljs-operator">=</span> Calendar.getInstance();
        birthCalendar.setTime(birthDate);

        <span class="hljs-comment">//如果出生日期大于当前时间，则抛出异常</span>
        <span class="hljs-keyword">if</span> (cal.before(birthCalendar)) {
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
        }
        <span class="hljs-comment">//取出系统当前时间的年、月、日部分</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">yearNow</span> <span class="hljs-operator">=</span> cal.get(Calendar.YEAR);
        <span class="hljs-type">int</span> <span class="hljs-variable">monthNow</span> <span class="hljs-operator">=</span> cal.get(Calendar.MONTH);
        <span class="hljs-type">int</span> <span class="hljs-variable">dayOfMonthNow</span> <span class="hljs-operator">=</span> cal.get(Calendar.DAY_OF_MONTH);

        <span class="hljs-comment">//将日期设置为出生日期</span>
        cal.setTime(birthDate);
        <span class="hljs-comment">//取出出生日期的年、月、日部分</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">yearBirth</span> <span class="hljs-operator">=</span> cal.get(Calendar.YEAR);
        <span class="hljs-type">int</span> <span class="hljs-variable">monthBirth</span> <span class="hljs-operator">=</span> cal.get(Calendar.MONTH);
        <span class="hljs-type">int</span> <span class="hljs-variable">dayOfMonthBirth</span> <span class="hljs-operator">=</span> cal.get(Calendar.DAY_OF_MONTH);
        <span class="hljs-comment">//当前年份与出生年份相减，初步计算年龄</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> yearNow - yearBirth;
        <span class="hljs-comment">//当前月份与出生日期的月份相比，如果月份小于出生月份，则年龄上减1，表示不满多少周岁</span>
        <span class="hljs-keyword">if</span> (monthNow &lt;= monthBirth) {
            <span class="hljs-comment">//如果月份相等，在比较日期，如果当前日，小于出生日，也减1，表示不满多少周岁</span>
            <span class="hljs-keyword">if</span> (monthNow == monthBirth) {
                <span class="hljs-keyword">if</span> (dayOfMonthNow &lt; dayOfMonthBirth) age--;
            }<span class="hljs-keyword">else</span>{
                age--;
            }
        }
        <span class="hljs-keyword">return</span> age;

    }
    <span class="hljs-comment">//打印ArrayList&lt;? extends Person&gt;的方法</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printPersonList</span><span class="hljs-params">(ArrayList&lt;? extends Person&gt; personList)</span> {
        System.out.println(<span class="hljs-string">"************************************************************************************"</span>);
        System.out.println(<span class="hljs-string">"编号\t\t姓名\t\t性别\t\t生日\t\t\t年龄\t\t描述"</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; personList.size(); i++) {
            <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> personList.get(i);
            System.out.println(personList.get(i));
        }
        System.out.println(<span class="hljs-string">"************************************************************************************"</span>);
    }
    <span class="hljs-comment">//打印Person的方法</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printPerson</span><span class="hljs-params">(Person person)</span> {
        System.out.println(<span class="hljs-string">"************************************************************************************"</span>);
        System.out.println(<span class="hljs-string">"编号\t\t姓名\t\t性别\t\t生日\t\t\t年龄\t\t描述"</span>);
        System.out.println(person );
        System.out.println(<span class="hljs-string">"************************************************************************************"</span>);
    }
}
</code></pre></div>
<p>4.6 学员管理系统_主菜单和二级菜单实现</p>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.main;


<span class="hljs-keyword">import</span> com.itheima.student.Student;
<span class="hljs-keyword">import</span> com.itheima.teacher.Teacher;
<span class="hljs-keyword">import</span> com.itheima.utils.Utils;

<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Scanner;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainApp</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);
        <span class="hljs-comment">//学生集合</span>
        ArrayList&lt;Student&gt; stuList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        <span class="hljs-comment">//教师集合</span>
        ArrayList&lt;Teacher&gt; teaList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        <span class="hljs-comment">//主菜单</span>
        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
            System.out.println(<span class="hljs-string">"*****************************************"</span>);
            System.out.println(<span class="hljs-string">"* 1.学员信息管理   2.教师信息管理   3.退出 *"</span>);
            System.out.println(<span class="hljs-string">"*****************************************"</span>);
            <span class="hljs-type">int</span> <span class="hljs-variable">op</span> <span class="hljs-operator">=</span> sc.nextInt();
            <span class="hljs-keyword">switch</span> (op) {
                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
                    studentManage(stuList,sc);
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
                    teacherManage(teaList,sc);
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
                    System.out.println(<span class="hljs-string">"谢谢使用，拜拜！！"</span>);
                    System.exit(<span class="hljs-number">0</span>);
                <span class="hljs-keyword">default</span>:
                    System.out.println(<span class="hljs-string">"你的输入有误，请重新输入！"</span>);
                    <span class="hljs-keyword">break</span>;
            }
        }
    }
    <span class="hljs-comment">//教师信息管理-课堂练习</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">teacherManage</span><span class="hljs-params">(ArrayList&lt;Teacher&gt; teaList,Scanner sc)</span> {

    }

    <span class="hljs-comment">//学员信息管理</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">studentManage</span><span class="hljs-params">(ArrayList&lt;Student&gt; stuList,Scanner sc)</span> {
        <span class="hljs-comment">//二级菜单</span>
        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
            System.out.println(<span class="hljs-string">"------------------------------------------------------"</span>);
            System.out.println(<span class="hljs-string">"【学员信息管理】"</span>);
            System.out.println(<span class="hljs-string">"1.添加学员   2.修改学员   3.删除学员   4.查询学员   5.返回"</span>);
            System.out.println();
            System.out.println(<span class="hljs-string">"请输入功能序号："</span>);
            <span class="hljs-type">int</span> <span class="hljs-variable">op</span> <span class="hljs-operator">=</span> sc.nextInt();
            <span class="hljs-keyword">switch</span> (op) {
                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
                    addStudent(stuList, sc);
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
                    updateStudent(stuList, sc);
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
                    deleteStudent(stuList, sc);
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:
                    selectAll(stuList, sc);
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:
                    <span class="hljs-keyword">return</span>;
                <span class="hljs-keyword">default</span>:
                    System.out.println(<span class="hljs-string">"你的输入有误，请重新输入！"</span>);
                    <span class="hljs-keyword">break</span>;
            }
        }
    }
    
}
</code></pre></div>
<p>4.7 学员管理系统_添加学员</p>
<div><pre class="hljs"><code> <span class="hljs-comment">//添加学员</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addStudent</span><span class="hljs-params">(ArrayList&lt;Student&gt; stuList, Scanner sc)</span> {
        System.out.println(<span class="hljs-string">"请输入学员姓名："</span>);
        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> sc.next();
        System.out.println(<span class="hljs-string">"请输入性别："</span>);
        <span class="hljs-type">String</span> <span class="hljs-variable">sex</span> <span class="hljs-operator">=</span> sc.next();
        System.out.println(<span class="hljs-string">"请输入出生日期(yyyy-MM-dd)："</span>);
        <span class="hljs-type">String</span> <span class="hljs-variable">birthday</span> <span class="hljs-operator">=</span> sc.next();

        stuList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(++Utils.stuId,name,sex,birthday));

        System.out.println(<span class="hljs-string">"【成功】学员信息添加成功！"</span>);
    }</code></pre></div>
<p>4.8 学员管理系统_查询学员</p>
<div><pre class="hljs"><code><span class="hljs-comment">//查询所有学员</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectAll</span><span class="hljs-params">(ArrayList&lt;Student&gt; stuList, Scanner sc)</span> {
        System.out.println(<span class="hljs-string">"【查询结果】"</span>);
        <span class="hljs-keyword">if</span> (stuList.size() == <span class="hljs-number">0</span>) {
            System.out.println(<span class="hljs-string">"无数据"</span>);
            <span class="hljs-keyword">return</span>;
        }
        Utils.printPersonList(stuList);
    }</code></pre></div>
<p>4.9 学员管理系统__修改学员</p>
<div><pre class="hljs"><code>    <span class="hljs-comment">//修改学员</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateStudent</span><span class="hljs-params">(ArrayList&lt;Student&gt; stuList, Scanner sc)</span> {
        System.out.println(<span class="hljs-string">"请输入要修改的学员ID："</span>);
        <span class="hljs-type">int</span> <span class="hljs-variable">stuId</span> <span class="hljs-operator">=</span> sc.nextInt();
        <span class="hljs-comment">//查询</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; stuList.size(); i++) {
            <span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> stuList.get(i);
            <span class="hljs-keyword">if</span> (stu.getId() == stuId) {
                System.out.println(<span class="hljs-string">"【查询结果】要修改的学员信息："</span>);
                <span class="hljs-comment">//打印</span>
                Utils.printPerson(stu);
                <span class="hljs-comment">//执行修改</span>
                System.out.println(<span class="hljs-string">"请输入新姓名(保留原值输入0)："</span>);
                <span class="hljs-type">String</span> <span class="hljs-variable">newName</span> <span class="hljs-operator">=</span> sc.next();
                System.out.println(<span class="hljs-string">"请输入新性别(保留原值输入0)："</span>);
                <span class="hljs-type">String</span> <span class="hljs-variable">newSex</span> <span class="hljs-operator">=</span> sc.next();
                System.out.println(<span class="hljs-string">"请输入新出生日期(yyyy-MM-dd)(保留原值输入0)："</span>);
                <span class="hljs-type">String</span> <span class="hljs-variable">newBirthday</span> <span class="hljs-operator">=</span> sc.next();

                <span class="hljs-keyword">if</span> (!<span class="hljs-string">"0"</span>.equals(newName)) {
                    stu.setName(newName);
                }
                <span class="hljs-keyword">if</span> (!<span class="hljs-string">"0"</span>.equals(newSex)) {
                    stu.setSex(newSex);
                }
                <span class="hljs-keyword">if</span> (!<span class="hljs-string">"0"</span>.equals(newBirthday)) {
                    stu.setBirthday(newBirthday);
                }
                System.out.println(<span class="hljs-string">"【成功】学员信息修改成功！"</span>);
                <span class="hljs-keyword">return</span>;
            }

        }
        System.out.println(<span class="hljs-string">"【错误】学员ID："</span> + stuId + <span class="hljs-string">" 没找到！"</span>);
    }</code></pre></div>
<p>4.10 学员管理系统_删除学员</p>
<div><pre class="hljs"><code>    <span class="hljs-comment">//删除学员</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteStudent</span><span class="hljs-params">(ArrayList&lt;Student&gt; stuList, Scanner sc)</span> {
        System.out.println(<span class="hljs-string">"请输入要删除的学员ID："</span>);
        <span class="hljs-type">int</span> <span class="hljs-variable">stuId</span> <span class="hljs-operator">=</span> sc.nextInt();
        <span class="hljs-comment">//查询</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; stuList.size(); i++) {
            <span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> stuList.get(i);
            <span class="hljs-keyword">if</span> (stu.getId() == stuId) {
                System.out.println(<span class="hljs-string">"【查询结果】要删除的学员信息："</span>);
                Utils.printPerson(stu);
                System.out.println(<span class="hljs-string">"【确认】您确定要删除这条信息吗(y/n)？"</span>);
                <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> sc.next();
                <span class="hljs-keyword">if</span> (<span class="hljs-string">"y"</span>.equals(str)) {
                    stuList.remove(i);
                    System.out.println(<span class="hljs-string">"【成功】数据已被删除！"</span>);
                    <span class="hljs-keyword">return</span>;<span class="hljs-comment">//结束方法</span>
                }<span class="hljs-keyword">else</span>{
                    System.out.println(<span class="hljs-string">"【取消】操作被取消！"</span>);
                    <span class="hljs-keyword">return</span>;
                }

            }

        }
        System.out.println(<span class="hljs-string">"【错误】学员ID："</span> + stuId + <span class="hljs-string">" 未找到！"</span>);
    }</code></pre></div>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[day06-List及其子类、Collections、Set及其子类]]></title>
            <guid>9cc8e2b413594a5ebe46fd398d74ccdc</guid>
            <pubDate>Fri, 26 Nov 2021 09:38:39 GMT</pubDate>
            <content:encoded><![CDATA[<nav class="table-of-contents"><ul><li><a href="#学习目标">学习目标</a></li><li><a href="#第一章-list接口">第一章 List接口</a><ul><li><a href="#1list接口的概述">1.List接口的概述</a></li><li><a href="#2list接口中常用的方法重点">2.List接口中常用的方法(重点)</a></li><li><a href="#3arraylist集合数组">3.ArrayList集合(数组)</a></li><li><a href="#4linkedlist集合双向链表">4.LinkedList集合(双向链表)</a><ul><li><a href="#alinkedlist集合概述">a.LinkedList集合概述</a></li><li><a href="#blinkedlist集合特有的方法使用">b.LinkedList集合特有的方法(使用)</a></li></ul></li><li><a href="#5vector集合扩展-了解">5.Vector集合(扩展-了解)</a></li></ul></li><li><a href="#第二章-collections类">第二章 Collections类</a><ul><li><a href="#1collections的常用功能重点">1.Collections的常用功能(重点)</a></li><li><a href="#2comparator比较器重点">2.Comparator比较器(重点)</a></li><li><a href="#3对student进行排序指定排序的规则">3.对Student进行排序(指定排序的规则)</a></li><li><a href="#4可变参数">4.可变参数</a></li><li><a href="#5collections集合工具类中的方法addall">5.Collections集合工具类中的方法addAll</a></li></ul></li><li><a href="#第三章-set接口">第三章 Set接口</a><ul><li><a href="#1set接口的介绍记住">1.Set接口的介绍(记住)</a></li><li><a href="#2hashset集合的介绍和基本使用重点">2.HashSet集合的介绍和基本使用(重点)</a></li><li><a href="#3哈希值扩展-了解">3.哈希值(扩展-了解)</a></li><li><a href="#4string类的哈希值扩展-了解">4.String类的哈希值(扩展-了解)</a></li><li><a href="#5hashset集合存储数据的结构哈希表">5.HashSet集合存储数据的结构（哈希表）</a></li><li><a href="#6使用hashset集合存储string不重复的原理扩展-了解">6.使用HashSet集合存储String不重复的原理(扩展-了解)</a></li><li><a href="#7hashset存储自定义类型元素重点中的重点">7.HashSet存储自定义类型元素(重点中的重点)</a></li><li><a href="#2linkedhashset集合了解">2.LinkedHashSet集合(了解)</a></li><li><a href="#3treeset集合使用">3.TreeSet集合(使用)</a></li></ul></li></ul></nav><h1 id="学习目标">学习目标</h1>
<div><pre class="hljs"><code>能够说出List集合特点
    <span class="hljs-number">1.</span>有序
    <span class="hljs-number">2.</span>允许存储重复的元素
    <span class="hljs-number">3.</span>有带索引的特有方法(练习 add,remove,set,get)
能够使用集合工具类
    Collections类:
        <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(List&lt;T&gt; list)</span> 根据元素的自然顺序 对指定列表按升序进行排序。
        <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(List&lt;T&gt; list, Comparator&lt;? <span class="hljs-built_in">super</span> T&gt; c)</span> 根据指定比较器产生的顺序对指定列表进行排序。
        <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shuffle</span><span class="hljs-params">(List&lt;?&gt; list)</span>  随机打乱集合中元素的顺序
能够使用Comparator比较器进行排序
    Collections.sort(list01, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() {
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> {
            <span class="hljs-comment">//降序: o2-o1  升序:o1-o2</span>
            <span class="hljs-keyword">return</span> o2-o1;
        }
    });
能够使用可变参数
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(<span class="hljs-type">int</span>...arr)</span>{}
    调用method方法,参数是一个可变参数,可以接收任意个同种数据类型的数据
    method(),method(<span class="hljs-number">10</span>),method(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>)...
能够说出Set集合的特点
    <span class="hljs-number">1.</span>不允许存储重复的元素
    <span class="hljs-number">2.</span>不包含带索引的方法
能够说出哈希表的特点
    JDK1<span class="hljs-number">.8</span>之前:数组+单向链表
    JDK1<span class="hljs-number">.8</span>之后:数组+单向链表|数组+红黑树
    查询的效率高
使用HashSet集合存储自定义元素(重点)
    想要保证存储的元素(Person对象,Student对象...)同名和同年龄的人视为同一个人
    自定义类型(Person对象,Student对象...)必须重写hashCode和equals方法</code></pre></div>
<h1 id="第一章-list接口">第一章 List接口</h1>
<h2 id="1list接口的概述">1.List接口的概述</h2>
<div><pre class="hljs"><code><span class="hljs-comment">/*
    java.uil.List&lt;E&gt;接口 extends Collection&lt;E&gt;接口
    List接口的特点:
        1.是一个有序的集合:存储元素和取出元素的顺序是一致的  存储:123  取出:123
        2.允许存储重复的元素  add(10)  add(10)
        3.包含一些带索引的特有方法
    List接口特有的带索引的方法:
        void add(int index, E element)  在指定索引处,添加一个新的元素
        E get(int index)  获取指定索引处的元素
        E remove(int index)  移除并返回指定索引处的元素,返回的就是被移除的元素
        E set(int index, E element)  替换并返回指定索引处的元素,返回的是被替换的元素
    注意:
        使用带索引的方法,必须防止索引越界异常(不要超过集合索引的使用范围:0--&gt;集合的长度-1)         
 */</span></code></pre></div>
<h2 id="2list接口中常用的方法重点">2.List接口中常用的方法(重点)</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo01List;

<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Iterator;
<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-comment">/*
    List接口中常用的方法(重点)
    IndexOutOfBoundsException:索引越界异常,一般集合会抛出
        StringIndexOutOfBoundsException:字符串索引越界异常
        ArrayIndexOutOfBoundsException:数组索引越界异常
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01List</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">//创建List集合对象</span>
        List&lt;String&gt; list =<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        list.add(<span class="hljs-string">"aaa"</span>);
        list.add(<span class="hljs-string">"bbb"</span>);
        list.add(<span class="hljs-string">"ccc"</span>);
        list.add(<span class="hljs-string">"aaa"</span>);
        list.add(<span class="hljs-string">"ddd"</span>);
        System.out.println(list);<span class="hljs-comment">//[aaa, bbb, ccc, aaa, ddd]</span>

        <span class="hljs-comment">//void add(int index, E element)  在指定索引处,添加一个新的元素</span>
        <span class="hljs-comment">//需求:在2索引处添加一个元素"你好"</span>
        list.add(<span class="hljs-number">2</span>,<span class="hljs-string">"你好"</span>);
        System.out.println(list);<span class="hljs-comment">//[aaa, bbb, 你好, ccc, aaa, ddd]</span>

        <span class="hljs-comment">//E get(int index)  获取指定索引处的元素</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">0</span>);
        System.out.println(<span class="hljs-string">"s1:"</span>+s1);<span class="hljs-comment">//s1:aaa</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">3</span>);
        System.out.println(<span class="hljs-string">"s2:"</span>+s2);<span class="hljs-comment">//s2:ccc</span>
        <span class="hljs-comment">//String s3 = list.get(10);//IndexOutOfBoundsException: Index: 10, Size: 6</span>

        <span class="hljs-comment">//E remove(int index)  移除并返回指定索引处的元素,返回的就是被移除的元素</span>
        <span class="hljs-comment">//需求:移除ccc和ddd之间的aaa</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> list.remove(<span class="hljs-number">4</span>);
        System.out.println(<span class="hljs-string">"s4:"</span>+s4);<span class="hljs-comment">//s4:aaa 被移除的元素</span>
        System.out.println(list);<span class="hljs-comment">//[aaa, bbb, 你好, ccc, ddd]</span>

        <span class="hljs-comment">//E set(int index, E element)  替换并返回指定索引处的元素,返回的是被替换的元素</span>
        <span class="hljs-comment">//需求:把"你好",替换为"大家好"</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">s5</span> <span class="hljs-operator">=</span> list.set(<span class="hljs-number">2</span>, <span class="hljs-string">"大家好"</span>);
        System.out.println(<span class="hljs-string">"s5:"</span>+s5);<span class="hljs-comment">//s5:你好 被替换的元素</span>
        System.out.println(list);<span class="hljs-comment">//[aaa, bbb, 大家好, ccc, ddd]</span>
        System.out.println(<span class="hljs-string">"-------------------使用普通for循环遍历------------------------"</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) {
            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> list.get(i);
            System.out.println(s);
        }
        System.out.println(<span class="hljs-string">"-------------------使用迭代器遍历------------------------"</span>);
        Iterator&lt;String&gt; it = list.iterator();
        <span class="hljs-keyword">while</span> (it.hasNext()){
            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> it.next();
            System.out.println(s);
        }
        System.out.println(<span class="hljs-string">"-------------------使用增强for循环遍历------------------------"</span>);
        <span class="hljs-keyword">for</span> (String s : list) {
            System.out.println(s);
        }
    }
}</code></pre></div>
<h2 id="3arraylist集合数组">3.ArrayList集合(数组)</h2>
<div><pre class="hljs"><code><span class="hljs-comment">/*
    java.util.ArrayList&lt;E&gt;集合 implements List&lt;E&gt;接口
    List 接口的大小可变数组的实现。
    ArrayList集合底层采用的就是数组结构:查询快,增删慢
    工作中:查询多的时候使用,不对集合的长度进行修改(添加,删除)
*/</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;E&gt;{
    <span class="hljs-keyword">transient</span> Object[] elementData = {};
    add方法:
    list.add(<span class="hljs-string">"aaa"</span>);	
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> {
        ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span>
        elementData[size++] = e;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
    ...
    <span class="hljs-comment">//add方法底层:创建一个新的数组,长度是源数组长度+1,把源数组中的元素使用System类中的arraycopy方法复制到新的数组中    </span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="hljs-type">int</span> newLength, Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">T</span>[]&gt; newType) {
        <span class="hljs-meta">@SuppressWarnings("unchecked")</span>
        T[] copy = ((Object)newType == (Object)Object[].class)
            ? (T[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[newLength]
            : (T[]) Array.newInstance(newType.getComponentType(), newLength);
        System.arraycopy(original, <span class="hljs-number">0</span>, copy, <span class="hljs-number">0</span>,
                         Math.min(original.length, newLength));
        <span class="hljs-keyword">return</span> copy;
    }   
    
}</code></pre></div>
<h2 id="4linkedlist集合双向链表">4.LinkedList集合(双向链表)</h2>
<h3 id="alinkedlist集合概述">a.LinkedList集合概述</h3>
<p><img src="/_resources/f31da0df0bfb44a18e3cb60f80094152.png" /></p>
<div><pre class="hljs"><code><span class="hljs-comment">/*
    java.util.LinkedList&lt;E&gt; implements List&lt;E&gt;接口
    List 接口的链接列表实现。
    LinkedList集合底层是一个双向链表:查询慢,增删快
    双向:是一个有序的集合
    LinkedList集合中含有一些操作链表首尾元素的方法:
        public void addFirst(E e) :将指定元素插入此列表的开头。
        public void push(E e) :将元素推入此列表所表示的堆栈。
        public void addLast(E e) :将指定元素添加到此列表的结尾。
        
        public E getFirst() :返回此列表的第一个元素。
        public E getLast() :返回此列表的最后一个元素。
        public boolean isEmpty() ：如果列表不包含元素，则返回true
        
        public E removeFirst() :移除并返回此列表的第一个元素。
        public E pop() :从此列表所表示的堆栈处弹出一个元素。
        public E removeLast() :移除并返回此列表的最后一个元素。

   注意:
   		使用LinkedList集合特有的方法,不能使用多态创建对象
   		List&lt;String&gt; list = new LinkedList&lt;&gt;();弊端:不能是实现类特有的方法
   		LinkedList&lt;String&gt; linked = (LinkedList&lt;String&gt;)list; 向下转型
   		Collection&lt;String&gt; list = new LinkedList&lt;&gt;();弊端:不能是实现类特有的方法
   		LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;();
*/</span></code></pre></div>
<h3 id="blinkedlist集合特有的方法使用">b.LinkedList集合特有的方法(使用)</h3>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo01List;

<span class="hljs-keyword">import</span> java.util.LinkedList;

<span class="hljs-comment">/*
    LinkedList集合特有的方法(使用)
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo02LinkedList</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        show04();
    }

    <span class="hljs-comment">/*
        public E removeFirst() :移除并返回此列表的第一个元素。
        public E pop() :从此列表所表示的堆栈处弹出一个元素。此方法等效于 removeFirst()。
        public E removeLast() :移除并返回此列表的最后一个元素。
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show04</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">//创建LinkedList集合对象</span>
        LinkedList&lt;String&gt; linked = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
        <span class="hljs-comment">//往集合中添加元素</span>
        linked.add(<span class="hljs-string">"aaa"</span>);
        linked.add(<span class="hljs-string">"bbb"</span>);
        linked.add(<span class="hljs-string">"ccc"</span>);
        linked.add(<span class="hljs-string">"ddd"</span>);
        System.out.println(linked);<span class="hljs-comment">//[aaa, bbb, ccc, ddd]</span>

        <span class="hljs-comment">//public E removeFirst() :移除并返回此列表的第一个元素。</span>
        <span class="hljs-comment">//String first = linked.removeFirst();</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> linked.pop();
        System.out.println(<span class="hljs-string">"first:"</span>+first);<span class="hljs-comment">//first:aaa</span>
        System.out.println(linked);<span class="hljs-comment">//[bbb, ccc, ddd]</span>

        <span class="hljs-comment">//public E removeLast() :移除并返回此列表的最后一个元素。</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> linked.removeLast();
        System.out.println(<span class="hljs-string">"last:"</span>+last);<span class="hljs-comment">//last:ddd</span>
        System.out.println(linked);<span class="hljs-comment">//[bbb, ccc]</span>
    }

    <span class="hljs-comment">/*
        public E getFirst() :返回此列表的第一个元素。
        public E getLast() :返回此列表的最后一个元素。
        public boolean isEmpty() ：如果列表不包含元素，则返回true
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show03</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">//创建LinkedList集合对象</span>
        LinkedList&lt;String&gt; linked = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
        <span class="hljs-comment">//往集合中添加元素</span>
        linked.add(<span class="hljs-string">"aaa"</span>);
        linked.add(<span class="hljs-string">"bbb"</span>);
        linked.add(<span class="hljs-string">"ccc"</span>);
        linked.add(<span class="hljs-string">"ddd"</span>);

        <span class="hljs-comment">//linked.clear();//清空集合</span>

        System.out.println(linked);<span class="hljs-comment">//[]</span>

        <span class="hljs-comment">//增加一个判断,集合不是空的,在获取首尾元素,防止NoSuchElementException:没有这个元素异常</span>
        <span class="hljs-keyword">if</span>(!linked.isEmpty()){
            <span class="hljs-comment">//public E getFirst() :返回此列表的第一个元素。</span>
            <span class="hljs-type">String</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> linked.getFirst();
            System.out.println(<span class="hljs-string">"first:"</span>+first);<span class="hljs-comment">//first:aaa</span>

            <span class="hljs-comment">//public E getLast() :返回此列表的最后一个元素。</span>
            <span class="hljs-type">String</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> linked.getLast();
            System.out.println(<span class="hljs-string">"last:"</span>+last);
        }

    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show02</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">//创建LinkedList集合对象</span>
        LinkedList&lt;String&gt; linked = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
        linked.addFirst(<span class="hljs-string">"a"</span>);
        linked.addFirst(<span class="hljs-string">"b"</span>);
        linked.addFirst(<span class="hljs-string">"c"</span>);
        linked.addLast(<span class="hljs-string">"1"</span>);
        linked.addLast(<span class="hljs-string">"2"</span>);
        linked.addLast(<span class="hljs-string">"3"</span>);
        System.out.println(linked);<span class="hljs-comment">//[c, b, a, 1, 2, 3]</span>
    }

    <span class="hljs-comment">/*
        public void addFirst(E e) :将指定元素插入此列表的开头。
        public void push(E e) :将元素推入此列表所表示的堆栈。此方法等效于 addFirst(E)。
        public void addLast(E e) :将指定元素添加到此列表的结尾。
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show01</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">//创建LinkedList集合对象</span>
        LinkedList&lt;String&gt; linked = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
        <span class="hljs-comment">//往集合中添加元素</span>
        linked.add(<span class="hljs-string">"aaa"</span>);
        linked.add(<span class="hljs-string">"bbb"</span>);
        linked.add(<span class="hljs-string">"ccc"</span>);
        linked.add(<span class="hljs-string">"ddd"</span>);
        System.out.println(linked);<span class="hljs-comment">//[aaa, bbb, ccc, ddd]</span>

        <span class="hljs-comment">//public void addFirst(E e) :将指定元素插入此列表的开头。</span>
        <span class="hljs-comment">//linked.addFirst("www");</span>
        linked.push(<span class="hljs-string">"www"</span>);
        System.out.println(linked);<span class="hljs-comment">//[www, aaa, bbb, ccc, ddd]</span>

        <span class="hljs-comment">//public void addLast(E e) :将指定元素添加到此列表的结尾。</span>
        linked.addLast(<span class="hljs-string">"com"</span>);
        System.out.println(linked);<span class="hljs-comment">//[www, aaa, bbb, ccc, ddd, com]</span>
    }
}
</code></pre></div>
<h2 id="5vector集合扩展-了解">5.Vector集合(扩展-了解)</h2>
<div><pre class="hljs"><code><span class="hljs-comment">/*
    java.util.Vector&lt;E&gt; implements List&lt;E&gt;(jdk1.2之后)
    Vector是JDK1.0时期存在的单列集合,Collection下边的其他集合(ArrayList,LinkedList...)是JDK1.2之后出现的
    Vector 类可以实现可增长的对象数组。Vector集合底层和ArrayList集合是一样的,也是一个数组结构(查询快,增删慢)
    Vector集合1.0时期有一些特有的方法:
    	void addElement(E obj)  往集合中添加元素
    	Enumeration&lt;E&gt; elements() 返回此向量的组件的枚举。 
    	Enumeration&lt;E&gt;接口:向量枚举,是1.0时期的迭代器
    		boolean hasMoreElements()  判断集合中还有没有元素==&gt;hasNext
    		E nextElement()  取出集合的元素==&gt;next
    与新 collection 实现不同，Vector 是同步的。 
    同步技术:可以保证多线程的安全
    同步技术:集合存储数据效率低
    所以Vector集合被效率更高的ArrayList集合取代了
*/</span></code></pre></div>
<h1 id="第二章-collections类">第二章 Collections类</h1>
<h2 id="1collections的常用功能重点">1.Collections的常用功能(重点)</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo02Collections;

<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Collections;

<span class="hljs-comment">/*
    java.util.Collections:操作集合的工具类,里边的方法都是静态的,通过类名可以直接调用
        sort:排序  升序:小==&gt;大  降序:大==&gt;小
        static void sort(List&lt;T&gt; list) 根据元素的自然顺序 对指定列表(集合)按升序进行排序。
        static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) 根据指定比较器产生的顺序对指定列表进行排序。
        static void shuffle(List&lt;?&gt; list) 随机打乱集合中元素的顺序
    注意:
        以上3个方法的参数只能传递List接口下的集合(ArrayList,LinkedList),不能传递Set接口下的集合
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01Collections</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        ArrayList&lt;Integer&gt; list01 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        list01.add(<span class="hljs-number">3</span>);
        list01.add(<span class="hljs-number">4</span>);
        list01.add(<span class="hljs-number">1</span>);
        list01.add(<span class="hljs-number">2</span>);
        System.out.println(list01);<span class="hljs-comment">//[3, 4, 1, 2]</span>

        <span class="hljs-comment">/*
            static void sort(List&lt;T&gt; list) 根据元素的自然顺序 对指定列表(集合)按升序进行排序。
         */</span>
        Collections.sort(list01);
        System.out.println(list01);<span class="hljs-comment">//[1, 2, 3, 4]</span>

        <span class="hljs-comment">/*
            static void shuffle(List&lt;?&gt; list) 随机打乱集合中元素的顺序
         */</span>
        Collections.shuffle(list01);
        System.out.println(list01);<span class="hljs-comment">//[4, 2, 3, 1] [3, 1, 2, 4] [4, 1, 2, 3]...</span>

        ArrayList&lt;String&gt; list02 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        list02.add(<span class="hljs-string">"ac"</span>);
        list02.add(<span class="hljs-string">"aa"</span>);
        list02.add(<span class="hljs-string">"12"</span>);
        list02.add(<span class="hljs-string">"AB"</span>);
        list02.add(<span class="hljs-string">"AA"</span>);
        System.out.println(list02);<span class="hljs-comment">//[ac, aa, 12, AB, AA]</span>

        <span class="hljs-comment">/*
            static void sort(List&lt;T&gt; list) 根据元素的自然顺序 对指定列表(集合)按升序进行排序。
            自然顺序:编码表的顺序  ASCII表
            48:'0'  65:'A'  97:'a'
         */</span>
        Collections.sort(list02);
        System.out.println(list02);<span class="hljs-comment">//[12, AA, AB, aa, ac]</span>
    }
}</code></pre></div>
<h2 id="2comparator比较器重点">2.Comparator比较器(重点)</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo02Collections;

<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Collections;
<span class="hljs-keyword">import</span> java.util.Comparator;

<span class="hljs-comment">/*
    static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) 根据指定比较器产生的顺序对指定列表进行排序。
    参数:
        List&lt;T&gt; list:传递要排序的List集合
        Comparator&lt;? super T&gt; c:比较器
    java.util.Comparator&lt;T&gt;接口:强行对某个对象 collection 进行整体排序 的比较函数。
    接口中的抽象方法:
        int compare(T o1, T o2) 比较用来排序的两个参数。
        T o1, T o2:依次获取到集合中相邻的元素,进行比较
    排序的规则:
        o1-o2:升序
        o2-o1:降序
        o1==o2:两个元素相等
    匿名内部类:没有名字的类中类
        简化代码:结果就是一个子类|实现类对象
            可以把子类继承父类,重写父类方法,创建子类对象合成一步完成
            可以把实现类实现接口,重写接口中的方法,创建实现类对象合成一步完成
        格式:
            new 爹(){
                重写父类|接口中的方法
            };
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo02Comparator</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        ArrayList&lt;Integer&gt; list01 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        list01.add(<span class="hljs-number">3</span>);
        list01.add(<span class="hljs-number">4</span>);
        list01.add(<span class="hljs-number">4</span>);
        list01.add(<span class="hljs-number">1</span>);
        list01.add(<span class="hljs-number">2</span>);
        System.out.println(list01);<span class="hljs-comment">//[3, 4, 1, 2]</span>

        <span class="hljs-comment">//static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) 根据指定比较器产生的顺序对指定列表进行排序。</span>
        Collections.sort(list01, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> {
                <span class="hljs-comment">//o2-o1:降序</span>
                <span class="hljs-keyword">return</span> o2-o1;
            }
        });
        System.out.println(list01);<span class="hljs-comment">//[4, 4, 3, 2, 1]</span>

        Collections.sort(list01, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> {
                <span class="hljs-comment">//o1-o2:升序</span>
                <span class="hljs-keyword">return</span> o1-o2;
            }
        });
        System.out.println(list01);<span class="hljs-comment">//[1, 2, 3, 4, 4]</span>

        ArrayList&lt;String&gt; list02 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        list02.add(<span class="hljs-string">"ac"</span>);
        list02.add(<span class="hljs-string">"aa"</span>);
        list02.add(<span class="hljs-string">"中"</span>);
        list02.add(<span class="hljs-string">"12"</span>);
        list02.add(<span class="hljs-string">"AB"</span>);
        list02.add(<span class="hljs-string">"AA"</span>);
        System.out.println(list02);<span class="hljs-comment">//[ac, aa, 12, AB, AA]</span>
        Collections.sort(list02, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;String&gt;() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(String o1, String o2)</span> {
                <span class="hljs-comment">//按照字符串的首字母降序排序</span>
                <span class="hljs-keyword">return</span> o2.charAt(<span class="hljs-number">0</span>)-o1.charAt(<span class="hljs-number">0</span>);
            }
        });
        <span class="hljs-comment">//System.out.println("ac".charAt(0)-"aa".charAt(0));</span>
        <span class="hljs-comment">//System.out.println('a'+0);//97</span>
        <span class="hljs-comment">//System.out.println('中'+0);//20013</span>
        System.out.println(list02);
    }
}</code></pre></div>
<h2 id="3对student进行排序指定排序的规则">3.对Student进行排序(指定排序的规则)</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo02Collections;

<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Collections;
<span class="hljs-keyword">import</span> java.util.Comparator;

<span class="hljs-comment">/*
    对学生Student进行排序
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo03Student</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        ArrayList&lt;Student&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">"azhagnsan"</span>,<span class="hljs-number">18</span>));
        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">"lisi"</span>,<span class="hljs-number">20</span>));
        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">"wangwu"</span>,<span class="hljs-number">22</span>));
        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">"bzhaoliu"</span>,<span class="hljs-number">18</span>));
        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">"tianqi"</span>,<span class="hljs-number">21</span>));
        Collections.sort(list, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Student&gt;() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Student o1, Student o2)</span> {
                <span class="hljs-comment">//按照学生的年龄升序排序</span>
                <span class="hljs-keyword">return</span> o1.getAge()-o2.getAge();
            }
        });
        <span class="hljs-keyword">for</span> (Student s : list) {
            System.out.println(s);
        }
        Collections.sort(list, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Student&gt;() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Student o1, Student o2)</span> {
                <span class="hljs-comment">//按照学生的年龄升序排序</span>
                <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span>  o1.getAge()-o2.getAge();
                <span class="hljs-keyword">if</span>(a==<span class="hljs-number">0</span>){
                    <span class="hljs-comment">//两个学生年龄相等,按照姓名的首字母降序排序</span>
                    <span class="hljs-comment">//a=o2.getName().charAt(0)-o1.getName().charAt(0);</span>
                    <span class="hljs-comment">//按照姓名降序排序==&gt;String类</span>
                    <span class="hljs-comment">//int compareTo(String anotherString)按字典(编码表)顺序比较两个字符串。依次比较每一个字符</span>
                    a = o2.getName().compareTo(o1.getName());
                }
                <span class="hljs-keyword">return</span> a;
            }
        });
        System.out.println(<span class="hljs-string">"---------------------------------"</span>);
        <span class="hljs-keyword">for</span> (Student s : list) {
            System.out.println(s);
        }
    }
}</code></pre></div>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo02Collections;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> {
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> {
    }

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> {
        <span class="hljs-built_in">this</span>.name = name;
        <span class="hljs-built_in">this</span>.age = age;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Student{"</span> +
                <span class="hljs-string">"name='"</span> + name + <span class="hljs-string">'\''</span> +
                <span class="hljs-string">", age="</span> + age +
                <span class="hljs-string">'}'</span>;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> {
        <span class="hljs-built_in">this</span>.name = name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> age;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> {
        <span class="hljs-built_in">this</span>.age = age;
    }
}</code></pre></div>
<h2 id="4可变参数">4.可变参数</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo03varArgs;

<span class="hljs-comment">/*
    可变参数:
        当我们定义一个方法,方法参数列表的参数的类型已经确定了,但是个数不确定,就可以使用可变参数
        是JDK1.5之后出现的
    格式:
        修饰符 返回值类型 方法名(数据类型...变量名){
            方法体;
        }
    数据类型...变量名==&gt;可变参数
    int...a:可以接收任意个int类型的整数
    String...b:可以接收任意个String类型的整数
    底层原理:
        可以参数的底层就是一个数组,传递不同个数个参数,会创建不同长度的数组,来存储数据
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01VarArgs</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">//getSum();</span>
        <span class="hljs-comment">//getSum(10);</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> getSum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);
        System.out.println(<span class="hljs-string">"s1:"</span>+s1);
        <span class="hljs-comment">//int sum = getSum(10, 20, 30, 40, 50, 60, 70, 80, 90, 100);</span>
        <span class="hljs-comment">//System.out.println(sum);//550</span>
    }

    <span class="hljs-comment">/*
        定义一个计算n个int类型整数和的方法
            n个:0个,1个,2个,3个,100个...1000个...100000个...
        需求:
            数据类型确定:int
            参数个数不确定:n个
        使用可变参数解决:可以接收任意个
        getSum();传递0个参数,可变参数就会创建一个长度为0的数组,存储数据 int[] arr = new int[]{ };
        getSum(10);传递1个参数,可变参数就会创建一个长度为1的数组,存储数据 int[] arr = new int[]{10};
        getSum(10,20);传递2个参数,可变参数就会创建一个长度为2的数组,存储数据 int[] arr = new int[]{10,20};
        ...
        getSum(10,20,30,40,50,60,70,80,90,100);传递10个参数
            可变参数就会创建一个长度为10的数组,存储数据 int[] arr = new int[]{10,20,30,40,50,60,70,80,90,100};
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSum</span><span class="hljs-params">(<span class="hljs-type">int</span>...arr)</span>{
        <span class="hljs-comment">//System.out.println(arr);//[I@4554617c</span>
        <span class="hljs-comment">//System.out.println(arr.length);//0,1,2</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : arr) {
            sum+=i;
        }
        <span class="hljs-keyword">return</span> sum;
    }

    <span class="hljs-comment">/*
        定义一个计算四个int类型整数和的方法
     */</span>
    <span class="hljs-comment">/*public static int getSum(int a,int b,int c,int d){
        return a+b+c+d;
    }*/</span>

    <span class="hljs-comment">/*
        定义一个计算三个int类型整数和的方法
     */</span>
    <span class="hljs-comment">/*public static int getSum(int a,int b,int c){
        return a+b+c;
    }*/</span>

    <span class="hljs-comment">/*
        定义一个计算两个int类型整数和的方法
     */</span>
    <span class="hljs-comment">/*public static int getSum(int a,int b){
        return a+b;
    }*/</span>
}</code></pre></div>
<p><strong>重点:记住可变参数可以接收任意个同种数据类型的元素</strong></p>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo03varArgs;

<span class="hljs-comment">/*
    可变参数的注意事项(了解)
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo02VarArgs</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        show04(<span class="hljs-number">10</span>,<span class="hljs-number">1.1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-string">"aa"</span>);
    }
    
    <span class="hljs-comment">//1.一个方法的参数列表如果有多个参数,可变参数必须写在末尾</span>
    <span class="hljs-comment">//Vararg parameter must be the last in the list</span>
    <span class="hljs-comment">//public static void show01(int a,double b,int...d,String s){}</span>
    
    <span class="hljs-comment">//2.一个方法的参数列表,只能写一个可变参数</span>
    <span class="hljs-comment">//public static void show02(String...s,int...a){}</span>
    
    <span class="hljs-comment">//以后查看源码可以看到</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show03</span><span class="hljs-params">(Object...obj)</span>{}
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T[] show04(T...t){
        <span class="hljs-keyword">return</span> t;
    }
}</code></pre></div>
<h2 id="5collections集合工具类中的方法addall">5.Collections集合工具类中的方法addAll</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo03varArgs;

<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Collections;

<span class="hljs-comment">/*
    Collections集合工具类中的方法addAll
    static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt; c, T... elements)
          将所有指定元素添加到指定 collection 中。
          一次往集合中添加多个元素
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo03Collections</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        list.add(<span class="hljs-number">1</span>);
        list.add(<span class="hljs-number">2</span>);
        list.add(<span class="hljs-number">3</span>);
        list.add(<span class="hljs-number">4</span>);
        list.add(<span class="hljs-number">5</span>);
        System.out.println(list);

        ArrayList&lt;Integer&gt; list02 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        Collections.addAll(list02,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>);
        System.out.println(list02);

        <span class="hljs-comment">//可变参数底层就是一个数组,所以可以传递可变参数的地方,都可以传递数组</span>
        Integer[] arr = {<span class="hljs-number">100</span>,<span class="hljs-number">200</span>,<span class="hljs-number">300</span>,<span class="hljs-number">400</span>,<span class="hljs-number">500</span>};
        Collections.addAll(list02,arr);
        System.out.println(list02);<span class="hljs-comment">//[1, 2, 3, 4, 5, 100, 200, 300, 400, 500]</span>
    }
}</code></pre></div>
<h1 id="第三章-set接口">第三章 Set接口</h1>
<h2 id="1set接口的介绍记住">1.Set接口的介绍(记住)</h2>
<div><pre class="hljs"><code><span class="hljs-comment">/*
    java.util.Set&lt;E&gt;接口 extends Collection&lt;E&gt;接口
    Set接口的特点:
        1.不允许存储重复的元素  add(1) add(1) ==&gt;集合中只有一个1
        2.不包含带索引的方法,里边的方法和Collection接口是一样
*/</span></code></pre></div>
<h2 id="2hashset集合的介绍和基本使用重点">2.HashSet集合的介绍和基本使用(重点)</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo04Set;

<span class="hljs-keyword">import</span> java.util.Collections;
<span class="hljs-keyword">import</span> java.util.HashSet;
<span class="hljs-keyword">import</span> java.util.Iterator;

<span class="hljs-comment">/*
    java.util.HashSet&lt;E&gt;集合 implements Set&lt;E&gt;接口
        此类实现 Set 接口，由哈希表（实际上是一个 HashMap 实例）支持。
        它不保证 set 的迭代顺序；特别是它不保证该顺序恒久不变。
    HashSet集合的特点:
        1.不允许存储重复的元素
        2.不包含带索引的方法(不能使用普通for循环遍历)
        3.底层是一个哈希表结构
            JDK1.8之前:数组+单向链表
            JDK1.8以后:数组+单向链表|数组+红黑树
        4.是一个无序的集合(存储的元素和取出元素顺序[有可能]不一致)
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01HashSet</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        HashSet&lt;String&gt; set1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();
        set1.add(<span class="hljs-string">"aaa"</span>);
        set1.add(<span class="hljs-string">"bbb"</span>);
        set1.add(<span class="hljs-string">"ccc"</span>);
        set1.add(<span class="hljs-string">"aaa"</span>);
        set1.add(<span class="hljs-string">"ddd"</span>);
        System.out.println(set1);<span class="hljs-comment">//[aaa, ccc, bbb, ddd]</span>
        <span class="hljs-comment">//使用迭代器遍历HashSet集合</span>
        Iterator&lt;String&gt; it = set1.iterator();
        <span class="hljs-keyword">while</span> (it.hasNext()){
            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> it.next();
            System.out.println(s);
        }
        System.out.println(<span class="hljs-string">"------------------------"</span>);
        HashSet&lt;Integer&gt; set2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();
        Collections.addAll(set2,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);
        System.out.println(set2);<span class="hljs-comment">//[1, 2, 3, 4, 5]</span>
        <span class="hljs-comment">//使用增强for循环遍历HashSet集合</span>
        <span class="hljs-keyword">for</span> (Integer in : set2) {
            System.out.println(in);
        }
    }
}</code></pre></div>
<h2 id="3哈希值扩展-了解">3.哈希值(扩展-了解)</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo04Set;

<span class="hljs-comment">/*
    哈希值:
        是一个十进制的整数,由操作系统随机给出,我们打印对象的地址值,使用的就是哈希值(逻辑地址)
        对象在内存中实际存储的地址,并不是哈希值的地址(物理地址)
    Object类有获取对象哈希值的方法:
        int hashCode() 返回该对象的哈希码值。
        hashCode方法的底层源码:
            public native int hashCode();
            native:调用的是操作系统底层的方法,不是由java语言编写的
   Object类的toString方法
        String toString() 返回该对象的字符串表示。
    底层源码:
        public String toString() {
            return getClass().getName() + "@" + Integer.toHexString(hashCode());
        }
        getClass().getName():使用反射技术,获取包名+类名  com.itheima.demo04Set.Person
        "@":字符串原样输出
        Integer.toHexString(hashCode()):把hashCode方法返回的十进制的整数,转换为十六进制
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo02HashCode</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();
        <span class="hljs-type">int</span> <span class="hljs-variable">h1</span> <span class="hljs-operator">=</span> p1.hashCode();
        System.out.println(h1);<span class="hljs-comment">//1163157884==&gt;重写后 1</span>
        System.out.println(p1.toString());<span class="hljs-comment">//com.itheima.demo04Set.Person@4554617c==&gt;重写后 1</span>
        <span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();
        <span class="hljs-type">int</span> <span class="hljs-variable">h2</span> <span class="hljs-operator">=</span> p2.hashCode();
        System.out.println(h2);<span class="hljs-comment">//1956725890==&gt;重写后 1</span>
        System.out.println(p2.toString());<span class="hljs-comment">//com.itheima.demo04Set.Person@74a14482==&gt;重写后 1</span>
        System.out.println(p1==p2);<span class="hljs-comment">//false 引用数据类型比较的是对象的地址值</span>
    }
}</code></pre></div>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo04Set;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Object</span>{
    <span class="hljs-comment">//重写Object类的hashCode方法</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }
}
</code></pre></div>
<h2 id="4string类的哈希值扩展-了解">4.String类的哈希值(扩展-了解)</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo04Set;

<span class="hljs-comment">/*
    String类的哈希值(了解)
        String类重写了Object类的hashCode方法
        规则:
            相同的字符串返回的哈希值是一样的
            不同的字符串,计算出的哈希值也有可能是一样
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo03StringHashCode</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"abc"</span>);
        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"abc"</span>);
        System.out.println(s1.hashCode());<span class="hljs-comment">//96354</span>
        System.out.println(s2.hashCode());<span class="hljs-comment">//96354</span>
        System.out.println(s1==s2);<span class="hljs-comment">//false</span>

        System.out.println(<span class="hljs-string">"重地"</span>.hashCode());<span class="hljs-comment">//1179395</span>
        System.out.println(<span class="hljs-string">'重'</span>+<span class="hljs-number">0</span>);<span class="hljs-comment">//37325</span>
        System.out.println(<span class="hljs-string">'地'</span>+<span class="hljs-number">0</span>);<span class="hljs-comment">//22320</span>

        System.out.println(<span class="hljs-string">"通话"</span>.hashCode());<span class="hljs-comment">//1179395</span>
    }
}</code></pre></div>
<p><img src="/_resources/1a9e506db1dc4da79034adeb690fb0d0.png" /></p>
<h2 id="5hashset集合存储数据的结构哈希表">5.HashSet集合存储数据的结构（哈希表）</h2>
<p><img src="/_resources/2323d60ece8a4fd383a7fd45bfa9ea27.png" /></p>
<h2 id="6使用hashset集合存储string不重复的原理扩展-了解">6.使用HashSet集合存储String不重复的原理(扩展-了解)</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo04Set;

<span class="hljs-keyword">import</span> java.util.HashSet;

<span class="hljs-comment">/*
    使用HashSet集合存储String不重复的原理(扩展-了解)
    String类重写了hashCode和equals方法,保证元素唯一
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo04HashSetSaveString</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        HashSet&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();
        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"abc"</span>);
        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"abc"</span>);
        set.add(s1);
        set.add(s2);
        set.add(<span class="hljs-string">"重地"</span>);
        set.add(<span class="hljs-string">"通话"</span>);
        set.add(<span class="hljs-string">"abc"</span>);
        System.out.println(set);<span class="hljs-comment">//[重地, 通话, abc]</span>
    }
}</code></pre></div>
<p><img src="/_resources/1e8412be46634fe88622e1e5a17c4c06.png" /></p>
<h2 id="7hashset存储自定义类型元素重点中的重点">7.HashSet存储自定义类型元素(重点中的重点)</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo04Set;

<span class="hljs-keyword">import</span> java.util.HashSet;

<span class="hljs-comment">/*
    HashSet存储自定义类型元素(重点中的重点)
    需求:
        同名同年龄的学生,认为是同一个学生,只能存储一次
    解决:
        自定义类型(Student,Person,Animal...),需要重写hashCode和equals方法,保证元素唯一
        alt+insert==&gt;选择equals and hashCode
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo05HashSetSaveStudent</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">//创建一个HashSet集合,泛型使用Student</span>
        HashSet&lt;Student&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();
        <span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">"a"</span>,<span class="hljs-number">10</span>);
        <span class="hljs-type">Student</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">"a"</span>,<span class="hljs-number">10</span>);
        System.out.println(s1.hashCode());<span class="hljs-comment">//1163157884==&gt;重写后107</span>
        System.out.println(s2.hashCode());<span class="hljs-comment">//1956725890==&gt;重写后107</span>
        set.add(s1);
        set.add(s2);
        <span class="hljs-type">Student</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">"b"</span>,<span class="hljs-number">9</span>);
        System.out.println(s3.hashCode());
        set.add(s3);
        <span class="hljs-keyword">for</span> (Student s : set) {
            System.out.println(s.getName()+<span class="hljs-string">"\t"</span>+s.getAge());
        }
    }
}</code></pre></div>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo04Set;

<span class="hljs-keyword">import</span> java.util.Objects;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> {
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> {
    }

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> {
        <span class="hljs-built_in">this</span>.name = name;
        <span class="hljs-built_in">this</span>.age = age;
    }

    <span class="hljs-comment">/*
        重写Object类中hashCode方法
        重写的规则:name本身就是一个字符串,直接调用字符串重写的hashCode方法+age
            name.hashCode()+age;
        --------------------------------------------------
        Student s1 = new Student("a",10); 哈希值:97+10=107
        Student s2 = new Student("a",10); 哈希值:97+10=107
        set.add(s1); 在集合中找,有没有107这个哈希值,发现没有,就会把s1存储到HashSet集合中
        set.add(s2); 在集合中找,有没有107这个哈希值,发现有, s2.equals(s1)==&gt;true
            两个元素哈希值相同,equals方法返回true,认定s2和s1完全相同,就不会把s2存储到HashSet集合中
        --------------------------------------------------
        Student s3 = new Student("b",9);哈希值:98+9=107
        set.add(s3);在集合中找,有没有107这个哈希值,发现有, s3.equals(s1)==&gt;false
            两个元素哈希值相同,equals方法返回false,认定s3和s1不同,就会把s3存储到HashSet集合中
        --------------------------------------------------
        降低不同元素,出现相同哈希值的概率
        name.hashCode()*2+age;
        Student s1 = new Student("a",10); 哈希值:97*2+10=194+10=204
        Student s3 = new Student("b",9);哈希值:98*2+9=196+9=205
        set.add(s3);在集合中找,有没有205这个哈希值,发现没有,直接把s3存储到HashSet集合中
        sun公司经过无数次计算,任意倍数扩大31被,重复的几率是最低
        name.hashCode()*31+age;
     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> (Student) o;
        <span class="hljs-type">return</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span>= student.age &amp;&amp;
                Objects.equals(name, student.name);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> Objects.hash(name, age);
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> {
        <span class="hljs-built_in">this</span>.name = name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> age;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> {
        <span class="hljs-built_in">this</span>.age = age;
    }
}</code></pre></div>
<p><img src="/_resources/40deb9479ce449cd96543562238e131d.png" /></p>
<h2 id="2linkedhashset集合了解">2.LinkedHashSet集合(了解)</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo04Set;

<span class="hljs-keyword">import</span> java.util.HashSet;
<span class="hljs-keyword">import</span> java.util.LinkedHashSet;

<span class="hljs-comment">/*
    java.util.LinkedHashSet&lt;E&gt;集合 extends HashSet&lt;E&gt;集合 implements Set&lt;E&gt;接口
        具有可预知迭代顺序的 Set 接口的哈希表和链接列表实现。
        此实现与 HashSet 的不同之外在于，后者维护着一个运行于所有条目的双重链接列表。
    LinkedHashSet特点:
        1.不允许存储重复元素
        2.不包含带索引的方法
        3.是一个有序的集合
        4.底层是哈希表+单向链表
            JDK1.8之前:数组+单向链表+单向链表
            JDK1.8之后:数组+单向链表+单向链表|数组+红黑树+单向链表
            底层就是一个双向链表的结构,是一个有序的集合
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo06LinkedHashSet</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        HashSet&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();
        set.add(<span class="hljs-string">"aaa"</span>);
        set.add(<span class="hljs-string">"bbb"</span>);
        set.add(<span class="hljs-string">"ccc"</span>);
        set.add(<span class="hljs-string">"aaa"</span>);
        set.add(<span class="hljs-string">"ddd"</span>);
        System.out.println(set);<span class="hljs-comment">//[aaa, ccc, bbb, ddd] 不允许存储重复元素,是一个无序的集合</span>

        LinkedHashSet&lt;String&gt; linked = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;();
        linked.add(<span class="hljs-string">"aaa"</span>);
        linked.add(<span class="hljs-string">"bbb"</span>);
        linked.add(<span class="hljs-string">"ccc"</span>);
        linked.add(<span class="hljs-string">"aaa"</span>);
        linked.add(<span class="hljs-string">"ddd"</span>);
        System.out.println(linked);<span class="hljs-comment">//[aaa, bbb, ccc, ddd] 不允许存储重复元素,是一个有序的集合</span>
    }
}</code></pre></div>
<h2 id="3treeset集合使用">3.TreeSet集合(使用)</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo04Set;

<span class="hljs-keyword">import</span> java.util.Comparator;
<span class="hljs-keyword">import</span> java.util.TreeSet;

<span class="hljs-comment">/*
    java.util.TreeSet&lt;E&gt;集合 implements Set&lt;E&gt;接口
        基于Set接口的红黑树的实现
        使用元素的自然顺序对元素进行排序(内部会使用Comparator比较器对元素进行默认的升序排序)
        或者根据创建TreeSet集合时提供的 Comparator 进行排序，具体取决于使用的构造方法。
    构造方法:
        TreeSet() 构造一个新的空 set，该 set 根据其元素的自然顺序进行排序。
        TreeSet(Comparator&lt;? super E&gt; comparator) 构造一个新的空 TreeSet，它根据指定比较器进行排序。
     TreeSet集合特点:
        1.不允许存储重复元素
        2.没有带索引的方法
        3.底层是一个红黑树结构(元素是有序的)
        4.可以根据比较器产生的规则对元素进行排序
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo07TreeSet</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">//使用空参数构造方法,创建TreeSet集合对象</span>
        TreeSet&lt;Integer&gt; set1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;();
        set1.add(<span class="hljs-number">1</span>);
        set1.add(<span class="hljs-number">3</span>);
        set1.add(<span class="hljs-number">3</span>);
        set1.add(<span class="hljs-number">2</span>);
        set1.add(<span class="hljs-number">5</span>);
        set1.add(<span class="hljs-number">4</span>);
        System.out.println(set1);<span class="hljs-comment">//[1, 2, 3, 4, 5]</span>

        <span class="hljs-comment">//使用带比较器构造方法,创建TreeSet集合对象</span>
        TreeSet&lt;Integer&gt; set2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> {
                <span class="hljs-comment">//o1-o2:升序  o2-o1:降序</span>
                <span class="hljs-keyword">return</span> o2-o1;
            }
        });
        set2.add(<span class="hljs-number">1</span>);
        set2.add(<span class="hljs-number">3</span>);
        set2.add(<span class="hljs-number">3</span>);
        set2.add(<span class="hljs-number">2</span>);
        set2.add(<span class="hljs-number">5</span>);
        set2.add(<span class="hljs-number">4</span>);
        System.out.println(set2);<span class="hljs-comment">//[5, 4, 3, 2, 1]</span>
    }
}</code></pre></div>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[day05-Collection、Iterator、泛型、数据结构]]></title>
            <guid>0c5bbbdae59f4853970830885abd1b5c</guid>
            <pubDate>Thu, 25 Nov 2021 09:48:12 GMT</pubDate>
            <content:encoded><![CDATA[<nav class="table-of-contents"><ul><li><a href="#学习目标">学习目标</a></li><li><a href="#第一章-collection集合">第一章 Collection集合</a><ul><li><a href="#1集合和数组的区别">1.集合和数组的区别</a></li><li><a href="#2集合常用类的继承体系">2.集合常用类的继承体系</a></li><li><a href="#3collection常用功能重点">3.Collection常用功能(重点)</a></li></ul></li><li><a href="#第二章-iterator迭代器">第二章 Iterator迭代器</a><ul><li><a href="#1迭代器的概述">1.迭代器的概述</a></li><li><a href="#2迭代器的基本使用重点">2.迭代器的基本使用(重点)</a></li><li><a href="#3迭代器的执行原理了解">3.迭代器的执行原理(了解)</a></li><li><a href="#4迭代器的并发修改异常了解-面试">4.迭代器的并发修改异常(了解-面试)</a></li><li><a href="#6增强for循环重点">6.增强for循环(重点)</a></li></ul></li><li><a href="#第三章-泛型">第三章 泛型</a><ul><li><a href="#1泛型的概述">1.泛型的概述</a></li><li><a href="#2使用泛型的好处">2.使用泛型的好处</a></li><li><a href="#3定义和使用含有泛型的类">3.定义和使用含有泛型的类</a></li><li><a href="#4定义和使用含有泛型的方法重点">4.定义和使用含有泛型的方法(重点)</a></li><li><a href="#5定义和使用含有泛型的接口">5.定义和使用含有泛型的接口</a></li><li><a href="#6泛型的通配符">6.泛型的通配符</a></li></ul></li><li><a href="#第四章-数据结构">第四章 数据结构</a><ul><li><a href="#1数据结构_栈先进后出">1.数据结构_栈:先进后出</a></li><li><a href="#2数据结构_队列先进先出">2.数据结构_队列:先进先出</a></li><li><a href="#3数据结构_数组查询快增删慢">3.数据结构_数组:查询快,增删慢</a></li><li><a href="#4数据结构_链表查询慢增删快">4.数据结构_链表:查询慢,增删快</a></li><li><a href="#5数据结构_红黑树查询的速度特别快">5.数据结构_红黑树:查询的速度特别快</a></li></ul></li></ul></nav><h1 id="学习目标">学习目标</h1>
<div><pre class="hljs"><code>能够说出集合与数组的区别
    数组:
        <span class="hljs-number">1.</span>是引用数据类型的一种,可以存储多个元素
        <span class="hljs-number">2.</span>数组的长度是固定的 <span class="hljs-type">int</span>[] arr1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];  <span class="hljs-type">int</span>[] arr2 = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>};
        <span class="hljs-number">3.</span>数组即可以存储基本类型的数据,又可以存储引用数据类型的数据
            <span class="hljs-type">int</span>[],<span class="hljs-type">double</span>[],String[],Student[]
    集合:
        <span class="hljs-number">1.</span>是引用数据类型的一种,可以存储多个元素
        <span class="hljs-number">2.</span>集合的长度是可以变化的(可以往集合中添加元素,删除集合中的元素)
        <span class="hljs-number">3.</span>只能存储引用数据类型的数据
            ArrayList&lt;<span class="hljs-type">int</span>&gt; 错误	ArrayList&lt;Integer&gt;	ArrayList&lt;Student&gt;
能够使用Collection集合的常用功能(重点)
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> ： 把给定的对象添加到当前集合中 。
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(E e)</span> : 把给定的对象在当前集合中删除。
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object obj)</span> : 判断当前集合中是否包含给定的对象。
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> : 判断当前集合是否为空。
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> : 返回集合中元素的个数。
    <span class="hljs-keyword">public</span> Object[] toArray() : 把集合中的元素，存储到数组中
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> :清空集合中所有的元素。
能够使用迭代器对集合进行取元素(重点)
    <span class="hljs-comment">//创建集合对象</span>
    Collection&lt;String&gt; coll = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
    coll.add(<span class="hljs-string">"西施"</span>);
    coll.add(<span class="hljs-string">"貂蝉"</span>);
    coll.add(<span class="hljs-string">"王昭君"</span>);
    coll.add(<span class="hljs-string">"杨贵妃"</span>);
    <span class="hljs-comment">//1.使用Collection接口中的方法iterator获取迭代器的实现类对象</span>
    Iterator&lt;String&gt; it = coll.iterator();
    <span class="hljs-comment">//2.使用迭代器Iterator中的方法hasNext判断集合中是否还有元素</span>
    <span class="hljs-keyword">while</span> (it.hasNext()){
        <span class="hljs-comment">//3.集合中有元素,使用迭代器Iterator中的方法next取出元素</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> it.next();
        System.out.println(s);
    }	
能够使用增强<span class="hljs-keyword">for</span>循环遍历集合和数组(重点)
    <span class="hljs-keyword">for</span>(集合|数组中元素的数据类型 变量名: 集合|数组){
        sout(变量名);
    }
    <span class="hljs-type">int</span>[] arr = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>};
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : arr){
        sout(i);
    }
    ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
    list.add(<span class="hljs-string">"a"</span>);
    list.add(<span class="hljs-string">"b"</span>);
    <span class="hljs-keyword">for</span>(String s : list){
        sout(s);
    }
能够理解泛型上下限
    泛型的上限限定: ? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">E</span> ==&gt;传递的未知类型?只能是E的子类或者本身
    泛型的下限限定: ? <span class="hljs-type">super</span> <span class="hljs-variable">E</span>   <span class="hljs-operator">=</span>=&gt;传递的未知类型?只能是E的父类或者本身
能够阐述泛型通配符的作用
    泛型的通配符: ?  可以接收任意的数据类型
能够说出常见的数据结构
    栈,队列,数组,链表,红黑树
能够说出数组结构特点
    查询快,增删慢
能够说出栈结构特点
    先进后出
能够说出队列结构特点
    先进先出
能够说出单向(双向)链表结构特点
    查询慢,增删快
    单向:是一个无序
    双向:是一个有序</code></pre></div>
<h1 id="第一章-collection集合">第一章 Collection集合</h1>
<h2 id="1集合和数组的区别">1.集合和数组的区别</h2>
<p>数组:</p>
<ol>
<li>
<p>是引用数据类型的一种,可以存储多个元素</p>
</li>
<li>
<p>数组的长度是固定的 int[] arr1 = new int[10];  int[] arr2 = {1,2,3};</p>
</li>
<li>
<p>数组即可以存储基本数据类型的数据,又可以存储引用数据类型的数据 int[] double[] String[] Student[]</p>
</li>
</ol>
<p>集合:</p>
<ol>
<li>
<p>是引用数据类型的一种,可以存储多个元素</p>
</li>
<li>
<p>集合的长度是可以变化的(添加元素,删除集合中的元素)</p>
</li>
<li>
<p>集合只能存储引用数据类型的数据</p>
</li>
</ol>
<p><code>ArrayList&lt;int&gt; 错误  ArrayList&lt;Integer&gt;  ArrayList&lt;Student&gt; ArrayList&lt;String&gt;正确</code></p>
<h2 id="2集合常用类的继承体系">2.集合常用类的继承体系</h2>
<p><img src="/_resources/2c65d9dc7905400989b2ed2e51b45d00.png" /></p>
<h2 id="3collection常用功能重点">3.Collection常用功能(重点)</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo01Collection;

<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Collection;
<span class="hljs-keyword">import</span> java.util.HashSet;
<span class="hljs-keyword">import</span> java.util.LinkedList;

<span class="hljs-comment">/*
    Collection常用功能(重点)
    public boolean add(E e) ： 把给定的对象添加到当前集合中 。
    public boolean remove(E e) : 把给定的对象在当前集合中删除。
    public boolean contains(Object obj) : 判断当前集合中是否包含给定的对象。
    public boolean isEmpty() : 判断当前集合是否为空。
    public int size() : 返回集合中元素的个数。
    public Object[] toArray() : 把集合中的元素，存储到数组中
    public void clear() :清空集合中所有的元素。
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01Collection</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">//1.使用多态的方式创建集合对象  接口 = 实现类对象   父类=子类对象</span>
        Collection&lt;String&gt; coll = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        <span class="hljs-comment">//Collection&lt;String&gt; coll = new LinkedList&lt;&gt;();</span>
        <span class="hljs-comment">//Collection&lt;String&gt; coll = new HashSet&lt;&gt;();</span>
        
        System.out.println(coll.isEmpty());<span class="hljs-comment">//true</span>
        <span class="hljs-comment">/*
            public boolean add(E e) :往集合的末尾追加元素
            返回值:boolean
                添加成功,返回true
                添加失败,返回false
         */</span>
        <span class="hljs-type">boolean</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> coll.add(<span class="hljs-string">"张三"</span>);
        System.out.println(<span class="hljs-string">"b1:"</span>+b1);
        coll.add(<span class="hljs-string">"李四"</span>);
        coll.add(<span class="hljs-string">"张三"</span>);
        coll.add(<span class="hljs-string">"王五"</span>);
        coll.add(<span class="hljs-string">"赵六"</span>);
        coll.add(<span class="hljs-string">"田七"</span>);
        System.out.println(coll);<span class="hljs-comment">//[张三, 李四, 张三, 王五, 赵六, 田七]</span>
        <span class="hljs-comment">/*
            public boolean remove(E e) 移除集合中指定的元素
            返回值:boolean
                集合中有指定元素,移除成功,返回true
                集合中没有指定的元素,移除失败,返回false
            注意:
                集合中有重复的元素,只移除第一个
         */</span>
        <span class="hljs-type">boolean</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> coll.remove(<span class="hljs-string">"张三"</span>);
        System.out.println(<span class="hljs-string">"b2:"</span>+b2);<span class="hljs-comment">//b2:true</span>
        System.out.println(coll);<span class="hljs-comment">//[李四, 张三, 王五, 赵六, 田七]</span>

        <span class="hljs-type">boolean</span> <span class="hljs-variable">b3</span> <span class="hljs-operator">=</span> coll.remove(<span class="hljs-string">"赵四"</span>);
        System.out.println(<span class="hljs-string">"b3:"</span>+b3);<span class="hljs-comment">//b3:false</span>
        System.out.println(coll);<span class="hljs-comment">//[李四, 张三, 王五, 赵六, 田七]</span>

        <span class="hljs-comment">/*
            contains:包含
            public boolean contains(Object obj) : 判断当前集合中是否包含给定的对象。
            返回值:boolean
                集合中有指定元素,返回true
                集合中没有指定的元素,返回false
         */</span>
        <span class="hljs-type">boolean</span> <span class="hljs-variable">b4</span> <span class="hljs-operator">=</span> coll.contains(<span class="hljs-string">"田七"</span>);
        System.out.println(<span class="hljs-string">"b4:"</span>+b4);<span class="hljs-comment">//b4:true</span>
        <span class="hljs-type">boolean</span> <span class="hljs-variable">b5</span> <span class="hljs-operator">=</span> coll.contains(<span class="hljs-string">"胡歌"</span>);
        System.out.println(<span class="hljs-string">"b5:"</span>+b5);<span class="hljs-comment">//b5:false</span>

        <span class="hljs-comment">/*
            Empty:空的
            public boolean isEmpty() : 判断当前集合是否为空。
            返回值:boolean
                集合是空的,里边没有元素,返回true
                集合不是空的,里边有元素,返回false
         */</span>
        <span class="hljs-type">boolean</span> <span class="hljs-variable">b6</span> <span class="hljs-operator">=</span> coll.isEmpty();
        System.out.println(<span class="hljs-string">"b6:"</span>+b6);<span class="hljs-comment">//b6:false</span>

        <span class="hljs-comment">/*
            public int size() : 返回集合中元素的个数。集合长度
         */</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> coll.size();
        System.out.println(<span class="hljs-string">"size:"</span>+size);

        <span class="hljs-comment">/*
            public Object[] toArray() : 把集合中的元素，存储到数组中
         */</span>
        Object[] arr = coll.toArray();
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
            System.out.println(arr[i]);
        }

        <span class="hljs-comment">/*
            clear:清除
            public void clear() :清空集合中所有的元素。
            注意:
                此方法仅仅是清空集合中的元素,集合对象还可以使用
         */</span>
        coll.clear();
        System.out.println(coll);<span class="hljs-comment">//[]</span>
        coll.add(<span class="hljs-string">"itheima"</span>);
        System.out.println(coll);<span class="hljs-comment">//[itheima]</span>
    }
}</code></pre></div>
<h1 id="第二章-iterator迭代器">第二章 Iterator迭代器</h1>
<h2 id="1迭代器的概述">1.迭代器的概述</h2>
<p><strong>迭代器:遍历集合</strong></p>
<div><pre class="hljs"><code><span class="hljs-comment">/*
    迭代器:是一种通用取出集合中元素的方式
    迭代器的由来:
        集合有很多种,每种集合的数据结构不同(数组,链表,哈希表...),集合取出元素的方式也不同
        我们不可能为每种集合都定义一种取出元素的方式,浪费
        所以我们可以使用迭代器,是集合通用的取出元素的方式
    迭代器的原理:
        判断集合中还有没有元素,有就取出来;
        再判断集合中还有没有元素,有再取出来;
        一直判断到集合中没有元素为止,这种取出元素的方式叫迭代
    ------------------------------------------------------------------------------------
    java.util.Iterator&lt;E&gt;接口:对 collection 进行迭代的迭代器。
    Iterator接口的常用方法:
        boolean hasNext() 如果仍有元素可以迭代，则返回 true。
            判断集合中还没有没有元素;有返回true,没有返回false
        E next() 返回迭代的下一个元素。 取出集合中的元素
    ------------------------------------------------------------------------------------
    Iterator是一个接口无法创建对象使用,使用Iterator接口的实现类对象,Iterator接口的实现类对象是每个集合的内部类(了解)
    我们可以使用Collection接口中的方法iterator获取迭代器Iterator接口的实现类对象
        Iterator&lt;E&gt; iterator() 返回在此 collection 的元素上进行迭代的迭代器。
    注意:
        我们无需关注iterator方法返回的是接口的哪个实现类对象,我们只需要会使用Iterator接口来接收这个实现类对象即可(多态)
 */</span></code></pre></div>
<h2 id="2迭代器的基本使用重点">2.迭代器的基本使用(重点)</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo02Iterator;

<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Collection;
<span class="hljs-keyword">import</span> java.util.Iterator;

<span class="hljs-comment">/*
    迭代器的基本使用(重点)
    1.使用Collection接口中的方法iterator获取迭代器的实现类对象
    2.使用迭代器Iterator中的方法hasNext判断集合中是否还有元素
    3.集合中有元素,使用迭代器Iterator中的方法next取出元素
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01Iterator</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">//创建集合对象</span>
        Collection&lt;String&gt; coll = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        coll.add(<span class="hljs-string">"西施"</span>);
        coll.add(<span class="hljs-string">"貂蝉"</span>);
        coll.add(<span class="hljs-string">"王昭君"</span>);
        coll.add(<span class="hljs-string">"杨贵妃"</span>);
        <span class="hljs-comment">//1.使用Collection接口中的方法iterator获取迭代器的实现类对象</span>
        <span class="hljs-comment">//迭代器也是有泛型的,迭代器的泛型跟着集合走,集合是什么泛型,迭代器就是什么泛型</span>
        <span class="hljs-comment">//多态  接口 = 实现类对象</span>
        Iterator&lt;String&gt; it = coll.iterator();

        <span class="hljs-comment">/*
            我们发现,使用迭代器取出集合中的元素,是一个重复的过程
            我们不知道集合中有多少元素,也就不知道循环多少次,所以使用while循环
            循环结束的条件 it.hasNext方法返回false
         */</span>
        <span class="hljs-comment">//2.使用迭代器Iterator中的方法hasNext判断集合中是否还有元素</span>
        <span class="hljs-keyword">while</span> (it.hasNext()){
            <span class="hljs-comment">//3.集合中有元素,使用迭代器Iterator中的方法next取出元素</span>
            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> it.next();
            System.out.println(s);
        }
        System.out.println(<span class="hljs-string">"------------------------------------"</span>);
        <span class="hljs-comment">//迭代器对象,只能使用一次;想再次遍历集合,需要重新获取一个迭代器对象</span>
        Iterator&lt;String&gt; it2 = coll.iterator();
        <span class="hljs-keyword">while</span> (it2.hasNext()){
            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> it2.next();
            System.out.println(s);
        }
        System.out.println(<span class="hljs-string">"------------------------------------"</span>);
        <span class="hljs-keyword">for</span> (Iterator&lt;String&gt; it3 = coll.iterator();it3.hasNext();){
            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> it3.next();
            System.out.println(s);
        }
    }

    <span class="hljs-comment">/*
        //2.使用迭代器Iterator中的方法hasNext判断集合中是否还有元素
        boolean b = it.hasNext();
        System.out.println(b);//true

        //3.集合中有元素,使用迭代器Iterator中的方法next取出元素
        String s = it.next();
        System.out.println(s);//西施

        b = it.hasNext();
        System.out.println(b);//true
        s = it.next();
        System.out.println(s);//貂蝉

        b = it.hasNext();
        System.out.println(b);//true
        s = it.next();
        System.out.println(s);//王昭君

        b = it.hasNext();
        System.out.println(b);//true
        s = it.next();
        System.out.println(s);//杨贵妃

        b = it.hasNext();
        System.out.println(b);//false
        s = it.next();//NoSuchElementException:没有这个元素异常 没有元素了,就不能在取了
     */</span>
}
</code></pre></div>
<h2 id="3迭代器的执行原理了解">3.迭代器的执行原理(了解)</h2>
<p><img src="/_resources/e10b303ae2ea4216bdfde97dfc2225f3.png" /></p>
<h2 id="4迭代器的并发修改异常了解-面试">4.迭代器的并发修改异常(了解-面试)</h2>
<p><img src="/_resources/fcba6bf20bd8463cabdb4f67c09631f8.png" /></p>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo02Iterator;

<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Iterator;
<span class="hljs-keyword">import</span> java.util.ListIterator;

<span class="hljs-comment">/*
    迭代器的并发修改异常:在使用迭代器遍历集合的过程中,对集合长度进行了修改,迭代器就会抛出并发修改异常
    ConcurrentModificationException
    注意:
        1.并发:遍历和修改同时进行
        2.修改:修改集合的长度(添加元素,删除元素)
    解决方案:
        1.遍历集合的同时,不修改集合的长度
        2.在Iterator迭代器接口中,有一个方法叫remove
            void remove() 移除迭代器it.next方法取出的元素
            使用此方法移除元素,迭代器不会抛出并发修改异常了
        3.Iterator接口有一个子接口叫ListIterator
            在ListIterator接口定义了往集合中添加元素的方法
                public interface ListIterator&lt;E&gt;extends Iterator&lt;E&gt;
                void add(E e)  迭代器中往集合添加元素的方法
                void remove() 删除的是next方法取出的元素
       注意:
        1.如果使用迭代器中的add|remove方法,往集合中添加|删除元素
            就相当于集合和迭代器商量好了,可以往集合中添加|删除元素,迭代器就不会抛出并发修改异常了
        2.ListIterator迭代器只能遍历List接口下的集合(ArrayList,LinkedList),不能遍历Set接口下的集合(HashSet,LinkedHashSet)
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo02Iterator</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">//创建集合对象,往集合中添加元素</span>
        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        list.add(<span class="hljs-string">"aaa"</span>);
        list.add(<span class="hljs-string">"bbb"</span>);
        list.add(<span class="hljs-string">"ccc"</span>);
        list.add(<span class="hljs-string">"ddd"</span>);
        list.add(<span class="hljs-string">"eee"</span>);
        <span class="hljs-comment">//使用迭代器遍历list集合</span>
        <span class="hljs-comment">//使用集合中的方法iterator获取迭代器接口的实现类对象</span>
        Iterator&lt;String&gt; it = list.iterator();
        <span class="hljs-comment">//使用Iterator迭代器中的方法hasNext和next遍历集合</span>
        <span class="hljs-keyword">while</span> (it.hasNext()){
            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> it.next();
            System.out.println(s);

             <span class="hljs-comment">/*
                需求:增加一个判断,如果取出的元素是"ccc"
                就给集合添加一个新的元素"itcast"
                编程技巧:使用equals方法判断的时候,一般都把已知的值写在前边,防止空指针异常
             */</span>
             <span class="hljs-comment">/*if("ccc".equals(s)){
                 list.add("itcast");
             }*/</span>

             <span class="hljs-comment">/*
                需求:增加一个判断,如果取出的元素是"ccc"
                就删除"ccc"
              */</span>
             <span class="hljs-comment">/*if("ccc".equals(s)){
                 //list.remove("ccc");//使用集合删除元素的方法,会抛出并发修改异常
                 it.remove();//使用迭代器删除元素的方法,不会抛出并发修改异常
             }*/</span>
        }
        System.out.println(list);<span class="hljs-comment">//[aaa, bbb, ddd, eee]</span>
        System.out.println(<span class="hljs-string">"-----------------------------------"</span>);
        <span class="hljs-comment">//获取List接口下的迭代器</span>
        ListIterator&lt;String&gt; lit = list.listIterator();
        <span class="hljs-keyword">while</span> (lit.hasNext()){
            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> lit.next();
            System.out.println(s);
             <span class="hljs-comment">/*
                需求:增加一个判断,如果取出的元素是"ccc"
                就给集合添加一个新的元素"itcast"
                编程技巧:使用equals方法判断的时候,一般都把已知的值写在前边,防止空指针异常
             */</span>
             <span class="hljs-keyword">if</span>(<span class="hljs-string">"ccc"</span>.equals(s)){
                 <span class="hljs-comment">//list.add("itcast");//使用集合的添加方法,会抛出ConcurrentModificationException</span>
                 lit.add(<span class="hljs-string">"itcast"</span>);<span class="hljs-comment">//使用迭代器的添加方法,不会抛出ConcurrentModificationException</span>
             }
        }
        System.out.println(list);<span class="hljs-comment">//[aaa, bbb, ccc, itcast, ddd, eee]</span>
    }
}
</code></pre></div>
<h2 id="6增强for循环重点">6.增强for循环(重点)</h2>
<p><strong>注意:</strong></p>
<p>​	<strong>增强for循环底层是一个迭代器,所以在使用增强for循环遍历的时候,不能对集合的长度进行修改,否则会抛出并发修改异常</strong></p>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo03forEach;

<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Collection;

<span class="hljs-comment">/*
    增强for循环(重点)
        增强for循环底层就是一个迭代器,只是使用了for循环的方式对迭代器进行了封装,简化了迭代器的代码
        是JDK1.5之后出现的
    注意:
        在使用增强for循环遍历集合的过程中,不能修改集合的长度,会抛出迭代器的并发修改异常
    格式:
        for(数据类型 变量名 : 集合名|数组名){
            sout(变量名);
        }
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01ForEach</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        show03();
    }

    <span class="hljs-comment">/*
        普通for循环快捷键:集合名.fori
        增强for循环快捷键:集合名.for
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show03</span><span class="hljs-params">()</span> {
        ArrayList&lt;Student&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">"张三"</span>,<span class="hljs-number">18</span>));
        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">"李四"</span>,<span class="hljs-number">18</span>));
        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">"王五"</span>,<span class="hljs-number">18</span>));
        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">"赵六"</span>,<span class="hljs-number">18</span>));
        <span class="hljs-keyword">for</span> (Student s : list) {
            System.out.println(s);
        }
    }

    <span class="hljs-comment">/*
        使用增强for循环遍历集合
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show02</span><span class="hljs-params">()</span> {
        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        list.add(<span class="hljs-string">"aaa"</span>);
        list.add(<span class="hljs-string">"bbb"</span>);
        list.add(<span class="hljs-string">"ccc"</span>);
        list.add(<span class="hljs-string">"ddd"</span>);
        <span class="hljs-keyword">for</span>(String s : list){
            <span class="hljs-comment">//list.add("eeee");//ConcurrentModificationException 遍历过程中,不能修改集合长度</span>
            System.out.println(s);
        }
    }

    <span class="hljs-comment">/*
        使用增强for循环遍历数组
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show01</span><span class="hljs-params">()</span> {
        <span class="hljs-type">int</span>[] arr = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>};
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : arr){
            System.out.println(i);
        }
    }
}
</code></pre></div>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo03forEach;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> {
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> {
    }

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> {
        <span class="hljs-built_in">this</span>.name = name;
        <span class="hljs-built_in">this</span>.age = age;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Student{"</span> +
                <span class="hljs-string">"name='"</span> + name + <span class="hljs-string">'\''</span> +
                <span class="hljs-string">", age="</span> + age +
                <span class="hljs-string">'}'</span>;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> {
        <span class="hljs-built_in">this</span>.name = name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> age;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> {
        <span class="hljs-built_in">this</span>.age = age;
    }
}
</code></pre></div>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo03forEach;

<span class="hljs-comment">/*
    增强for循环:原理
    好处:
        格式简单
    弊端:
        只能遍历,不能修改数组|集合中元素的值
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo02ForEach</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">int</span>[] arr1 = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>};
        <span class="hljs-comment">//使用普通for循环遍历数组</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr1.length; i++) {
            arr1[i]*=<span class="hljs-number">2</span>;
            System.out.println(arr1[i]);
        }
        System.out.println(<span class="hljs-string">"arr1[0]:"</span>+arr1[<span class="hljs-number">0</span>]);
        System.out.println(<span class="hljs-string">"---------------------------"</span>);
        <span class="hljs-type">int</span>[] arr2 = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>};
        <span class="hljs-comment">//使用增强for循环遍历数组</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> s : arr2) {
            s *= <span class="hljs-number">2</span>;
            System.out.println(s);
        }
        System.out.println(<span class="hljs-string">"arr2[0]:"</span>+arr2[<span class="hljs-number">0</span>]);
    }
}
</code></pre></div>
<p><img src="/_resources/1bce237bf92642288906cba5cc19aa43.png" /></p>
<h1 id="第三章-泛型">第三章 泛型</h1>
<h2 id="1泛型的概述">1.泛型的概述</h2>
<p><strong>面试:什么是泛型,一种未知的数据类型,当我们不知道使用什么类型的时候,就可以使用泛型</strong></p>
<p><img src="/_resources/26f19f7d42084b9fa8f1157611adc99f.png" /></p>
<h2 id="2使用泛型的好处">2.使用泛型的好处</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo04Generic;

<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Iterator;

<span class="hljs-comment">/*
    使用泛型的好处
    注意:了解==&gt;反射
        java中的泛型是一种伪泛型,在.java文件中有泛型的概念,在生成的.class文件中是没有泛型的
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01Generic</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        show02();
    }

    <span class="hljs-comment">/*
        创建集合对象,使用泛型
        好处:
            存储的数据是什么类型,取出的也是什么类型,不需要强转,就可以使用元素特有的方法
        弊端:
            集合使用什么类型,泛型就是什么类型,就只能存储什么类型的数据
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show02</span><span class="hljs-params">()</span> {
        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        list.add(<span class="hljs-string">"abc"</span>);
        <span class="hljs-comment">//list.add(1);</span>
        Iterator&lt;String&gt; it = list.iterator();
        <span class="hljs-keyword">while</span> (it.hasNext()){
            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> it.next();
            System.out.println(s+<span class="hljs-string">"==&gt;"</span>+s.length());
        }
    }

    <span class="hljs-comment">/*
        创建集合对象,不使用泛型
        好处:
            集合的泛型默认就是Object类型,什么类型的数据都可以存储
        弊端:
            取出的元素默认是Object类型,无法使用元素特有的方法
            需要向下转型,为了防止类型转换异常,增加判断
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show01</span><span class="hljs-params">()</span> {
        <span class="hljs-type">ArrayList</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();
        list.add(<span class="hljs-string">"abc"</span>);
        list.add(<span class="hljs-number">1</span>);
        <span class="hljs-comment">//使用迭代器遍历集合</span>
        <span class="hljs-type">Iterator</span> <span class="hljs-variable">it</span> <span class="hljs-operator">=</span> list.iterator();
        <span class="hljs-keyword">while</span> (it.hasNext()){
            <span class="hljs-type">Object</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> it.next();<span class="hljs-comment">//多态 Object s = "abc";  Object s = 1;</span>
            System.out.println(s);

            <span class="hljs-comment">//想使用String类型特有的方法,获取字符串的长度</span>
            <span class="hljs-keyword">if</span>(s <span class="hljs-keyword">instanceof</span> String){
                <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> (String)s;
                System.out.println(str.length());
            }
        }
    }
}</code></pre></div>
<p>通过反编译软件,查看的class文件中,没有泛型</p>
<p><img src="/_resources/ae687d58ce674377ab94b2d377d578f8.png" /></p>
<h2 id="3定义和使用含有泛型的类">3.定义和使用含有泛型的类</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo05GenericClass;

<span class="hljs-comment">/*
    定义和使用含有泛型的类
    什么是泛型,一种未知的数据类型,当我们不知道使用什么类型的时候,就可以使用泛型
    定义格式:
       public class 类名&lt;泛型&gt;{
            类中所有使用数据类型的地方,都可以使用类上定义的泛型
       }
    当我们创建对象的时候,可以给泛型赋值,确定泛型的数据类型
    Person&lt;C,D,E,F,W&gt;:定义多个泛型
    泛型的名字可以是任意的名字
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&lt;C&gt; {
    <span class="hljs-keyword">private</span> C name;

    <span class="hljs-keyword">public</span> C <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(C name)</span> {
        <span class="hljs-built_in">this</span>.name = name;
    }
}</code></pre></div>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo05GenericClass;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01Person</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">//没有给泛型赋值,默认就是Object类型</span>
        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();
        p.setName(<span class="hljs-number">11</span>);
        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> p.getName();
        System.out.println(obj);

        Person&lt;String&gt; p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>&lt;&gt;();
        p2.setName(<span class="hljs-string">"aaa"</span>);
        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> p2.getName();
        System.out.println(name);

        Person&lt;Double&gt; p3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>&lt;&gt;();
        p3.setName(<span class="hljs-number">1.1</span>);
        <span class="hljs-type">Double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> p3.getName();
        System.out.println(d);
    }
}</code></pre></div>
<p><img src="/_resources/9d32a2ddd1244b719db4596ce391145a.png" /></p>
<h2 id="4定义和使用含有泛型的方法重点">4.定义和使用含有泛型的方法(重点)</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo06GenericMethod;

<span class="hljs-comment">/*
    定义和使用含有泛型的方法(重点)
    方法上的泛型:定义在修饰符和返回值类型之间
    定义格式:
        修饰符 &lt;定义泛型&gt; 返回值类型 方法名(参数列表){
            方法体
        }
        方法的参数的类型和方法的返回值类型,就可以使用方法上定义的泛型
    什么时候确定泛型的数据类型:
        调用方法的时候,传递的数据是什么类型,方法上的泛型就是什么类型
        泛型:都是引用数据类型
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
    <span class="hljs-comment">//定义一个含有泛型的方法</span>
    <span class="hljs-keyword">public</span> &lt;M&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">show01</span><span class="hljs-params">(M m)</span>{
        System.out.println(m);
    }

    <span class="hljs-comment">//定义一个含有泛型的静态方法</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;S&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">show02</span><span class="hljs-params">(S s)</span>{
        System.out.println(s);
    }

    <span class="hljs-comment">//定义一个含有泛型,返回值类型使用泛型的静态方法</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;V&gt; V <span class="hljs-title function_">show03</span><span class="hljs-params">(V v)</span>{
        <span class="hljs-keyword">return</span> v;
    }
}</code></pre></div>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo06GenericMethod;

<span class="hljs-keyword">import</span> java.util.ArrayList;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01Person</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();
        p.show01(<span class="hljs-number">100</span>);
        p.show01(<span class="hljs-string">"aaa"</span>);
        p.show01(<span class="hljs-literal">true</span>);
        p.show01(<span class="hljs-number">1.1</span>);
        p.show01(<span class="hljs-string">'#'</span>);
        <span class="hljs-type">int</span>[] arr = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>};
        p.show01(arr);
        System.out.println(<span class="hljs-string">"---------------------------------"</span>);
        <span class="hljs-comment">//通过类名.方法名,可以集合调用静态方法</span>
        Person.show02(<span class="hljs-number">100</span>);
        Person.show02(<span class="hljs-string">"aaa"</span>);
        Person.show02(<span class="hljs-literal">true</span>);
        Person.show02(<span class="hljs-number">1.1</span>);
        Person.show02(<span class="hljs-string">'#'</span>);
        System.out.println(<span class="hljs-string">"---------------------------------"</span>);
        <span class="hljs-type">Integer</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> Person.show03(<span class="hljs-number">10</span>);
        System.out.println(in);
        <span class="hljs-type">String</span> <span class="hljs-variable">aaa</span> <span class="hljs-operator">=</span> Person.show03(<span class="hljs-string">"aaa"</span>);
        System.out.println(aaa);
        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        list.add(<span class="hljs-string">"aa"</span>);
        list.add(<span class="hljs-string">"bb"</span>);
        ArrayList&lt;String&gt; list2 = Person.show03(list);
        System.out.println(list2);
    }
}</code></pre></div>
<p><img src="/_resources/0bffe3c7fe0b47d7b6369aba86942e3a.png" /></p>
<h2 id="5定义和使用含有泛型的接口">5.定义和使用含有泛型的接口</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo07GenericInterface;

<span class="hljs-comment">/*
    定义和使用含有泛型的接口
    定义格式:
        public interface 接口名&lt;定义泛型&gt;{
            接口中的方法的参数和返回值类型都可以使用泛型
        }
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInter</span>&lt;I&gt; {
    <span class="hljs-comment">//抽象方法</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(I i)</span>;
}</code></pre></div>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo07GenericInterface;

<span class="hljs-comment">/*
    含有泛型的接口的第一种使用方式
        定义一个实现类,实现接口,并直接指定接口中泛型的数据类型
    格式:
        public class MyInterImpl1 implements MyInter&lt;String&gt;{
            @Override
            public void show(String s) {}
        }
        public class MyInterImpl1 implements MyInter&lt;Integer&gt;{
            @Override
            public void show(Integer in) {}
        }
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInterImpl1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MyInter</span>&lt;Integer&gt;{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(Integer in)</span> {
        System.out.println(in);
    }
}</code></pre></div>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo07GenericInterface;

<span class="hljs-comment">/*
    含有泛型的接口的第二种使用方式
        接口使用什么泛型,实现类就使用什么泛型,跟着接口走
    格式:
        public class MyInterImpl2&lt;I&gt; implements MyInter&lt;I&gt;{
            @Override
            public void show(I i) {
                System.out.println(i);
            }
        }
    就相当于一个含有泛型的类,创建对象的时候,确定泛型的数据类型
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInterImpl2</span>&lt;I&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MyInter</span>&lt;I&gt;{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(I i)</span> {
        System.out.println(i);
    }
}</code></pre></div>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo07GenericInterface;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">//创建接口的实现类对象</span>
        <span class="hljs-type">MyInterImpl1</span> <span class="hljs-variable">my01</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyInterImpl1</span>();
        my01.show(<span class="hljs-number">10</span>);
        
        MyInterImpl2&lt;String&gt; my02 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyInterImpl2</span>&lt;&gt;();
        my02.show(<span class="hljs-string">"aaa"</span>);

        MyInterImpl2&lt;Boolean&gt; my03 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyInterImpl2</span>&lt;&gt;();
        my03.show(<span class="hljs-literal">true</span>);
    }
}</code></pre></div>
<h2 id="6泛型的通配符">6.泛型的通配符</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo08Generic;

<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Collection;
<span class="hljs-keyword">import</span> java.util.Iterator;

<span class="hljs-comment">/*
    泛型的通配符
    ?:就是泛型的通配符,可以作为方法集合参数的类型使用,可以接收任意的数据类型
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01Generic</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        ArrayList&lt;Integer&gt; list01 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        list01.add(<span class="hljs-number">10</span>);
        list01.add(<span class="hljs-number">20</span>);
        ArrayList&lt;String&gt; list02 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        list02.add(<span class="hljs-string">"aaa"</span>);
        list02.add(<span class="hljs-string">"bbb"</span>);
        printCollection(list01);
        printCollection(list02);
        <span class="hljs-comment">//?只能作为参数中集合的数据类型使用,不能定义集合的时候使用</span>
        <span class="hljs-comment">//ArrayList&lt;?&gt; list03 = new ArrayList&lt;&gt;();</span>
        <span class="hljs-comment">//list03.add("aa");</span>
    }

    <span class="hljs-comment">/*
        需求:
            定义一个方法,方法的参数可以接收任意数据类型的集合
            在方法中对集合进行遍历
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printCollection</span><span class="hljs-params">(Collection&lt;?&gt; coll)</span>{
        <span class="hljs-comment">//使用迭代器遍历集合</span>
        Iterator&lt;?&gt; it = coll.iterator();
        <span class="hljs-keyword">while</span> (it.hasNext()){
            <span class="hljs-comment">//it.next方法取出元素是什么类型Object:中有Object类型可以接收任意的数据类型</span>
            <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> it.next();
            System.out.println(obj);
        }
    }
}</code></pre></div>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo08Generic;

<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Collection;

<span class="hljs-comment">/*
    泛型通配符的高级使用
    泛型的通配符: ? 代表可以接收任意数据类型的数据
    泛型的上限限定: ? extends E==&gt;传递的未知类型?只能使用E的子类或者是E本身
        ? extends Person:代表传递的未知的类型只能是Person或者Person的子类
    泛型的下限限定: ? super E==&gt;传递的未知类型?只能使用E的父类或者是E本身
        ? super Person:代表传递的未知的类型只能是Person或者Person的父类
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo02Generic</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        Collection&lt;Integer&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();
        Collection&lt;String&gt; list2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();
        Collection&lt;Number&gt; list3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Number&gt;();
        Collection&lt;Object&gt; list4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Object&gt;();

        <span class="hljs-comment">/*
            Integer extends Number extends Object
            String exntends Object
         */</span>

        getElement1(list1);
        <span class="hljs-comment">//getElement1(list2);//报错 String和Number没有关系</span>
        getElement1(list3);
        <span class="hljs-comment">//getElement1(list4);//报错 Object类型是Number的父类,需要Number子类</span>

        <span class="hljs-comment">//getElement2(list1);//报错 Integer是Number的子类,需要Number的父类</span>
        <span class="hljs-comment">//getElement2(list2);//报错 String和Number没有关系</span>
        getElement2(list3);
        getElement2(list4);
    }

        <span class="hljs-comment">// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getElement1</span><span class="hljs-params">(Collection&lt;? extends Number&gt; coll)</span>{}

        <span class="hljs-comment">// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getElement2</span><span class="hljs-params">(Collection&lt;? <span class="hljs-built_in">super</span> Number&gt; coll)</span>{}
}</code></pre></div>
<h1 id="第四章-数据结构">第四章 数据结构</h1>
<h2 id="1数据结构_栈先进后出">1.数据结构_栈:先进后出</h2>
<h2 id="2数据结构_队列先进先出">2.数据结构_队列:先进先出</h2>
<p><img src="/_resources/d57cea82bbae4085aa0ebebaccdfcdba.png" /></p>
<h2 id="3数据结构_数组查询快增删慢">3.数据结构_数组:查询快,增删慢</h2>
<p><img src="/_resources/1ee0da0736e940dfaec92f8613590bc8.png" /></p>
<h2 id="4数据结构_链表查询慢增删快">4.数据结构_链表:查询慢,增删快</h2>
<p><img src="/_resources/972710bbaafb4ebc9c1b1975dae7672b.png" /></p>
<h2 id="5数据结构_红黑树查询的速度特别快">5.数据结构_红黑树:查询的速度特别快</h2>
<p><img src="/_resources/6152d135cfbd4b63831c5088abcfe728.png" /></p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[day03-常用api]]></title>
            <guid>1b55359b506a4540a40232c6fad6e54b</guid>
            <pubDate>Tue, 06 Jul 2021 09:27:44 GMT</pubDate>
            <content:encoded><![CDATA[<nav class="table-of-contents"><ul><li><a href="#1-java一共有四种访问权限修饰符">1. Java一共有四种访问权限修饰符：</a><ul><li><a href="#访问权限修饰符的作用限制其他类访问本类以及本类成员的访问权限">访问权限修饰符的作用：限制其他类，访问本类以及本类成员的访问权限。</a></li><li><a href="#这四种访问权限修饰符可以修饰">这四种访问权限修饰符可以修饰：</a></li><li><a href="#类两种">类(两种)：</a></li><li><a href="#类成员成员属性-成员方法-构造方法四种">类成员(成员属性、成员方法、构造方法)(四种)：</a></li></ul></li><li><a href="#2-代码块">2. 代码块：</a><ul><li><a href="#a构造代码块">A).构造代码块：</a><ul><li><a href="#构造代码块作用">构造代码块作用：</a></li></ul></li><li><a href="#b静态代码块">B).静态代码块：</a><ul><li><a href="#静态代码块作用">静态代码块作用：</a></li></ul></li><li><a href="#c局部代码块">C).局部代码块：</a><ul><li><a href="#局部代码块作用">局部代码块作用：</a></li></ul></li></ul></li><li><a href="#3-object类">3. Object类：</a><ul><li><a href="#1-object类概述">1. Object类概述</a></li><li><a href="#2-object类_tostring方法">2. Object类_toString方法</a></li><li><a href="#3-object类_equals方法">3. Object类_equals方法</a></li><li><a href="#21-objects类的使用">2.1 Objects类的使用</a></li></ul></li><li><a href="#4-javautildate类表示一个日期和时间的对象精度毫秒">4. java.util.Date(类)：表示一个日期和时间的对象，精度：毫秒。</a><ul><li><a href="#1构造方法">1).构造方法：</a></li><li><a href="#2成员方法">2).成员方法：</a></li><li><a href="#3示例代码">3).示例代码：</a></li></ul></li><li><a href="#5-javatextdateformat抽象类日期格式化类">5. java.text.DateFormat(抽象类)：日期格式化类。</a><ul><li><a href="#1-dateformat类中的静态方法getinstance获取一个此类的子类对象">1. DateFormat类中的静态方法：getInstance()：获取一个此类的子类对象。</a></li><li><a href="#2-使用子类simpledateformat我们使用">2. 使用子类：SimpleDateFormat【我们使用】</a></li><li><a href="#3-simpledateformat的构造方法">3. SimpleDateFormat的构造方法：</a></li></ul></li><li><a href="#6-javautilcalendar抽象类它是一个日历类可以做日期运算">6. java.util.Calendar(抽象类)：它是一个"日历"类，可以做日期运算。</a><ul><li><a href="#1calendar是抽象类不能创建对象有两种方案">1).Calendar是抽象类，不能创建对象，有两种方案：</a></li><li><a href="#2直接使用子类gregoriancalendar">2).直接使用子类：GregorianCalendar</a></li></ul></li><li><a href="#7-javamathbigdecimal类">7. java.math.BigDecimal(类)：</a><ul><li><a href="#1构造方法-1">1).构造方法：</a></li><li><a href="#2成员方法-1">2).成员方法：</a></li></ul></li><li><a href="#8-math类">8. Math类</a></li><li><a href="#9-system类">9. System类</a></li><li><a href="#10-总结">10. 总结：</a></li></ul></nav><h2 id="1-java一共有四种访问权限修饰符">1. Java一共有四种访问权限修饰符：</h2>
<blockquote>
<p>public(公有)：
protected(受保护)：
(什么都不写)(默认)：
private(私有)：</p>
</blockquote>
<h4 id="访问权限修饰符的作用限制其他类访问本类以及本类成员的访问权限">访问权限修饰符的作用：限制其他类，访问本类以及本类成员的访问权限。</h4>
<h4 id="这四种访问权限修饰符可以修饰">这四种访问权限修饰符可以修饰：</h4>
<h4 id="类两种">类(两种)：</h4>
<blockquote>
<p>public：表示：此类可以被本项目(模块)下任何包的其它类访问。【常用】
(什么都不写)默认：表示：此类只能同包的其它类访问。</p>
</blockquote>
<h4 id="类成员成员属性-成员方法-构造方法四种">类成员(成员属性、成员方法、构造方法)(四种)：</h4>
<blockquote>
<p>public：表示：此成员可以被本项目中所有其它包的类访问。【成员方法、构造方法】
protected：表示：此成员只能被同包的其它类访问。如果是包外的子类，可以访问
(什么都不写)：表示：此成员只能被同包的其它类访问。
private：表示：此成员只能被本类内部的其它成员访问。【成员属性】</p>
</blockquote>
<h2 id="2-代码块">2. 代码块：</h2>
<h3 id="a构造代码块">A).构造代码块：</h3>
<p><strong>直接写在类体中，用一对大括号括起来的一个代码块。</strong></p>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>{
<span class="hljs-comment">//构造代码块</span>
{
    System.<span class="hljs-keyword">out</span>.println(“构造代码块”);
}
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span>(<span class="hljs-params"></span>)</span>{
    System.<span class="hljs-keyword">out</span>.println(“无参构造！”);
}
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a</span>)</span>{
        System.<span class="hljs-keyword">out</span>.println(“有参构造！”);
    }
}</code></pre></div>
<p>无论调用哪个构造方法，都会先执行一次"构造代码块"；</p>
<h4 id="构造代码块作用">构造代码块作用：</h4>
<p><strong>如果多个构造方法都需要做的事情，可以放在"构造代码块"中。</strong></p>
<h3 id="b静态代码块">B).静态代码块：</h3>
<p><strong>直接写在类体中，普通代码块前面加static关键字</strong></p>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> {
<span class="hljs-comment">//构造方法</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span>(<span class="hljs-params"></span>)</span>{
System.<span class="hljs-keyword">out</span>.println(“无参构造！”);
}
<span class="hljs-comment">//构造方法</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a</span>)</span> {
System.<span class="hljs-keyword">out</span>.println(“有参构造！”);
}
<span class="hljs-comment">//构造代码块</span>
{
System.<span class="hljs-keyword">out</span>.println(“构造代码块<span class="hljs-number">1</span>”);
}
<span class="hljs-comment">//静态构造代码块：初始化静态成员。</span>
<span class="hljs-keyword">static</span> {
System.<span class="hljs-keyword">out</span>.println(“静态代码块…”);
}
}</code></pre></div>
<h4 id="静态代码块作用">静态代码块作用：</h4>
<p>初始化静态成员属性的。</p>
<h3 id="c局部代码块">C).局部代码块：</h3>
<p><strong>写在某个方法内的代码块。</strong></p>
<div><pre class="hljs"><code>        <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> <span class="hljs-keyword">show</span>(){
            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println("a");
            {
                <span class="hljs-type">int</span>[] arr = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];
                <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(arr.length);
            }
            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println("b");
        }</code></pre></div>
<h4 id="局部代码块作用">局部代码块作用：</h4>
<p>限制变量的生命周期。</p>
<h2 id="3-object类">3. Object类：</h2>
<h3 id="1-object类概述">1. Object类概述</h3>
<ul>
<li>
<ol>
<li>列表项.java.lang.Object(类):它是所有类的父类，任何的类，如果不继承其它类，都会隐式的继承自Object类。(包括类库的类、数组、我们自己的类)</li>
</ol>
</li>
<li>
<ol start="2">
<li>从Object类继承下来的两个重要方法：</li>
</ol>
<ul>
<li>
<ol>
<li>public boolean equals(Object obj)：用来比较两个对象的“内容”是否一致。</li>
</ol>
<ul>
<li>我们学习String的时候，它有一个equals()方法，就是从Object类继承下去的，并且String给重写了。</li>
</ul>
</li>
<li>
<ol start="2">
<li>public String toString()：将对象转换为String。</li>
</ol>
<ul>
<li>我们学习StringBuilder的时候，它有一个toString()方法，就是从Object类继承下去的，并且StringBuilder给重写了。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-object类_tostring方法">2. Object类_toString方法</h3>
<ul>
<li>
<ol>
<li>public String toString()：将对象转换为String，Object类的toString()默认实现：全类名 + @ + 地址。 这种字符串，对于我们没有任何意义，我们想将“成员属性和成员方法”封装成一个字符串，所以我们需要“重写”这个方法。</li>
</ol>
</li>
<li>
<ol start="2">
<li>有以下两种情况Java会自动调用我们类的toString():</li>
</ol>
<ul>
<li>
<ol>
<li>println()方法，内部会自动调用我们对象的toString();</li>
</ol>
</li>
<li>
<ol start="2">
<li>字符串 + 对象 ：会隐式的调用我们对象的toString();
<img src="/_resources/f3e89f6c2daa47e7b19feb81c6e4c744.png" /></li>
</ol>
</li>
</ul>
</li>
</ul>
<p><img src="/_resources/d547a439c5b0423787dc85961dd826ad.png" /></p>
<h3 id="3-object类_equals方法">3. Object类_equals方法</h3>
<ul>
<li>
<ol>
<li>public boolean equals(Object obj)：用来比较两个对象的“内容”是否一致。通常子类需要重写此方法。</li>
</ol>
</li>
<li>
<ol start="2">
<li>图示： <img src="/_resources/d4d25799f629419d86a9807e02492c71.png" /></li>
</ol>
</li>
</ul>
<h3 id="21-objects类的使用">2.1 Objects类的使用</h3>
<ul>
<li>java.util.Objects(类)： 它是一个对“对象”操作的“工具类”。它里面包含了一些方法，可以很安全的对“对象”进行操作。 Java类库中很对这种类，命名方式：”类名s”，它就表示是这个“类”的工具类。 <img src="/_resources/e92b4774c0a4426eb17355a09c79526b.png" /></li>
</ul>
<h2 id="4-javautildate类表示一个日期和时间的对象精度毫秒">4. java.util.Date(类)：表示一个日期和时间的对象，精度：毫秒。</h2>
<p>java.util.Date(类)：它表示可以表示一个日期和时间，通常用来获取当前系统时间。 精确到毫秒</p>
<h3 id="1构造方法">1).构造方法：</h3>
<blockquote>
<ol>
<li>Date()：无参构造，使用当前系统时间构造一个Date对象。</li>
<li>Date(long m)：使用一个毫秒值构造一个Date对象。它内部存储的是：1970年01月01日零时开始，到这个毫秒值之间的长度，所表示一个日期和时间</li>
</ol>
</blockquote>
<h3 id="2成员方法">2).成员方法：</h3>
<blockquote>
<ol>
<li>public long getTime()：获取此Date对象距离1970年01月01日零时之间的毫秒值。</li>
<li>public void setTime(long m)：设置此Date对象的毫秒值。</li>
</ol>
</blockquote>
<h3 id="3示例代码">3).示例代码：</h3>
<div><pre class="hljs"><code><span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) {
    //<span class="hljs-number">1.</span>构造一个<span class="hljs-type">Date</span>对象
    <span class="hljs-type">Date</span> date1 = <span class="hljs-built_in">new</span> <span class="hljs-type">Date</span>();
    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(date1);//Thu Apr <span class="hljs-number">01</span> <span class="hljs-number">12</span>:<span class="hljs-number">08</span>:<span class="hljs-number">28</span> CST <span class="hljs-number">2021</span>
    long <span class="hljs-type">time</span> = date1.getTime();
    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-type">time</span>);//<span class="hljs-number">1617250108107</span>
    //<span class="hljs-number">2.</span>使用一个毫秒值构造
    <span class="hljs-type">Date</span> date2 = <span class="hljs-built_in">new</span> <span class="hljs-type">Date</span>(<span class="hljs-number">1000</span> * <span class="hljs-number">3600</span> * <span class="hljs-number">24</span> * <span class="hljs-number">-1</span>);//指：从<span class="hljs-number">1970</span>年<span class="hljs-number">01</span>月<span class="hljs-number">01</span>日零时开始的一个毫秒值。
    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(date2);//Wed <span class="hljs-type">Dec</span> <span class="hljs-number">31</span> <span class="hljs-number">08</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> CST <span class="hljs-number">1969</span>
    date2.setTime(<span class="hljs-type">time</span>);
    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(date2);//Thu Apr <span class="hljs-number">01</span> <span class="hljs-number">12</span>:<span class="hljs-number">08</span>:<span class="hljs-number">28</span> CST <span class="hljs-number">2021</span>
}</code></pre></div>
<h2 id="5-javatextdateformat抽象类日期格式化类">5. java.text.DateFormat(抽象类)：日期格式化类。</h2>
<p>java.text.DateFormat(抽象类)：它用来做“日期格式化”的。 我们有些时候显示日期和时间时，需要特定的格式： 例如：2021年11月20日 14:58:22 2021/11/20 14:58:22 2021-11-20 14:58:22 要想将日期和时间按照我们想要的格式进行显示，就需要用到DateFormat类，它就可以按我们想要的格式对日期进行“格式化”</p>
<h3 id="1-dateformat类中的静态方法getinstance获取一个此类的子类对象">1. DateFormat类中的静态方法：getInstance()：获取一个此类的子类对象。</h3>
<h3 id="2-使用子类simpledateformat我们使用">2. 使用子类：SimpleDateFormat【我们使用】</h3>
<h3 id="3-simpledateformat的构造方法">3. SimpleDateFormat的构造方法：</h3>
<ol>
<li>SimpleDateFormat(String pattern) ：使用一个模式字符串构造一个SimpleDateFormat对象。</li>
</ol>
<blockquote>
<p>模式字符串是固定写法，在API文档中有说明： 1).y：年 2).M：月 3).d：日 4).H：小时 5).m：分钟 6).s：秒</p>
</blockquote>
<ol start="2">
<li>示例代码：典型操作：</li>
</ol>
<blockquote>
<p>将Date转换为String:format(Date date) 将String转换为Date：parse(String s)：</p>
</blockquote>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo08</span> {
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String\[\] args)</span> <span class="hljs-keyword">throws</span> ParseException {
<span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();

    <span class="hljs-comment">//我们想要的格式：2021年04月01日 12:17:23</span>
    <span class="hljs-comment">//1.创建一个SimpleDateFormat对象</span>
    <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>);
    <span class="hljs-comment">//2.将Date对象转换为String</span>
    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> sdf.format(date);
    <span class="hljs-comment">//3.打印字符串</span>
    System.out.println(str);

    System.out.println(<span class="hljs-string">"------------------------------------------"</span>);
    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">"2000-01-30"</span>;<span class="hljs-comment">//将String转换为Date</span>
    <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">"yyyy-MM-dd"</span>);
    <span class="hljs-type">Date</span> <span class="hljs-variable">date2</span> <span class="hljs-operator">=</span> sdf2.parse(s);
    System.out.println(date2);
}

}</code></pre></div>
<ol start="3">
<li>练习1_转换字符串的日期格式</li>
</ol>
<ul>
<li>
<ol>
<li>题目：从控制台接收一个以下格式的日期：”2021年11月20日”，程序要将其转为”2021-11-20”的格式，并输出。</li>
</ol>
</li>
<li>
<ol start="2">
<li>步骤：</li>
</ol>
<ul>
<li>
<ol>
<li>将原字符串转换为一个Date对象。</li>
</ol>
</li>
<li>
<ol start="2">
<li>将date对象，转换为另一个格式的String即可。 <img src="/_resources/0c0842f438474d28b9c0dcb985f6dac8.png" /></li>
</ol>
</li>
</ul>
</li>
</ul>
<ol start="4">
<li>练习2_计算来到世界多少天</li>
</ol>
<ul>
<li>
<ol>
<li>题目：从控制台接收一位同学的“生日”，格式：yyyy-MM-dd，程序要能够算出这位同学从出生到现在共经历多少天？ <img src="/_resources/0bfd90ab0ab741eebbfb140a8e30f1dd.png" /></li>
</ol>
</li>
<li>
<ol start="2">
<li>代码实现： <img src="/_resources/2e7a17b3050a4f6195f4b892139aaa44.png" /></li>
</ol>
</li>
</ul>
<h2 id="6-javautilcalendar抽象类它是一个日历类可以做日期运算">6. java.util.Calendar(抽象类)：它是一个"日历"类，可以做日期运算。</h2>
<h3 id="1calendar是抽象类不能创建对象有两种方案">1).Calendar是抽象类，不能创建对象，有两种方案：</h3>
<blockquote>
<p>1). 调用Calendar的静态方法：getInstance()：可以获取它的一个子类对象。GregorianCalendar【我们使用这种方式】</p>
</blockquote>
<h3 id="2直接使用子类gregoriancalendar">2).直接使用子类：GregorianCalendar</h3>
<ol start="2">
<li>成员方法：</li>
</ol>
<blockquote>
<p>1).public int get(int field)：获取某个字段的值。
2).public void set(int field,int value)：将此Calendar中的field字段设置为value值。
3).public void add(int field,int value)：将field字段的值增加/减少value。
4).public boolean after (Object when)：判断当前时间是否在参数时间之后。
5).public boolean before(Object when)：判断当前时间是否在参数时间之前。
6).public final void setTime (Date date)：使用给定的Date设置此日历的时间。</p>
</blockquote>
<ol start="3">
<li>示例代码：</li>
</ol>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo08</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
<span class="hljs-comment">//      Calendar c = Calendar.getInstance();</span>
        <span class="hljs-type">GregorianCalendar</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GregorianCalendar</span>();
        System.out.println(c);

        <span class="hljs-comment">//1).public int get(int field)：获取某个字段的值。</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">year</span> <span class="hljs-operator">=</span> c.get(<span class="hljs-number">1</span>);
        <span class="hljs-type">int</span> <span class="hljs-variable">month</span> <span class="hljs-operator">=</span> c.get(<span class="hljs-number">2</span>) + <span class="hljs-number">1</span>;<span class="hljs-comment">//它内部存储的月份值：0-11的值，表示真实的：1-12</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> c.get(Calendar.DAY_OF_MONTH);
        <span class="hljs-type">int</span> <span class="hljs-variable">hour</span> <span class="hljs-operator">=</span> c.get(Calendar.HOUR_OF_DAY);
        <span class="hljs-type">int</span> <span class="hljs-variable">minute</span> <span class="hljs-operator">=</span> c.get(Calendar.MINUTE);
        <span class="hljs-type">int</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> c.get(Calendar.SECOND);
        <span class="hljs-type">int</span> <span class="hljs-variable">week</span> <span class="hljs-operator">=</span> c.get(Calendar.DAY_OF_WEEK);<span class="hljs-comment">//返回的是1-7的值，表示：星期日，星期一，星期二，....，星期六</span>
        System.out.println(year + <span class="hljs-string">"-"</span> + month + <span class="hljs-string">"-"</span> + date + <span class="hljs-string">" "</span>
                            + hour + <span class="hljs-string">":"</span> + minute + <span class="hljs-string">":"</span> + second);
        System.out.println(getWeek(week));

        <span class="hljs-comment">//2.set()方法：获取一个Calendar子类对象，并且设置年月日为：1999-11-20日</span>
        <span class="hljs-type">Calendar</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> Calendar.getInstance();<span class="hljs-comment">//当前系统时间</span>
        c2.set(Calendar.YEAR, <span class="hljs-number">1999</span>);
        c2.set(Calendar.MONTH,<span class="hljs-number">11</span> - <span class="hljs-number">1</span>);
        c2.set(Calendar.DAY_OF_MONTH, <span class="hljs-number">20</span>);

        <span class="hljs-comment">//此时c2内部已经变为：1999年11月20日了</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">w1</span> <span class="hljs-operator">=</span> c2.get(Calendar.DAY_OF_WEEK);
        System.out.println(<span class="hljs-string">"1999-11-20日那天是："</span> + getWeek(w1));


        <span class="hljs-comment">//3.add()方法：增加/减少指定字段的值。</span>
        <span class="hljs-comment">//需求：100天以后是哪年、哪月、哪日</span>
        <span class="hljs-comment">//1).获取当前系统时间</span>
        <span class="hljs-type">Calendar</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> Calendar.getInstance();
        <span class="hljs-comment">//2).将日期增加100</span>
        c3.add(Calendar.DAY_OF_MONTH, <span class="hljs-number">100</span>);
        <span class="hljs-comment">//3).打印c3</span>
        System.out.println(c3);
    }

    <span class="hljs-comment">//编写一个方法，可以根据一个int值返回对应的"星期X"字符串</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getWeek</span><span class="hljs-params">(<span class="hljs-type">int</span> week)</span> {<span class="hljs-comment">//week = 1--7</span>
        <span class="hljs-comment">//查表法</span>
        <span class="hljs-comment">//1.制作一个表(数组)</span>
        String[] arr = {<span class="hljs-string">"星期日"</span>, <span class="hljs-string">"星期一"</span>, <span class="hljs-string">"星期二"</span>, <span class="hljs-string">"星期三"</span>, <span class="hljs-string">"星期四"</span>, <span class="hljs-string">"星期五"</span>, <span class="hljs-string">"星期六"</span>};
        <span class="hljs-comment">//        索引：  [0]      [1]      [2]      [3]      [4]     [5]       [6]</span>
        <span class="hljs-keyword">return</span> arr[week - <span class="hljs-number">1</span>];

    }
}
</code></pre></div>
<blockquote>
<p><strong>get(Calendar.MONTH) 返回的月份为0-11</strong></p>
<p><strong>get(Calendar.DAY_OF_WEEK)返回的星期为星期日开始，需要设置)</strong></p>
</blockquote>
<h2 id="7-javamathbigdecimal类">7. java.math.BigDecimal(类)：</h2>
<h3 id="1构造方法-2">1).构造方法：</h3>
<blockquote>
<p>BigDecimal(String s)：</p>
</blockquote>
<h3 id="2成员方法-2">2).成员方法：</h3>
<div><pre class="hljs"><code>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Demo13</span> {
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> {
            <span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span>;
            String s = a + <span class="hljs-string">""</span>;<span class="hljs-comment">//"10"</span>

            <span class="hljs-built_in">double</span> d1 = <span class="hljs-number">0.1</span>;
            <span class="hljs-built_in">double</span> d2 = <span class="hljs-number">0.3</span>;

            System.<span class="hljs-keyword">out</span>.println(d1 + d2);<span class="hljs-comment">//0.09999999999999999</span>

            <span class="hljs-comment">//在做浮点运算不要使用基本类型，改用：BigDecimal类</span>
                    <span class="hljs-comment">//有重载方法，使用字符串的，double转换还是会有精度丢失问题</span>
            BigDecimal big1 = <span class="hljs-keyword">new</span> BigDecimal(d1 + <span class="hljs-string">""</span>);<span class="hljs-comment">//"0.09"</span>
            BigDecimal big2 = <span class="hljs-keyword">new</span> BigDecimal(d2 + <span class="hljs-string">""</span>);<span class="hljs-comment">//"0.01"</span>

            <span class="hljs-comment">//1.加</span>
            BigDecimal <span class="hljs-keyword">add</span> = big1.<span class="hljs-keyword">add</span>(big2);<span class="hljs-comment">//相当于：0.09 + 0.01</span>
            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"加的结果："</span> + <span class="hljs-keyword">add</span>);

            <span class="hljs-comment">//2.减</span>
            BigDecimal subtract = big1.subtract(big2);
            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"减的结果："</span> + subtract);

            <span class="hljs-comment">//3.乘</span>
            BigDecimal multiply = big1.multiply(big2);
            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"乘的结果："</span> + multiply);

            <span class="hljs-comment">//4.除</span>
    <span class="hljs-comment">//        BigDecimal divide = big1.divide(big2);//不建议使用此方法，如果除不尽，会出现异常。</span>
            BigDecimal divide = big1.divide(big2, <span class="hljs-number">3</span>, RoundingMode.HALF_UP);
            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"除的结果："</span> + divide);

        }
    }</code></pre></div>
<h2 id="8-math类">8. Math类</h2>
<ul>
<li>1). java.lang.Math(类)：它是进行“数学运算”的类，里面包含很多的“静态方法”。</li>
<li>2). 怎么使用Math类：它内部都是“静态方法”，通过类名就可以直接调用，不需要创建对象，所以帮助文档中没有它的构造方法说明。</li>
<li>3). 常用方法：</li>
</ul>
<blockquote>
<p>1). public static int abs(int a) 获取参数a的绝对值<br />
2). public static double ceil(double a) 向上取整<br />
3). public static double floor(double a) 向下取整<br />
4). public static double pow(double a, double b) 获取a的b次幂<br />
5). public static long round(double a) 四舍五入取整</p>
</blockquote>
<p><img src="/_resources/8d140caa41404923abd82dd26751320a.png" /></p>
<h2 id="9-system类">9. System类</h2>
<ul>
<li>1). java.lang.System(类)：系统类，包含了一些实用的工具性方法。</li>
<li>2). 它不需要被创建对象，内部都是“静态方法”，通过类名可以直接访问。</li>
<li>3). 常用方法：
<ul>
<li>1). public static void exit(int status)：结束JVM 例如：System.exit(0);</li>
<li>2). public static long currentTimeMillis()：获取当前系统时间的毫秒值，相当于：new Date().getTime(); 例如：基础班我们使用它，比较String和StringBuilder的工作效率的时候。 <img src="/_resources/ba6d90b8acab4ef296db6fa5b7a780cb.png" /></li>
</ul>
</li>
</ul>
<hr />
<h2 id="10-总结">10. 总结：</h2>
<ol>
<li>
<p>能够说出Object类的特点</p>
<blockquote>
<p>Object类是所有“类”的基类(父类),包括数组</p>
</blockquote>
</li>
<li>
<p>能够重写Object类的toString方法</p>
<blockquote>
<p>alt + insert --&gt; 选择toString()</p>
</blockquote>
</li>
<li>
<p>能够重写Object类的equals方法</p>
<blockquote>
<p>alt + insert --&gt; 选择equals()</p>
</blockquote>
</li>
<li>
<p>能够使用日期类输出当前日期</p>
<blockquote>
<p>Date date = new Date();
System.out.println(date);//格式看不懂（英文格式）</p>
</blockquote>
</li>
<li>
<p>能够使用将日期格式化为字符串的方法</p>
<blockquote>
<p>SimpleDateFormat sdf = new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”);
String str = sdf.format(new Date());
System.out.println(str);</p>
</blockquote>
</li>
<li>
<p>能够使用将字符串转换成日期的方法</p>
<blockquote>
<p>String str = “1999-11-10”;
SimpleDateFormat sdf = new SimpleDateFormat(“yyyy-MM-dd”);
Date date = sdf.parse(str);</p>
</blockquote>
</li>
<li>
<p>能够使用Calendar类的get、set、add方法计算日期</p>
<blockquote>
<p>1). public int get(int field)：获取某个字段的值
2). public void set(int field,int value)：设置某个字段的值为value。
3). public void add(int field,int value)：将某个字段的值增加/减少指定的value值。</p>
</blockquote>
</li>
<li>
<p>能够使用Math类对某个浮点数进行四舍五入取整</p>
<blockquote>
<p>public static long round(double a) 四舍五入取整</p>
</blockquote>
</li>
<li>
<p>能够使用System类获取当前系统毫秒值</p>
<blockquote>
<p>public static long currentTimeMillis()</p>
</blockquote>
</li>
</ol>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[day02- static、接口、多态、内部类]]></title>
            <guid>3370cb16ddc94cd18a7e2ef2294e008b</guid>
            <pubDate>Tue, 06 Jul 2021 07:32:18 GMT</pubDate>
            <content:encoded><![CDATA[<nav class="table-of-contents"><ul><li><a href="#第一章static关键字">第一章：static关键字</a><ul><li><a href="#11-static关键字_概述">1.1 static关键字_概述</a></li><li><a href="#12-static关键字_静态原理图">1.2 static关键字_静态原理图</a></li><li><a href="#13-static关键字_静态代码块">1.3 static关键字_静态代码块</a><ul><li><a href="#对于有些静态属性不能在声明的同时初始化例如">对于有些”静态属性”不能在声明的同时初始化，例如：</a></li></ul></li><li><a href="#14-以后开发中static的应用">1.4 以后开发中static的应用</a><ul><li><a href="#1static可以修饰">1).static可以修饰：</a></li><li><a href="#2以后开发中使用">2).以后开发中使用：</a></li><li><a href="#3其它注意事项">3).其它注意事项：</a></li></ul></li></ul></li><li><a href="#第二章接口">第二章：接口</a><ul><li><a href="#21-接口的概念视频">2.1 接口的概念(视频)</a><ul><li><a href="#1接口是一种特殊数据类型使用关键字interface定义">1).接口：是一种“特殊”数据类型，使用关键字：interface定义</a></li><li><a href="#2为什么要有接口">2).为什么要有接口：</a></li><li><a href="#3接口的定义使用关键字interface">3).接口的定义：使用关键字：interface</a></li><li><a href="#4接口中的成员jdk8有四种成员">4).接口中的成员(JDK8：有四种成员)</a></li></ul></li><li><a href="#22-子类和接口的关系_实现视频">2.2 子类和接口的关系_实现(视频)</a></li><li><a href="#23-子类多实现时的几种冲突情况">2.3 子类多实现时的几种冲突情况</a><ul><li><a href="#a公有-静态-常量的冲突">A).公有、静态、常量的冲突：</a></li><li><a href="#b公有-抽象方法的冲突">B).公有、抽象方法的冲突：</a></li><li><a href="#c公有-默认方法">C).公有、默认方法：</a></li><li><a href="#d公有-静态方法">D).公有、静态方法：</a></li></ul></li><li><a href="#24-接口继承接口视频">2.4 接口继承接口(视频)</a><ul><li><a href="#1接口和接口之间有一个继承的关系而且可以多继承">1).接口和接口之间，有一个“继承”的关系，而且可以“多继承”：</a></li></ul></li></ul></li><li><a href="#第三章多态">第三章：多态</a><ul><li><a href="#31-多态的概念">3.1 多态的概念</a><ul><li><a href="#1什么是多态指一类事物的多种表现形式">1).什么是“多态”：指“一类事物的多种表现形式”</a></li><li><a href="#2关于java的引用类型">2).关于“Java的引用类型”：</a></li></ul></li><li><a href="#32-多态时访问成员的特点">3.2 多态时访问成员的特点</a></li><li><a href="#33-多态的弊端和好处">3.3 多态的弊端和好处</a><ul><li><a href="#1弊端不能访问子类特有成员">1).弊端：不能访问子类特有成员！</a></li><li><a href="#2好处尤其是作为形参多态时对于程序扩展非常有好处">2).好处：尤其是作为“形参多态”时，对于“程序扩展非常有好处”：</a></li></ul></li><li><a href="#34-多态的几种应用">3.4 多态的几种应用</a><ul><li><a href="#1多态的三种使用方式">1).多态的三种使用方式：</a></li><li><a href="#2多态的三种应用">2).多态的三种应用：</a></li></ul></li><li><a href="#35-多态的转型">3.5 多态的转型</a><ul><li><a href="#1向上转型">1).向上转型：</a></li><li><a href="#2向下转型强制转换">2).向下转型(强制转换)</a></li></ul></li><li><a href="#36-笔记本电脑案例">3.6 笔记本电脑案例</a></li></ul></li><li><a href="#第四章内部类">第四章：内部类</a><ul><li><a href="#41-内部类_概念">4.1 内部类_概念</a><ul><li><a href="#1定义在另一个类内部的类叫内部类">1).定义在另一个类内部的类叫：内部类。</a></li><li><a href="#2内部类有两种">2).内部类有两种：</a></li></ul></li><li><a href="#42-内部类_成员内部类">4.2 内部类_成员内部类</a><ul><li><a href="#1成员内部类是定义在外部类的成员位置类体中方法外">1).成员内部类：是定义在“外部类的成员位置”——类体中，方法外</a></li></ul></li><li><a href="#43-内部类_局部内部类">4.3 内部类_局部内部类</a><ul><li><a href="#1局部内部类是定义在方法内部的类">1).局部内部类：是定义在“方法内部的类”</a></li></ul></li><li><a href="#44-内部类_匿名内部类重点掌握">4.4 内部类_匿名内部类【重点掌握】</a><ul><li><a href="#1匿名内部类是局部内部类的一种它也是定义在方法中的只是没有名字-但是它必须要有一个外部的父类父接口">1).匿名内部类是“局部内部类”的一种，它也是定义在“方法中”的，只是“没有名字”。但是它必须要有一个“外部的父类/父接口”。</a></li><li><a href="#示例">示例：</a></li></ul></li></ul></li><li><a href="#总结">总结：</a><ul><li><a href="#1能够掌握static关键字修饰的变量调用方式">1.能够掌握static关键字修饰的变量调用方式</a><ul><li><a href="#1可以通过对象调用">1).可以通过”对象”调用：</a></li><li><a href="#2可以通过类名调用推荐">2).可以通过”类名”调用：【推荐】</a></li></ul></li><li><a href="#2能够掌握static关键字修饰的方法调用方式">2.能够掌握static关键字修饰的方法调用方式</a><ul><li><a href="#1通过对象调用">1).通过“对象”调用：</a></li><li><a href="#2通过类名调用">2).通过“类名”调用：</a></li></ul></li><li><a href="#3能够写出接口的定义格式">3.能够写出接口的定义格式</a></li><li><a href="#4能够写出接口的实现格式">4.能够写出接口的实现格式</a></li><li><a href="#5能够说出接口中的成员特点">5.能够说出接口中的成员特点</a></li><li><a href="#6能够说出多态的前提">6.能够说出多态的前提</a></li><li><a href="#7能够写出多态的格式">7.能够写出多态的格式</a></li><li><a href="#8能够理解多态向上转型和向下转型">8.能够理解多态向上转型和向下转型</a></li><li><a href="#9能够说出内部类概念">9.能够说出内部类概念</a></li><li><a href="#10能够理解匿名内部类的编写格式">10.能够理解匿名内部类的编写格式</a></li></ul></li></ul></nav><h1 id="第一章static关键字">第一章：static关键字</h1>
<h2 id="11-static关键字_概述">1.1 static关键字_概述</h2>
<p><img src="/_resources/78bfe7deb84043079b39b4286ee25417.png" /></p>
<h2 id="12-static关键字_静态原理图">1.2 static关键字_静态原理图</h2>
<p><img src="/_resources/cd41b34cb2e24080a342a0e1adcb882c.png" /></p>
<h2 id="13-static关键字_静态代码块">1.3 static关键字_静态代码块</h2>
<h3 id="对于有些静态属性不能在声明的同时初始化例如">对于有些”静态属性”不能在声明的同时初始化，例如：</h3>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Var</span>{
    <span class="hljs-comment">//要求：为这个静态的数组的每个元素初始化为：1–100的随机数</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];
    <span class="hljs-comment">//只能使用”静态代码块”对其初始化</span>
    <span class="hljs-comment">//当第一次使用Var类，会先执行一次静态代码块，而且只执行一次。</span>
    <span class="hljs-keyword">static</span>{
        Random rdm = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Random</span>();
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; arr.length ; i++){
            arr[i] = rdm.<span class="hljs-built_in">nextInt</span>(<span class="hljs-number">100</span>) + <span class="hljs-number">1</span>;
        }
    }
}</code></pre></div>
<h2 id="14-以后开发中static的应用">1.4 以后开发中static的应用</h2>
<h3 id="1static可以修饰">1).static可以修饰：</h3>
<blockquote>
<p>1).成员属性：表示：静态属性，存储在”静态存储区”，只有一份存储空间，可以通过“类名”直接访问，比较方便。<br />
2).成员方法：表示：静态方法，存储在”静态存储区”，可以通过“类名”直接访问，比较方便。</p>
</blockquote>
<h3 id="2以后开发中使用">2).以后开发中使用：</h3>
<p>通常对于“一些共享的成员变量、工具性的方法”将其修饰为：static，使用起来比较方便。
例如：
<img src="/_resources/a6e0b272c63e4af5ae45baee1fae834a.png" /></p>
<h3 id="3其它注意事项">3).其它注意事项：</h3>
<blockquote>
<p>由于“静态成员”总是早于“普通成员”进入内存，</p>
<p>所以：静态方法，只能“直接访问”静态成员，不能访问普通成员</p>
<p>普通方法，可以访问“静态成员”，也可以访问“普通成员”。</p>
</blockquote>
<h1 id="第二章接口">第二章：接口</h1>
<h2 id="21-接口的概念视频">2.1 接口的概念(视频)</h2>
<h3 id="1接口是一种特殊数据类型使用关键字interface定义">1).接口：是一种“特殊”数据类型，使用关键字：interface定义</h3>
<div><pre class="hljs"><code>例如：<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">Animal</span>{
}</code></pre></div>
<h3 id="2为什么要有接口">2).为什么要有接口：</h3>
<p><img src="/_resources/8497cad798f64a43a808a24a9dbdd5f7.png" /></p>
<h3 id="3接口的定义使用关键字interface">3).接口的定义：使用关键字：interface</h3>
<div><pre class="hljs"><code>例如：

<span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span>eface ILog{ <span class="hljs-comment">//建议I开头，表示是一个接口</span>

}

编译后，会生成<span class="hljs-keyword">class</span>文件，但“接口”不能被创建对象。

做“父级”的类使用，供子类去实现，重写抽象方法，达到“功能扩展”的目的。</code></pre></div>
<h3 id="4接口中的成员jdk8有四种成员">4).接口中的成员(JDK8：有四种成员)</h3>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ILog</span> {
    <span class="hljs-comment">//1.公有、静态、常量(JDK8以前)：可以被子类继承</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> final <span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span>;
    <span class="hljs-built_in">int</span> b = <span class="hljs-number">20</span>;<span class="hljs-comment">//编译后，会变为：public static final int b = 20;</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> c = <span class="hljs-number">30</span>;<span class="hljs-comment">//编译后，会变为：pubic static fina int c = 30;</span>
    
    <span class="hljs-comment">//2.公有、抽象方法(JDK8以前)：强制子类必须重写</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">log</span>(<span class="hljs-params"></span>)</span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span>(<span class="hljs-params"></span>)</span>;<span class="hljs-comment">//编译后：public abstract void show();</span>
    
    <span class="hljs-comment">//3.公有、默认方法：(JDK8开始)必须用public，default修饰，必须有方法体：被子类继承，子类可以重写，也可以不重写。</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-literal">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show1</span>(<span class="hljs-params"></span>)</span>{
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"默认方法show1()"</span>);
    }
    
    <span class="hljs-comment">//4.公有、静态方法(JDK8开始)：不能被子类继承，就属于本接口，通过"接口名.静态方法名"访问，工具性方法。</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show2</span>(<span class="hljs-params"></span>)</span>{
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"公有、静态的show2()"</span>);
    }
}</code></pre></div>
<h2 id="22-子类和接口的关系_实现视频">2.2 子类和接口的关系_实现(视频)</h2>
<ol>
<li>子类可以“实现”一个或者多个接口，使用关键字：implements</li>
<li>子类实现接口后，必须重写接口中所有的“公有、抽象方法”，否则子类必须是一个“抽象类”。</li>
<li>实现的几种方式：</li>
</ol>
<ul>
<li>
<ol>
<li>子类可以实现一个接口</li>
</ol>
</li>
</ul>
<div><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-symbol">Student</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">ILog</span>{

}</code></pre></div>
<ul>
<li>
<ol start="2">
<li>子类可以同时实现多个接口：</li>
</ol>
</li>
</ul>
<div><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-symbol">Student</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">ILog,<span class="hljs-symbol">IAnimal</span></span>{

}</code></pre></div>
<ul>
<li>
<ol start="3">
<li>子类可以在“继承”的同时，实现一个或多个接口</li>
</ol>
</li>
</ul>
<div><pre class="hljs"><code>public inteface <span class="hljs-type">ILog</span>{}
public inteface <span class="hljs-type">IA</span>{}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Human</span> <span class="hljs-title">implements</span> <span class="hljs-title">ILog</span> , <span class="hljs-title">IA</span></span>{<span class="hljs-comment">//一定要“先继承，后实现”</span>

}</code></pre></div>
<h2 id="23-子类多实现时的几种冲突情况">2.3 子类多实现时的几种冲突情况</h2>
<p>当一个子类同时“实现多个接口”时，在“多个接口”中可能会有一些：成员属性的冲突、抽象方法的冲突、默认方法的冲突、静态方法的冲突：</p>
<h3 id="a公有-静态-常量的冲突">A).公有、静态、常量的冲突：</h3>
<p><img src="/_resources/0cf1e3e3bfce4b1c981931849b367fc8.png" /></p>
<h3 id="b公有-抽象方法的冲突">B).公有、抽象方法的冲突：</h3>
<p><img src="/_resources/d32eec679ae241d4b49e93d0984030b0.png" /></p>
<h3 id="c公有-默认方法">C).公有、默认方法：</h3>
<p><img src="/_resources/508293bc46ef4454b5620a1aa3acef73.png" /></p>
<h3 id="d公有-静态方法">D).公有、静态方法：</h3>
<p><img src="/_resources/4863bc9245bc43eca0dc8902a6ecf949.png" /></p>
<h2 id="24-接口继承接口视频">2.4 接口继承接口(视频)</h2>
<h3 id="1接口和接口之间有一个继承的关系而且可以多继承">1).接口和接口之间，有一个“继承”的关系，而且可以“多继承”：</h3>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">IA</span>{}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">IB</span>{}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">IC</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">IA</span>,<span class="hljs-symbol">IB</span>{<span class="hljs-comment">//接口可以继承其它接口，而且可以多继承</span>
}</code></pre></div>
<p>接口和接口之间：继承关系，而且可以多继承<br />
类和接口之间：实现关系，可以多实现；<br />
类和类之间：继承关系，只能单继承<br />
-------------------------------------------------------------------------------<br />
课后测试：<br />
1).一个接口继承多个接口的冲突情况：<br />
2).一个子类继承父类同时实现一个或多个接口的冲突情况：</p>
<h1 id="第三章多态">第三章：多态</h1>
<p>面向对象语言的三个特征：封装、继承、多态</p>
<h2 id="31-多态的概念">3.1 多态的概念</h2>
<h3 id="1什么是多态指一类事物的多种表现形式">1).什么是“多态”：指“一类事物的多种表现形式”</h3>
<p>Java代码中体现的：“父类类型的变量”存储了它的“子类对象的引用”。`
示例：</p>
<div><pre class="hljs"><code>//<span class="hljs-number">2</span>.多态
Animal a1 <span class="hljs-operator">=</span> new Cat()<span class="hljs-comment">;</span>
a1.eat()<span class="hljs-comment">;</span>

Animal a2 <span class="hljs-operator">=</span> new Dog()<span class="hljs-comment">;</span>
a2.eat()<span class="hljs-comment">;</span></code></pre></div>
<p>“多态”的使用前提：必须要有“继承”/“实现”关系。</p>
<h3 id="2关于java的引用类型">2).关于“Java的引用类型”：</h3>
<div><pre class="hljs"><code>ArrayList list = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>();<span class="hljs-comment">//右边产生的是ArrayList对象的空间，左边是：ArrayList类型的变量存储这个地址。</span>

<span class="hljs-keyword">String</span> str = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>();<span class="hljs-comment">//编译错误，不能用String类型的变量存储ArrayList对象的地址。</span>

Random rdm = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>();<span class="hljs-comment">//编译错误</span>

ArrayList list = <span class="hljs-keyword">new</span> <span class="hljs-type">String</span>(“”);<span class="hljs-comment">//编译错误</span></code></pre></div>
<h2 id="32-多态时访问成员的特点">3.2 多态时访问成员的特点</h2>
<p>1).多态时访问的成员都是“父类的”，只有当子类重写方法时，访问的才是“子类”的。多态时，不能访问子类特有成员。
<img src="/_resources/a5de677b78f64a2dabb799ac9ae686cc.png" /></p>
<h2 id="33-多态的弊端和好处">3.3 多态的弊端和好处</h2>
<h3 id="1弊端不能访问子类特有成员">1).弊端：不能访问子类特有成员！</h3>
<h3 id="2好处尤其是作为形参多态时对于程序扩展非常有好处">2).好处：尤其是作为“形参多态”时，对于“程序扩展非常有好处”：</h3>
<p><img src="/_resources/05624e67e3a24d48b215fcceafc58270.png" /></p>
<h2 id="34-多态的几种应用">3.4 多态的几种应用</h2>
<h3 id="1多态的三种使用方式">1).多态的三种使用方式：</h3>
<div><pre class="hljs"><code><span class="hljs-number">1</span>).父类的多态：
    public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span>{}
    public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span></span>{}
    main(){
    <span class="hljs-type">Animal</span> a = <span class="hljs-keyword">new</span> <span class="hljs-type">Cat</span>();
    }
<span class="hljs-number">2</span>).父抽象类的多态：
    public <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span>{}
    public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span></span>{}
    main(){
    <span class="hljs-type">Animal</span> a = <span class="hljs-keyword">new</span> <span class="hljs-type">Cat</span>();
    }
 <span class="hljs-number">3</span>).父接口的多态
        public interface <span class="hljs-type">IAnimal</span>{}
        public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-title">implements</span> <span class="hljs-title">IAnimal</span></span>{}
        main(){
            <span class="hljs-type">IAnimal</span> a = <span class="hljs-keyword">new</span> <span class="hljs-type">Cat</span>();
        }</code></pre></div>
<h3 id="2多态的三种应用">2).多态的三种应用：</h3>
<div><pre class="hljs"><code><span class="hljs-number">1</span>).变量的多态使用：
<span class="hljs-title class_">Animal</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();

<span class="hljs-number">2</span>).形参的多态使用：
<span class="hljs-comment">//可以接收任何Animal及其子类对象的引用</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">print</span>(<span class="hljs-params">Animal a </span>){

}

<span class="hljs-number">3</span>).返回值的多态：
<span class="hljs-title function_">main</span>(<span class="hljs-params"></span>){
    <span class="hljs-title class_">Animal</span> a = <span class="hljs-title function_">getAnimal</span>();<span class="hljs-comment">//相当于：Animal a = new Cat();</span>
}
<span class="hljs-comment">//可以返回Animal的任何子类对象</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">Animal</span> <span class="hljs-title function_">getAnimal</span>(<span class="hljs-params"></span>){
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<span class="hljs-comment">//也可以return new Dog();</span>
}</code></pre></div>
<h2 id="35-多态的转型">3.5 多态的转型</h2>
<h3 id="1向上转型">1).向上转型：</h3>
<div><pre class="hljs"><code>Animal a = <span class="hljs-keyword">new</span> <span class="hljs-type">Cat</span>();<span class="hljs-comment">//将Cat类型自动提升为Animal类型</span></code></pre></div>
<p>此时不能访问子类特有成员
要想访问子类特有成员，将Animal类型的a转换为Cat类型——向下转型</p>
<h3 id="2向下转型强制转换">2).向下转型(强制转换)</h3>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo12</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String\[\] args)</span> {
    <span class="hljs-comment">//1.向上转型——多态</span>
    <span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();
    a.eat();
    <span class="hljs-comment">// a.catchMouse();//编译错误，不能访问子类特有成员</span>
     <span class="hljs-comment">//2.要想访问子类特有成员，向下转型</span>
        <span class="hljs-keyword">if</span>(a <span class="hljs-keyword">instanceof</span> Cat) {<span class="hljs-comment">//true</span>
            <span class="hljs-type">Cat</span> <span class="hljs-variable">cat</span> <span class="hljs-operator">=</span> (Cat) a;
            cat.eat();
            cat.catchMouse();
        }
        
        <span class="hljs-keyword">if</span>(a <span class="hljs-keyword">instanceof</span> Dog) {<span class="hljs-comment">//false</span>
            <span class="hljs-type">Dog</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> (Dog) a;
            dog.eat();
        }
}</code></pre></div>
<p>}</p>
<h2 id="36-笔记本电脑案例">3.6 笔记本电脑案例</h2>
<p>此案例可以说明“多态的好处”
<img src="/_resources/1f72a2246b634ebcae0ee91429600360.png" /></p>
<p>代码实现：</p>
<p><img src="/_resources/218a08ba83de40fcbd1bc0250b076c79.png" /></p>
<div><pre class="hljs"><code>    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IA</span>{
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show1</span><span class="hljs-params">()</span>;
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IB</span>{
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show2</span><span class="hljs-params">()</span>;
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Zi</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IA</span>,IB{
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show1</span><span class="hljs-params">()</span>{
        }
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show2</span><span class="hljs-params">()</span>{
        }
    }
    main(){
        <span class="hljs-type">IA</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Zi</span>();
        a.show1();
        <span class="hljs-type">IB</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Zi</span>();
        b.show2();
    } </code></pre></div>
<h1 id="第四章内部类">第四章：内部类</h1>
<h2 id="41-内部类_概念">4.1 内部类_概念</h2>
<h3 id="1定义在另一个类内部的类叫内部类">1).定义在另一个类内部的类叫：内部类。</h3>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">Student</span> {
    <span class="hljs-comment">//1.成员属性</span>
    <span class="hljs-comment">//2.成员方法</span>
    <span class="hljs-comment">//3.构造方法</span>
    <span class="hljs-comment">//4.内部类</span>
    <span class="hljs-keyword">class</span> <span class="hljs-symbol">A</span>{
    } 
}</code></pre></div>
<h3 id="2内部类有两种">2).内部类有两种：</h3>
<blockquote>
<p>1).成员内部类：</p>
<p>2).局部内部类：</p>
<ul>
<li>|–匿名局部内部类【常用】</li>
</ul>
</blockquote>
<h2 id="42-内部类_成员内部类">4.2 内部类_成员内部类</h2>
<h3 id="1成员内部类是定义在外部类的成员位置类体中方法外">1).成员内部类：是定义在“外部类的成员位置”——类体中，方法外</h3>
<p><img src="/_resources/7c1726a1808e4fdf9afacc75d3f60c93.png" /></p>
<h2 id="43-内部类_局部内部类">4.3 内部类_局部内部类</h2>
<h3 id="1局部内部类是定义在方法内部的类">1).局部内部类：是定义在“方法内部的类”</h3>
<p><img src="/_resources/edcae83f0e1f4a0d97fb9859a3bea6e1.png" /></p>
<h2 id="44-内部类_匿名内部类重点掌握">4.4 内部类_匿名内部类【重点掌握】</h2>
<h3 id="1匿名内部类是局部内部类的一种它也是定义在方法中的只是没有名字-但是它必须要有一个外部的父类父接口">1).匿名内部类是“局部内部类”的一种，它也是定义在“方法中”的，只是“没有名字”。但是它必须要有一个“外部的父类/父接口”。</h3>
<p>语法：</p>
<div><pre class="hljs"><code><span class="hljs-keyword">new</span> <span class="hljs-type"></span>父类/父接口(){
<span class="hljs-comment">//子类类体</span>
}</code></pre></div>
<h3 id="示例">示例：</h3>
<p><img src="/_resources/b91e9742f7124a29b84fe79d37918a27.png" /></p>
<hr />
<h1 id="总结">总结：</h1>
<h2 id="1能够掌握static关键字修饰的变量调用方式">1.能够掌握static关键字修饰的变量调用方式</h2>
<h3 id="1可以通过对象调用">1).可以通过”对象”调用：</h3>
<div><pre class="hljs"><code>Var v <span class="hljs-operator">=</span> new Var()<span class="hljs-comment">;</span>
System.out.println(v.school)<span class="hljs-comment">;</span></code></pre></div>
<h3 id="2可以通过类名调用推荐">2).可以通过”类名”调用：【推荐】</h3>
<div><pre class="hljs"><code>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">Var</span>.school);</code></pre></div>
<h2 id="2能够掌握static关键字修饰的方法调用方式">2.能够掌握static关键字修饰的方法调用方式</h2>
<h3 id="1通过对象调用">1).通过“对象”调用：</h3>
<div><pre class="hljs"><code>v.getMax<span class="hljs-comment">(…)</span></code></pre></div>
<h3 id="2通过类名调用">2).通过“类名”调用：</h3>
<div><pre class="hljs"><code><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Var</span>.</span></span>get<span class="hljs-constructor">Max(…)</span>;</code></pre></div>
<h2 id="3能够写出接口的定义格式">3.能够写出接口的定义格式</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">IAnimal</span>{}</code></pre></div>
<h2 id="4能够写出接口的实现格式">4.能够写出接口的实现格式</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">Zi</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">IAnimal</span>{}</code></pre></div>
<h2 id="5能够说出接口中的成员特点">5.能够说出接口中的成员特点</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IAnimal</span></span>{
    <span class="hljs-comment">//JDK8(四种成员)</span>
    <span class="hljs-comment">//1.公有、静态、常量</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;
    <span class="hljs-comment">//2.公有、抽象方法</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>;
    <span class="hljs-comment">//3.公有、默认方法</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show1</span><span class="hljs-params">()</span></span>{
    }
    <span class="hljs-comment">//4.公有、静态方法【不能被子类继承】</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show2</span><span class="hljs-params">()</span></span>{
    }
}</code></pre></div>
<h2 id="6能够说出多态的前提">6.能够说出多态的前提</h2>
<p>必须要有“继承”/“实现”</p>
<h2 id="7能够写出多态的格式">7.能够写出多态的格式</h2>
<p>父类/父接口 变量名 = new 子类对象();</p>
<h2 id="8能够理解多态向上转型和向下转型">8.能够理解多态向上转型和向下转型</h2>
<div><pre class="hljs"><code><span class="hljs-number">1</span>).向上转型：多态
Animal a <span class="hljs-operator">=</span> new Cat()<span class="hljs-comment">;</span>
不能访问子类特有成员
<span class="hljs-number">2</span>).向下转型：
if(a instanceof Cat){
Cat c <span class="hljs-operator">=</span> (Cat)a<span class="hljs-comment">;</span>
可以访问子类特有成员
}</code></pre></div>
<h2 id="9能够说出内部类概念">9.能够说出内部类概念</h2>
<p>定义在另一个类内部的类，叫：内部类</p>
<h2 id="10能够理解匿名内部类的编写格式">10.能够理解匿名内部类的编写格式</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">new</span> <span class="hljs-type"></span>父类/父接口(){
<span class="hljs-comment">//子类类体</span>
}</code></pre></div>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[day01-复习、继承、抽象类、final关键字]]></title>
            <guid>997ccd40019040e5a04446e7f70506f8</guid>
            <pubDate>Tue, 06 Jul 2021 07:22:52 GMT</pubDate>
            <content:encoded><![CDATA[<nav class="table-of-contents"><ul><li><a href="#第一章面向对象回顾">第一章：面向对象回顾</a><ul><li><a href="#11-面向对象回顾类与对象">1.1 面向对象回顾–类与对象</a></li><li><a href="#12面向对象回顾匿名对象">1.2面向对象回顾–匿名对象</a></li></ul></li><li><a href="#第二章继承重点">第二章：继承【重点】</a><ul><li><a href="#21-继承的概念及作用">2.1 继承的概念及作用</a></li><li><a href="#22-继承的实现原理及成员访问">2.2 继承的实现原理及成员访问</a></li><li><a href="#23-子类覆盖父类成员">2.3 子类覆盖父类成员</a></li><li><a href="#24-继承的特点">2.4 继承的特点</a></li><li><a href="#25-this-和super关键字">2.5 this 和super关键字</a></li><li><a href="#26-this的穿透性和super的穿透性">2.6 this的穿透性和super的穿透性</a></li></ul></li><li><a href="#第三章抽象类重点">第三章：抽象类【重点】</a><ul><li><a href="#31-抽象类的概念">3.1 抽象类的概念</a></li><li><a href="#32-抽象类和抽象方法的定义">3.2 抽象类和抽象方法的定义</a></li><li><a href="#33-抽象类的特点">3.3 抽象类的特点</a></li></ul></li><li><a href="#第四章final关键字">第四章：final关键字</a><ul><li><a href="#41-final关键字概述">4.1 final关键字概述</a></li><li><a href="#42final的应用位置">4.2final的应用位置：</a></li><li><a href="#43-经验值分享">4.3 经验值分享：</a></li></ul></li></ul></nav><h1 id="第一章面向对象回顾">第一章：面向对象回顾</h1>
<h3 id="11-面向对象回顾类与对象">1.1 面向对象回顾–类与对象</h3>
<p>1).我们之前学过“类”，例如：Student类，它内部可以定义一些“变量、方法”，作用：它是一种“结构”，或者说是“自定义类型”这种类型是由很多的：变量、方法组成，是一种自	定义的、新的、复合类型。它用来表示一个“学员信息”，在程序中，它的一个“对象”主要用于“存储一个学员信息”。</p>
<img width="1082" height="380" src="/_resources/050f23cd775a42f49956b1560aa528fd.jpg" class="jop-noMdConv" />
<p>2).还有例如：Scanner类、Random类等，这些类都是提供了一些“功能(方法)”.</p>
<p>3).类中可以定义：</p>
<blockquote>
<p>1).成员变量：存储“用户数据”；</p>
<p>2).构造方法：初始化“成员变量”的(尤其是指全参构造)</p>
<p>3).成员方法：get/set方法：操作成员变量；其它成员方法：用于描述此类的一个功能。</p>
</blockquote>
<p><strong>public class</strong> Student {</p>
<p><a title="//1.xn--jsrq0qc7c28b" href="//1.xn--jsrq0qc7c28b">//1.成员属性</a></p>
<p><strong>private</strong> String <strong>name</strong>;</p>
<p><strong>private</strong> String <strong>sex</strong>;</p>
<p><strong>private int</strong> <strong>age</strong>;</p>
<p><em><a title="//2.xn--nfvu3by6hsy6b" href="//2.xn--nfvu3by6hsy6b">//2.构造方法</a></em></p>
<p><strong>public</strong> Student() {</p>
<p>}</p>
<p><strong>public</strong> Student(String name, String sex, <strong>int</strong> age) {</p>
<p><strong>this</strong>.<strong>name</strong> = name;</p>
<p><strong>this</strong>.<strong>sex</strong> = sex;</p>
<p><strong>this</strong>.<strong>age</strong> = age;</p>
<p>}</p>
<p><strong><a title="//3.xn--jsr123amyc91j" href="//3.xn--jsr123amyc91j">//3.成员方法</a></strong></p>
<p><strong>public</strong> String getName() {</p>
<p><strong>return</strong> <strong>name</strong>;</p>
<p>}</p>
<p><strong>public void</strong> setName(String name) {</p>
<p><strong>this</strong>.<strong>name</strong> = name;</p>
<p>}</p>
<p><strong>public</strong> String getSex() {</p>
<p><strong>return</strong> <strong>sex</strong>;</p>
<p>}</p>
<p><strong>public void</strong> setSex(String sex) {</p>
<p><strong>this</strong>.<strong>sex</strong> = sex;</p>
<p>}</p>
<p><strong>public int</strong> getAge() {</p>
<p><strong>return</strong> <strong>age</strong>;</p>
<p>}</p>
<p><strong>public void</strong> setAge(<strong>int</strong> age) {</p>
<p><strong>this</strong>.<strong>age</strong> = age;     }</p>
<p>}</p>
<img width="711" height="340" src="/_resources/55fb682100ed405886e5a078c2c1947c.jpg" class="jop-noMdConv" />
<h3 id="12面向对象回顾匿名对象">1.2面向对象回顾–匿名对象</h3>
<p>1).什么是“匿名对象”：没有名字的对象！</p>
<p>l以前都是有名字的对象：</p>
<p>Student stu = new Student();</p>
<p>Random rdm = new Random();</p>
<p>stu和rdm就是两个对象的名字，创建完对象后，我们可以通过这个“对象名”反复的使用这个对象！！</p>
<p>l某种情况下，为了书写方便，我们可以不为“对象”起名字，这样创建的对象就是：匿名对象，例如：</p>
<p>new Student();</p>
<p>2).“匿名对象”的主要的两个应用场景：</p>
<p>1).对于某个类中的某个方法，只调用一次：</p>
<p>例如：现有一个Student类：</p>
<p>public class Student(){</p>
<p>public void show(){</p>
<p>System.out.println(“我在传智播客顺义校区！”);</p>
<p>}</p>
<p>public void show1(){</p>
<p>}</p>
<p>}</p>
<p>//测试类：</p>
<p>public class Demo01{</p>
<p>public static void main(String[] args){</p>
<p>//此时只想调用一下show()方法：</p>
<p><a title="//1.xn--rutz60aoshxyx" href="//1.xn--rutz60aoshxyx">//1.正常调用</a>,但是，调用后，Student对象就没有用了，但会一直在内存中，占用内存空间</p>
<p>Student stu = new Student();</p>
<p>stu.show();</p>
<p>//2.<strong>采用“匿名对象”的方式：</strong></p>
<p>new Student().show();//show()方法调用完毕，Student对象立即成员垃圾，因为没有名字</p>
<p>}</p>
<p>}</p>
<p>2).当调用方法，需要传入某个对象时：</p>
<p><strong>public class</strong> Demo01 {</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p><em><a title="//1.xn--4gqvd70ltxc8xnizax7m359h" href="//1.xn--4gqvd70ltxc8xnizax7m359h">//1.创建一个学员对象</a></em></p>
<p>Student stu1 = <strong>new</strong> Student();</p>
<p>stu1.setName(<strong>“张三”</strong>);</p>
<p>stu1.setSex(<strong>“男”</strong>);</p>
<p>stu1.setAge(18);</p>
<p>System.<em><strong>out</strong></em>.println(stu1.getName() + <strong>" , "</strong> + stu1.getSex() + <strong>" , "</strong> + stu1.getAge());</p>
<p><em><a title="//2.xn--ciq1iq0bv8i8rkt6ft4bo20hfc5a" href="//2.xn--ciq1iq0bv8i8rkt6ft4bo20hfc5a">//2.记录第二个学员信息</a></em></p>
<p>Student stu2 = <strong>new</strong> Student(<strong>“李四”</strong>, <strong>“女”</strong>, 19);</p>
<p>System.<em><strong>out</strong></em>.println(stu2.getName() + <strong>" , "</strong> + stu2.getSex() + <strong>" , "</strong> + stu2.getAge());</p>
<p>Student stu = <strong>new</strong> Student();</p>
<p><em>print</em>(stu);<em>//传完后，在main()方法中Student对象已经没有用了，但会一直在内存中</em></p>
<p>/采用"匿名对象"的方式</p>
<p><em><strong><em>print</em>(<strong>new</strong> Student());</strong></em></p>
<p>**/*<em><strong>/print()方法结束后，Student对象会立即成为垃圾。</strong></em>}</p>
<p><strong>public static void</strong> print(Student stu){</p>
<p>stu.show();</p>
<p>}</p>
<p>}</p>
<h1 id="第二章继承重点">第二章：继承【重点】</h1>
<p>面向对象语言的三大特征：封装、继承、多态</p>
<h3 id="21-继承的概念及作用">2.1 继承的概念及作用</h3>
<p>视频</p>
<img width="800" height="436" src="/_resources/840b1252221142fc99478cc6e01a53e1.jpg" class="jop-noMdConv" />
<h3 id="22-继承的实现原理及成员访问">2.2 继承的实现原理及成员访问</h3>
<p>视频</p>
<img width="721" height="357" src="/_resources/3e7b5dcf31fb412188a5659766d29c0e.jpg" class="jop-noMdConv" />
<h3 id="23-子类覆盖父类成员">2.3 子类覆盖父类成员</h3>
<img width="876" height="346" src="/_resources/db6dd9ee056b4793976f968ed55fb4ed.jpg" class="jop-noMdConv" />
<p><strong>子类方法覆盖父类方法：重写</strong></p>
<p><strong>1).子类重写父类方法要保证：</strong></p>
<p><strong>1.返回值类型、方法名、形参列表必须跟父类相同；</strong></p>
<p><strong>2.访问权限修饰符必须跟父类相同，或者比父类更宽！</strong></p>
<h3 id="24-继承的特点">2.4 继承的特点</h3>
<p><strong>1)父类的“私有成员(成员属性、成员方法)”可以被子类继承，但不能被访问！！！——就相当于不能被继承</strong></p>
<p>public class Human{</p>
<p>String name;</p>
<p>private int money = 2000;</p>
<p>}</p>
<p>public class Student extends Human{</p>
<p>}</p>
<p>//测试类</p>
<p>main(){</p>
<p>Student stu = new Student();</p>
<p>System.out.println(stu.name);//Ok的，可以被继承，也可以被访问；</p>
<p>System.out.println(stu.money);//编译错误，可以被继承，但不能被子类访问——相当于不能被继承！</p>
<p>}</p>
<p>================================================================================================</p>
<p>正常编写的父类：</p>
<p>public class Human{</p>
<p>private String name;</p>
<p>private String sex;</p>
<p>private int age;</p>
<p>//提供公有的get/set方法</p>
<p>public void setName(String name){</p>
<p>this.name = name;</p>
<p>}</p>
<p>public String getName(){</p>
<p>return this.name;</p>
<p>}</p>
<p>…</p>
<p>}</p>
<p>//子类</p>
<p>public class Student extends Human{</p>
<p>}</p>
<p>//测试类：</p>
<p>main(){</p>
<p>Student stu = new Student();</p>
<p>stu.setName(“张三”);</p>
<p>}</p>
<p><strong>2).Java只能“单继承”——不能同时继承多个父类：</strong></p>
<p>class A{</p>
<p>public void show(){</p>
<p>System.out.println(“a”);</p>
<p>}</p>
<p>}</p>
<p>class B{</p>
<p>public void show(){</p>
<p>System.out.println(“b”);</p>
<p>}</p>
<p>}</p>
<p>class Zi extends A,B{//编译错误，不能同时继承两个类</p>
<p>}</p>
<p><strong>3).Java可以“多级继承”：</strong></p>
<p>class A{}</p>
<p>class B extends A{}</p>
<p>class C extends B{}</p>
<h3 id="25-this-和super关键字">2.5 this 和super关键字</h3>
<p>1).this关键字：可以访问“本类”的：成员属性、成员方法、构造方法。</p>
<p>1).访问“本类的”成员属性：通常不需要，但当：局部变量覆盖成员变量时，要访问被覆盖的成员变量，必须用this：</p>
<img width="613" height="197" src="/_resources/4627cc0c533d4078922bc57c995dd364.jpg" class="jop-noMdConv" />
<p>2).访问“本类的”其它成员方法：通常不需要：</p>
<img width="511" height="204" src="/_resources/34819a709f9d4fb49a898fedfbcd8f44.jpg" class="jop-noMdConv" />
<p>3).可以在一个构造方法中，调用另一个构造方法：必须用this()调用</p>
<img width="484" height="394" src="/_resources/a3002faaf0664432a723e46f0c96f548.jpg" class="jop-noMdConv" />
<p>2.super关键字：必须在“子类”中使用，可以在“子类中”访问“父类”的：成员属性、成员方法、构造方法</p>
<p>1).访问“父类”的成员属性：通常不用，当：子类的“成员变量”覆盖父类的“成员变量”，要访问被覆盖的父类成员变量时，必须用 “super.父类成员变量”来访问：</p>
<img width="495" height="228" src="/_resources/037939892cad4f2cb2ba350781e8d14e.jpg" class="jop-noMdConv" />
<p>2).访问“父类”的成员方法：通常不用，当：子类的“成员方法”覆盖了父类的“成员方法”，要访问被覆盖的父类的成员方法时，必须用“super.方法名()”的形式访问：</p>
<img width="563" height="296" src="/_resources/e9cd7adca4e24bd3b7b24d5d48ee1c12.jpg" class="jop-noMdConv" />
<p>3).在子类的构造方法中，调用父类的构造方法：必须用super()</p>
<img width="535" height="334" src="/_resources/52b4e26fdba04a3e8b3d872854e5f718.jpg" class="jop-noMdConv" />
<p>=============================================================================</p>
<p>注意：</p>
<p>1).在“子类”中，每个构造方法的第一句话，都会隐式的添加：super();</p>
<p>表示：调用父类“无参构造”。</p>
<p>public class Fu{</p>
<p>public Fu(){</p>
<p>System.out.println(“a”);</p>
<p>}</p>
<p>public Fu(String name,int age){</p>
<p>System.out.println(“b”);</p>
<p>}</p>
<p>}</p>
<p>public class Zi extneds Fu{</p>
<p>public Zi(){</p>
<p>System.out.println(“c”);</p>
<p>}</p>
<p>public Zi(String name,int age){</p>
<p>System.out.println(“d”);</p>
<p>}</p>
<p>}</p>
<p>//测试类：</p>
<p>main(){</p>
<p>Zi z1 = new Zi();//ac</p>
<p>Zi z2 = new Zi(“aa”,22);//ad</p>
<p>}</p>
<p>=======================================================================================</p>
<p>通常的情况：子类需要定义跟父类“一样形式”的构造方法：</p>
<img width="678" height="419" src="/_resources/910d7823b4a4479f8cf1b09f48897c92.jpg" class="jop-noMdConv" />
<h3 id="26-this的穿透性和super的穿透性">2.6 this的穿透性和super的穿透性</h3>
<img width="935" height="593" src="/_resources/09766e9ee6da4ee1ae262108723abdb5.jpg" class="jop-noMdConv" />
<p>======================================================================================================================</p>
<p>1).定义动物类：</p>
<blockquote>
<p>成员属性：名字、年龄、性别</p>
<p>成员方法：吃饭、睡觉</p>
</blockquote>
<p>2).定义子类：猫类，继承动物类</p>
<blockquote>
<p>成员属性：颜色</p>
<p>成员方法：捉老鼠</p>
</blockquote>
<p>3).定义子类：狗类，继承动物类</p>
<blockquote>
<p>成员属性：品种</p>
<p>成员方法：看家护院</p>
</blockquote>
<p>4).定义测试类：</p>
<blockquote>
<p>1).创建一个“猫对象”：“花花”，2，“母”，“栗色”</p>
<p>调用方法：吃饭、睡觉、捉老鼠</p>
<p>2).创建一个“狗对象”：“小强”，4，“公”，“德国牧羊犬”</p>
<p>调用方法：吃饭、谁、看家护院</p>
<p>见demo03</p>
</blockquote>
<p>===================================================================================================================</p>
<blockquote>
<p>1).定义一个水果类：</p>
<p>成员属性：产地、价格、采摘日期</p>
<p>成员方法：采摘(打印采摘日期)</p>
<p>2).定义一个“苹果类”，继承自：水果类</p>
<p>成员方法：重写“采摘”，打印：我是苹果，我是xxx年xx月xx日采摘的！</p>
<p>3).定义一个“桔子类”，继承自：水果类</p>
<p>成员方法：重写“采摘”，打印：我是桔子，我的xxx年xx月xx日采摘的！</p>
<p>见demo04</p>
</blockquote>
<h1 id="第三章抽象类重点">第三章：抽象类【重点】</h1>
<h3 id="31-抽象类的概念">3.1 抽象类的概念</h3>
<p>视频</p>
<img width="838" height="431" src="/_resources/f95358a0fce7409295a82524b3352c47.jpg" class="jop-noMdConv" />
<h3 id="32-抽象类和抽象方法的定义">3.2 抽象类和抽象方法的定义</h3>
<p>1).抽象类：</p>
<p><strong>public abstract class</strong> Human { *<a title="//1.xn--jsrq0qc7c28b" href="//1.xn--jsrq0qc7c28b">//1.成员属性</a><strong><a title="//2.xn--nfvu3by6hsy6b" href="//2.xn--nfvu3by6hsy6b">//2.构造方法</a></strong><a title="//3.xn--jsr123amycvuao2wz98c" href="//3.xn--jsr123amycvuao2wz98c">//3.普通成员方法</a>**<a title="//4.xn--tsu79d91i6m9a" href="//4.xn--tsu79d91i6m9a">//4.抽象方法</a>(没有方法体的方法)* }</p>
<p><strong>作用：不能被创建对象，只能做父类，代码复用！！</strong></p>
<p>2).抽象方法的定义：</p>
<p><strong>public abstract</strong> <strong>返回值类型</strong>/void work([形参]);//可以有参、有返回值，就是不能有“方法体”</p>
<p>作用：被子类继承，并且要求子类必须重写的——对子类形成限制！</p>
<h3 id="33-抽象类的特点">3.3 抽象类的特点</h3>
<p>1).抽象类：不能被创建对象，就是用来做“父类”被子类继承的！</p>
<p>2).子类继承了抽象类后，必须重写抽象类中所有的“抽象方法”，否则子类也必须是“抽象类”！</p>
<p>3).抽象类中可以不定义抽象方法；</p>
<p>但如果有“抽象方法”，这个类必须被定义为“抽象类”！！</p>
<p>4).抽象类不能被创建对象，但可以有“构造方法”，用于给子类初始化成员属性的：</p>
<img width="424" height="363" src="/_resources/3f6ab567156945e19333abb155822641.jpg" class="jop-noMdConv" />
<p>5).子类继承抽象类，仍然用extends关键字，而且必须是“单继承”！</p>
<h1 id="第四章final关键字">第四章：final关键字</h1>
<h3 id="41-final关键字概述">4.1 final关键字概述</h3>
<p>1).final表示：“最终”的</p>
<p>2).它可以修饰：</p>
<blockquote>
<p>1).类</p>
<p>2).成员属性</p>
<p>3).成员方法</p>
<p>4).局部变量</p>
</blockquote>
<p>3).注意：一共5个位置中的4个</p>
<img width="369" height="228" src="/_resources/4147d95f08cd4a9e8fb4e684fa56e15a.jpg" class="jop-noMdConv" />
<h3 id="42final的应用位置">4.2final的应用位置：</h3>
<p><strong>1).修饰类：表示”此类不能被继承”——太监类</strong></p>
<blockquote>
<p>public final class String{</p>
<p>…</p>
<p>}</p>
<p>此类不能被其它类继承；</p>
</blockquote>
<p>2).<strong>修饰“成员方法”：表示“此方法只能被子类继承，但不能被重写”！</strong></p>
<blockquote>
<p>public class Fu{</p>
<p>public void eat(){//需要子类继承，也可以重写</p>
<p>System.out.println(“牛肉炖萝卜”);</p>
<p>}</p>
<p>public <strong>final</strong>void study(){//需要子类继承，但这个方法就不想被子类重写</p>
<p>System.out.println(“必须要考大学，学Java”);</p>
<p>}</p>
<p>}</p>
<p>public class Zi extends Fu{</p>
<p>//可以重写eat()</p>
<p>public void eat(){</p>
<p>System.out.println(“我吃KFC…”);</p>
<p>}</p>
<p><strong>//<strong><strong>重写s</strong></strong>tudy()</strong></p>
<p>public void study(){//<strong>编译错误</strong></p>
<p>**    System.out.println(“<strong><strong>我不考大学，我要学P</strong></strong>HP”);**</p>
<p>**    }**</p>
<p>}</p>
</blockquote>
<p><strong>3</strong>).<strong>修饰：成员变量、局部变量：表示“常量”，其值只能被初始化一次，之后就不能被修改了！</strong></p>
<blockquote>
<p>1).基本数据类型：表示“值”不能改变！</p>
<p>final int a = 10;</p>
<p>a = 20;//<strong>编译错误</strong></p>
<p>2).引用数据类型：表示“地址(引用)”不能改变！</p>
<p>final int[] arr = {1,2,3};</p>
<p>arr[0] = 100;//OK的</p>
<p>arr = new int[10];//<strong>编译错误！！不能更改引用！！</strong></p>
</blockquote>
<hr />
<h3 id="43-经验值分享">4.3 经验值分享：</h3>
<p>总结：</p>
<p><strong>1</strong>.<strong>能够写出类的继承格式</strong></p>
<blockquote>
<p><strong>public class Fu{}</strong></p>
<p><strong>public class Zi</strong> <strong>extends</strong> <strong>Fu{</strong></p>
<p><strong>}</strong></p>
</blockquote>
<p><strong>2</strong>.<strong>能够说出继承的特点</strong></p>
<blockquote>
<p><strong>1). 父类的私有成员可以被继承，但不能被访问</strong></p>
<p><strong>2).Java只能单继承</strong></p>
<p><strong>3).Java可以多级继承；</strong></p>
</blockquote>
<p><strong>3</strong>.<strong>能够说出子类调用父类的成员特点</strong></p>
<blockquote>
<p><strong>先在子类中找，找到就用子类的；找不到就去父类中找！</strong></p>
</blockquote>
<p><strong>4</strong>.<strong>能够说出方法重写的概念</strong></p>
<blockquote>
<p><strong>子类定义跟父类“一模一样”(返回值类型、方法名、形参列表)的方法，这种形式叫：重写</strong></p>
</blockquote>
<p><strong>5</strong>.<strong>能够说出this可以解决的问题</strong></p>
<blockquote>
<p><strong>this：当局部变量覆盖成员变量时，要访问成员变量，必须用this.成员属性</strong></p>
<p><strong>在一个构造方法中，调用另一个构造方法，这时必须用this()</strong></p>
</blockquote>
<p><strong>6</strong>.<strong>能够说出super可以解决的问题</strong></p>
<blockquote>
<p><strong>super：当子类的成员变量，覆盖父类的成员变量时，要访问被覆盖的父类的成员变量时，必须使用：super.父类成员变量名</strong></p>
<p><strong>当子类的成员方法，覆盖父类的成员方法时，要访问被覆盖的父类的成员方法时，必须使用：super.父类成员方法名(****)</strong></p>
<p><strong>当在子类的构造方法中调用父类的构造方法时，必须使用super（实参)</strong></p>
</blockquote>
<p><strong>7</strong>.<strong>能够描述抽象方法的概念</strong></p>
<blockquote>
<p><strong>抽象方法：没有方法体的方法，要求子类必须继承，并强制子类重写的方法。</strong></p>
</blockquote>
<p><strong>8</strong>.<strong>能够写出抽象类的格式</strong></p>
<blockquote>
<p><strong>public abstract class</strong> <strong>类名{</strong></p>
<p><strong>}</strong></p>
</blockquote>
<p><strong>9</strong>.<strong>能够写出抽象方法的格式</strong></p>
<blockquote>
<p><strong>public abstract class</strong> <strong>类名{</strong></p>
<p>//<strong>抽象方法</strong></p>
<p><strong>public abstract</strong> <strong>返回值类型</strong> <strong>方法名(<strong><strong>[<strong><strong>参数]</strong></strong>)</strong></strong>;</strong></p>
<p><strong>}</strong></p>
</blockquote>
<p>10.<strong>能够说出父类抽象方法的存在意义</strong></p>
<blockquote>
<p><strong>强制子类继承，并重写！</strong></p>
</blockquote>
<p>11.<strong>能够描述final修饰的类的特点</strong></p>
<blockquote>
<p><strong>不能被继承</strong></p>
</blockquote>
<p>12.<strong>能够描述final修饰的方法的特点</strong></p>
<blockquote>
<p><strong>不能被重写(但可以被继承)</strong></p>
</blockquote>
<p>13.<strong>能够描述final修饰的变量的特点</strong></p>
<blockquote>
<p><strong>只能初始化一次，之后就不能被修改了——常量</strong></p>
<p><strong>基本数据类型：值不能更改；</strong></p>
<p><strong>引用数据类型：地址不能被更改；</strong></p>
</blockquote>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[day16_单例、多例、枚举、工厂模式、正则表达式]]></title>
            <guid>b2efbd92b4204546861bd944b35f94d0</guid>
            <pubDate>Mon, 19 Apr 2021 01:21:49 GMT</pubDate>
            <content:encoded><![CDATA[<nav class="table-of-contents"><ul><li><a href="#day16-单例模式-多例模式-枚举-工厂模式-正则表达式">day16 单例模式、多例模式、枚举、工厂模式、正则表达式</a><ul><li><a href="#昨日重点内容回顾">昨日重点内容回顾</a></li><li><a href="#今日学习目标">今日学习目标</a></li></ul></li><li><a href="#第一章-单例设计模式">第一章 单例设计模式</a><ul><li><a href="#11-单例设计模式的作用">1.1 单例设计模式的作用</a></li><li><a href="#12-单例设计模式实现步骤">1.2 单例设计模式实现步骤</a></li><li><a href="#13-单例设计模式的类型">1.3 单例设计模式的类型</a></li><li><a href="#14-饿汉单例设计模式">1.4 饿汉单例设计模式</a></li><li><a href="#15-懒汉单例设计模式">1.5 懒汉单例设计模式</a></li><li><a href="#16-小结">1.6 小结</a></li></ul></li><li><a href="#第二章-多例设计模式">第二章 多例设计模式</a><ul><li><a href="#21多例设计模式的作用">2.1.多例设计模式的作用</a></li><li><a href="#22实现步骤">2.2.实现步骤</a></li><li><a href="#23实现代码如下">2.3.实现代码如下:</a></li><li><a href="#24测试结果">2.4.测试结果:</a></li><li><a href="#25多例模式小结">2.5.多例模式小结:</a></li></ul></li><li><a href="#第三章-枚举">第三章 枚举</a><ul><li><a href="#31-不使用枚举存在的问题">3.1 不使用枚举存在的问题</a></li><li><a href="#32-枚举的作用与应用场景">3.2 枚举的作用与应用场景</a></li><li><a href="#33-枚举的基本语法">3.3 枚举的基本语法</a><ul><li><a href="#331-枚举的概念">3.3.1 枚举的概念</a></li><li><a href="#332-定义枚举的格式">3.3.2 定义枚举的格式</a></li><li><a href="#333-入门案例">3.3.3 入门案例</a></li><li><a href="#334-枚举的其他内容">3.3.4 枚举的其他内容</a></li></ul></li><li><a href="#34-应用场景">3.4 应用场景</a></li><li><a href="#35-枚举的应用">3.5 枚举的应用</a></li><li><a href="#36-小结">3.6 小结</a></li></ul></li><li><a href="#第四章-工厂设计模式">第四章 工厂设计模式</a><ul><li><a href="#41工厂模式概述">4.1.工厂模式概述:</a></li><li><a href="#42工厂模式作用">4.2.工厂模式作用:</a></li><li><a href="#43工厂模式实现步骤">4.3.工厂模式实现步骤:</a></li><li><a href="#44工厂模式实现代码">4.4.工厂模式实现代码:</a></li><li><a href="#45工厂模式小结">4.5.工厂模式小结</a></li></ul></li><li><a href="#第五章-正则表达式">第五章 正则表达式</a><ul><li><a href="#51-正则表达式的概念及演示">5.1 正则表达式的概念及演示</a></li><li><a href="#52-正则表达式-字符类">5.2 正则表达式-字符类</a></li><li><a href="#53-正则表达式-逻辑运算符">5.3 正则表达式-逻辑运算符</a></li><li><a href="#54-正则表达式-预定义字符">5.4 正则表达式-预定义字符</a></li><li><a href="#55-正则表达式-数量词">5.5 正则表达式-数量词</a></li><li><a href="#56-正则表达式-分组括号">5.6 正则表达式-分组括号( )</a></li><li><a href="#57-string的split方法中使用正则表达式">5.7 String的split方法中使用正则表达式</a></li><li><a href="#58-string类的replaceall方法中使用正则表达式">5.8 String类的replaceAll方法中使用正则表达式</a></li></ul></li></ul></nav><h1 id="day16-单例模式-多例模式-枚举-工厂模式-正则表达式">day16 单例模式、多例模式、枚举、工厂模式、正则表达式</h1>
<h2 id="昨日重点内容回顾">昨日重点内容回顾</h2>
<div><pre class="hljs"><code><span class="hljs-bullet">*</span> 能够说出XML的作用
<span class="hljs-code">    存储数据，充当配置文件！
</span>
<span class="hljs-bullet">*</span> 了解XML的组成元素
<span class="hljs-code">    文档声明、注释、元素、属性、转义字符
    &lt;!-- 注释的内容 --&gt;
    
* 能够说出有哪些XML约束技术
    dtd约束、schema约束
    
* 能够说出解析XML文档DOM方式原理
    先将xml文件加载到内存，生成一棵DOM树(Document对象，它里面包含了整个xml文件里面所有的节点)，使用Document对象获得根元素节点(唯一的一个)，通过根元素节点获得它所有的子元素节点，依次获取它的属性值和文本值。
    
* 能够使用dom4j解析XML文档
        // 获得核心解析器对象
        SAXReader saxReader = new SAXReader();
</span>
<span class="hljs-code">        // 使用核心解析器对象读取xml文件得到Document对象
        Document document = saxReader.read("day15_xml/src/books.xml");
        //System.out.println(document); // org.dom4j.tree.DefaultDocument@682a0b20 [Document: name day15_xml/src/books.xml]
</span>
<span class="hljs-code">        // 使用document对象获得根元素节点
        Element root = document.getRootElement();
        //System.out.println(root.getName()); // books
</span>
<span class="hljs-code">        // 获得根元素节点的所有子元素节点
        List&lt;Element&gt; bookEles = root.elements("book");
        
    	// 遍历
        for (Element bookEle : bookEles) {
            // 获得元素的名称
            //System.out.println(bookEle.getName()); // book book
</span>
<span class="hljs-code">            // 获得指定属性id的值
            //System.out.println(bookEle.attributeValue("id")); // 001 002
</span>
<span class="hljs-code">            // 获得指定元素的文本值
            //System.out.println(bookEle.elementText("name"));
</span>
<span class="hljs-code">            // 继续遍历获得book元素节点的子元素节点
            List&lt;Element&gt; eles = bookEle.elements();
            for (Element ele : eles) {
                // 获得当前元素节点的文本值
                System.out.println(ele.getName()+"："+ele.getText());
            }
        }    
        
* 能够使用xpath解析XML或HTML文档
        // 创建SaxReader核心解析器对象
        SAXReader saxReader = new SAXReader();
</span>
<span class="hljs-code">        // 通过核心解析器对象加载xml文件获得Document对象
        Document document = saxReader.read("src/books.xml");
</span>
<span class="hljs-code">        /*
            创建的是模块：
            单元测试路径相对的是模块
            main方法路径相对的是项目！
        */
</span>
<span class="hljs-code">        // 获得id为0002的书book
        Element book = (Element) document.selectSingleNode("//book[@id='0002']");
</span>
<span class="hljs-code">        // 获得指定元素名称的文本值
        System.out.println(book.elementText("name"));</span></code></pre></div>
<h2 id="今日学习目标">今日学习目标</h2>
<ul>
<li class="md-checkbox joplin-checkbox">
<p></p><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-44" /><label id="cb-label-md-checkbox-44" for="md-checkbox-44" class="checkbox-label-unchecked">能够说出单例设计模式的好处</label></div><p></p>
</li>
<li class="md-checkbox joplin-checkbox">
<p></p><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-45" /><label id="cb-label-md-checkbox-45" for="md-checkbox-45" class="checkbox-label-unchecked">能够说出多例模式的好处</label></div><p></p>
</li>
<li class="md-checkbox joplin-checkbox">
<p></p><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-46" /><label id="cb-label-md-checkbox-46" for="md-checkbox-46" class="checkbox-label-unchecked">能够定义枚举</label></div><p></p>
</li>
<li class="md-checkbox joplin-checkbox">
<p></p><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-47" /><label id="cb-label-md-checkbox-47" for="md-checkbox-47" class="checkbox-label-unchecked">能够使用工厂模式编写java程序</label></div><p></p>
</li>
<li class="md-checkbox joplin-checkbox">
<p></p><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-48" /><label id="cb-label-md-checkbox-48" for="md-checkbox-48" class="checkbox-label-unchecked">能够理解正则表达式的作用</label></div><p></p>
</li>
<li class="md-checkbox joplin-checkbox">
<p></p><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-49" /><label id="cb-label-md-checkbox-49" for="md-checkbox-49" class="checkbox-label-unchecked">能够使用正则表达式的字符类</label></div><p></p>
</li>
<li class="md-checkbox joplin-checkbox">
<p></p><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-50" /><label id="cb-label-md-checkbox-50" for="md-checkbox-50" class="checkbox-label-unchecked">能够使用正则表达式的逻辑运算符</label></div><p></p>
</li>
<li class="md-checkbox joplin-checkbox">
<p></p><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-51" /><label id="cb-label-md-checkbox-51" for="md-checkbox-51" class="checkbox-label-unchecked">能够使用正则表达式的预定义字符类</label></div><p></p>
</li>
<li class="md-checkbox joplin-checkbox">
<p></p><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-52" /><label id="cb-label-md-checkbox-52" for="md-checkbox-52" class="checkbox-label-unchecked">能够使用正则表达式的限定符</label></div><p></p>
</li>
<li class="md-checkbox joplin-checkbox">
<p></p><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-53" /><label id="cb-label-md-checkbox-53" for="md-checkbox-53" class="checkbox-label-unchecked">能够使用正则表达式的分组</label></div><p></p>
</li>
<li class="md-checkbox joplin-checkbox">
<p></p><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-54" /><label id="cb-label-md-checkbox-54" for="md-checkbox-54" class="checkbox-label-unchecked">能够在String的split方法中使用正则表达式</label></div><p></p>
</li>
</ul>
<h1 id="第一章-单例设计模式">第一章 单例设计模式</h1>
<p>正常情况下一个类可以创建多个对象</p>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
    <span class="hljs-comment">// 正常情况下一个类可以创建多个对象</span>
    <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();
    <span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();
    <span class="hljs-type">Person</span> <span class="hljs-variable">p3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();
}</code></pre></div>
<h2 id="11-单例设计模式的作用">1.1 单例设计模式的作用</h2>
<p>单例模式，是一种常用的软件设计模式。通过单例模式可以保证系统中，应用该模式的这个类只有一个实例。即一个类只有一个对象实例。</p>
<h2 id="12-单例设计模式实现步骤">1.2 单例设计模式实现步骤</h2>
<ol>
<li>
<p>将构造方法私有化，使其不能在类的外部通过new关键字实例化该类对象。</p>
</li>
<li>
<p>在该类内部产生一个唯一的实例化对象，并且将其封装为private static类型的成员变量。</p>
</li>
<li>
<p>定义一个静态方法返回这个唯一对象。</p>
</li>
</ol>
<h2 id="13-单例设计模式的类型">1.3 单例设计模式的类型</h2>
<p>根据实例化对象的时机单例设计模式又分为以下两种:</p>
<ol>
<li>
<p>饿汉单例设计模式</p>
</li>
<li>
<p>懒汉单例设计模式</p>
</li>
</ol>
<h2 id="14-饿汉单例设计模式">1.4 饿汉单例设计模式</h2>
<p>饿汉单例设计模式就是使用类的时候已经将对象创建完毕，不管以后会不会使用到该实例化对象，先创建了再说。很着急的样子，故被称为“饿汉模式”。</p>
<p>代码如下：</p>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> {
    <span class="hljs-comment">// 1.将构造方法私有化，使其不能在类的外部通过new关键字实例化该类对象。</span>
    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> {}

    <span class="hljs-comment">// 2.在该类内部产生一个唯一的实例化对象，并且将其封装为private static类型的成员变量。</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();
    
    <span class="hljs-comment">// 3.定义一个静态方法返回这个唯一对象。</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> instance;
    }
}</code></pre></div>
<h2 id="15-懒汉单例设计模式">1.5 懒汉单例设计模式</h2>
<p>懒汉单例设计模式就是调用getInstance()方法时实例才被创建，先不急着实例化出对象，等要用的时候才实例化出对象。不着急，故称为“懒汉模式”。</p>
<p>代码如下：</p>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> {

    <span class="hljs-comment">// 2.在该类内部产生一个唯一的实例化对象，并且将其封装为private static类型的成员变量。</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;
    
    <span class="hljs-comment">// 1.将构造方法私有化，使其不能在类的外部通过new关键字实例化该类对象。</span>
    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> {}
    
    <span class="hljs-comment">// 3.定义一个静态方法返回这个唯一对象。要用的时候才例化出对象</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>) {
            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();
        }
        <span class="hljs-keyword">return</span> instance;
    }
}</code></pre></div>
<blockquote>
<p>注意：懒汉单例设计模式在多线程环境下可能会实例化出多个对象，不能保证单例的状态，所以加上关键字：synchronized，保证其同步安全。</p>
</blockquote>
<h2 id="16-小结">1.6 小结</h2>
<p>单例模式可以保证系统中一个类只有一个对象实例。</p>
<p>实现单例模式的步骤：</p>
<ol>
<li>将构造方法私有化，使其不能在类的外部通过new关键字实例化该类对象。</li>
<li>在该类内部产生一个唯一的实例化对象，并且将其封装为private static类型的成员变量。</li>
<li>定义一个静态方法返回这个唯一对象。</li>
</ol>
<h1 id="第二章-多例设计模式">第二章 多例设计模式</h1>
<p>一般情况下一个类可以创建多个对象</p>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
    <span class="hljs-comment">// 正常情况下一个类可以创建多个对象</span>
    <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();
    <span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();
    <span class="hljs-type">Person</span> <span class="hljs-variable">p3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();
}</code></pre></div>
<h2 id="21多例设计模式的作用">2.1.多例设计模式的作用</h2>
<p>多例模式，是一种常用的软件设计模式。通过多例模式可以保证系统中，应用该模式的类有固定数量的实例。多例类要自我创建并管理自己的实例，还要向外界提供获取本类实例的方法。</p>
<h2 id="22实现步骤">2.2.实现步骤</h2>
<p>​	1.创建一个类,  将构造方法私有化，使其不能在类的外部通过new关键字实例化该类对象。</p>
<p>​	2.在类中定义该类被创建的总数量</p>
<p>​	3.在类中定义存放类实例的list集合</p>
<p>​	4.在类中提供静态代码块,在静态代码块中创建类的实例</p>
<p>​	5.提供获取类实例的静态方法</p>
<h2 id="23实现代码如下">2.3.实现代码如下:</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.List;
<span class="hljs-keyword">import</span> java.util.Random;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Multition</span> {
    <span class="hljs-comment">// 定义该类被创建的总数量</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;
    <span class="hljs-comment">// 定义存放类实例的list集合</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">List</span> <span class="hljs-variable">instanceList</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();
    <span class="hljs-comment">// 构造方法私有化,不允许外界创建本类对象</span>
    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Multition</span><span class="hljs-params">()</span> {
    }
    <span class="hljs-keyword">static</span> {
        <span class="hljs-comment">// 创建本类的多个实例,并存放到list集合中</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; maxCount; i++) {
            <span class="hljs-type">Multition</span> <span class="hljs-variable">multition</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Multition</span>();
            instanceList.add(multition);
        }
    }
    <span class="hljs-comment">// 给外界提供一个获取类对象的方法</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Multition <span class="hljs-title function_">getMultition</span><span class="hljs-params">()</span>{
        <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();
        <span class="hljs-comment">// 生成一个随机数</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> random.nextInt(maxCount);
        <span class="hljs-comment">// 从list集合中随机取出一个进行使用</span>
        <span class="hljs-keyword">return</span> (Multition)instanceList.get(i);
    }
}</code></pre></div>
<h2 id="24测试结果">2.4.测试结果:</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
    <span class="hljs-comment">// 编写一个循环从中获取类对象</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
        <span class="hljs-type">Multition</span> <span class="hljs-variable">multition</span> <span class="hljs-operator">=</span> Multition.getMultition();
        System.out.println(multition);
    }
}</code></pre></div>
<h2 id="25多例模式小结">2.5.多例模式小结:</h2>
<p>多例模式可以保证系统中一个类有固定个数的实例, 在实现需求的基础上, 能够提高实例的复用性.</p>
<p>实现多例模式的步骤：</p>
<ol>
<li>创建一个类,  将构造方法私有化，使其不能在类的外部通过new关键字实例化该类对象。</li>
<li>在类中定义该类被创建的总数量</li>
<li>在类中定义存放类实例的list集合</li>
<li>在类中提供静态代码块,在静态代码块中创建类的实例</li>
<li>提供获取类实例的静态方法</li>
</ol>
<h1 id="第三章-枚举">第三章 枚举</h1>
<h2 id="31-不使用枚举存在的问题">3.1 不使用枚举存在的问题</h2>
<p>假设我们要定义一个人类，人类中包含姓名和性别。通常会将性别定义成字符串类型，效果如下：</p>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> String sex;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> {
    }

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, String sex)</span> {
        <span class="hljs-built_in">this</span>.name = name;
        <span class="hljs-built_in">this</span>.sex = sex;
    }
    
    <span class="hljs-comment">// 省略get/set/toString方法</span>
}</code></pre></div>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">"张三"</span>, <span class="hljs-string">"男"</span>);
        <span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">"张三"</span>, <span class="hljs-string">"abc"</span>); <span class="hljs-comment">// 因为性别是字符串,所以我们可以传入任意字符串</span>
    }
}</code></pre></div>
<p>不使用枚举存在的问题：可以给性别传入任意的字符串，导致性别是非法的数据，不安全。</p>
<h2 id="32-枚举的作用与应用场景">3.2 枚举的作用与应用场景</h2>
<p>枚举的作用：一个方法接收的参数是固定范围之内的时候，那么即可使用枚举。</p>
<h2 id="33-枚举的基本语法">3.3 枚举的基本语法</h2>
<h3 id="331-枚举的概念">3.3.1 枚举的概念</h3>
<p>枚举是一种特殊类。枚举是有固定实例个数的类型，我们可以把枚举理解成有固定个数实例的多例模式。</p>
<h3 id="332-定义枚举的格式">3.3.2 定义枚举的格式</h3>
<div><pre class="hljs"><code><span class="hljs-keyword">enum</span> 枚举名 {
    第一行都是罗列枚举实例,这些枚举实例直接写大写名字即可。
}</code></pre></div>
<h3 id="333-入门案例">3.3.3 入门案例</h3>
<ol>
<li>定义枚举：BOY表示男，GIRL表示女</li>
</ol>
<div><pre class="hljs"><code><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Sex</span> {
    BOY, GIRL; <span class="hljs-comment">// 男，女</span>
}</code></pre></div>
<ol start="2">
<li>Perosn中的性别由String类型改为Sex枚举类型</li>
</ol>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> Sex sex;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> {
    }

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, Sex sex)</span> {
        <span class="hljs-built_in">this</span>.name = name;
        <span class="hljs-built_in">this</span>.sex = sex;
    }
    <span class="hljs-comment">// 省略get/set/toString方法</span>
}</code></pre></div>
<ol start="3">
<li>使用是只能传入枚举中的固定值</li>
</ol>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo02</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">"张三"</span>, Sex.BOY);
        <span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">"张三"</span>, Sex.GIRL);
        <span class="hljs-type">Person</span> <span class="hljs-variable">p3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">"张三"</span>, <span class="hljs-string">"abc"</span>);
    }
}</code></pre></div>
<h3 id="334-枚举的其他内容">3.3.4 枚举的其他内容</h3>
<p>枚举的本质是一个类，我们刚才定义的Sex枚举最终效果如下：</p>
<div><pre class="hljs"><code><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Sex</span> {
    BOY, GIRL; <span class="hljs-comment">// 男，女</span>
}

<span class="hljs-comment">// 枚举的本质是一个类，我们刚才定义的Sex枚举相当于下面的类</span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SEX</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">java</span>.lang.Enum&lt;SEX&gt; {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">SEX</span> <span class="hljs-variable">BOY</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SEX</span>();
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">SEX</span> <span class="hljs-variable">GIRL</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SEX</span>();
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SEX[] values();
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SEX <span class="hljs-title function_">valueOf</span><span class="hljs-params">(java.lang.String)</span>;
    <span class="hljs-keyword">static</span> {};
}</code></pre></div>
<p>枚举的本质是一个类，所以枚举中还可以有成员变量，成员方法等。</p>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Sex</span> {
    BOY(<span class="hljs-number">18</span>), GIRL(<span class="hljs-number">16</span>);

    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> age;

    Sex(<span class="hljs-type">int</span> age) {
        <span class="hljs-built_in">this</span>.age = age;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showAge</span><span class="hljs-params">()</span> {
        System.out.println(<span class="hljs-string">"年龄是: "</span> + age);
    }
}</code></pre></div>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo03</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">"张三"</span>, Sex.BOY);
        <span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">"张三"</span>, Sex.GIRL);

        Sex.BOY.showAge();
        Sex.GIRL.showAge();
    }
}</code></pre></div>
<p>运行效果：</p>
<div><pre class="hljs"><code>年龄是: <span class="hljs-number">18</span>
年龄是: <span class="hljs-number">16</span></code></pre></div>
<h2 id="34-应用场景">3.4 应用场景</h2>
<h2 id="35-枚举的应用">3.5 枚举的应用</h2>
<p><strong>枚举的作用：枚举通常可以用于做信息的分类，如性别，方向，季度等。</strong></p>
<p>枚举表示性别：</p>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Sex</span> {
    MAIL, FEMAIL;
}</code></pre></div>
<p>枚举表示方向：</p>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Orientation</span> {
    UP, RIGHT, DOWN, LEFT;
}</code></pre></div>
<p>枚举表示季度</p>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Season</span> {
    SPRING, SUMMER, AUTUMN, WINTER;
}</code></pre></div>
<h2 id="36-小结">3.6 小结</h2>
<ul>
<li>枚举类在第一行罗列若干个枚举对象。（多例）</li>
<li>第一行都是常量，存储的是枚举类的对象。</li>
<li>枚举是不能在外部创建对象的，枚举的构造器默认是私有的。</li>
<li>枚举通常用于做信息的标志和分类。</li>
</ul>
<h1 id="第四章-工厂设计模式">第四章 工厂设计模式</h1>
<h2 id="41工厂模式概述">4.1.工厂模式概述:</h2>
<p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。之前我们创建类对象时, 都是使用new 对象的形式创建, 除new 对象方式以外, 工厂模式也可以创建对象.</p>
<h2 id="42工厂模式作用">4.2.工厂模式作用:</h2>
<p>解决类与类之间的耦合问题</p>
<h2 id="43工厂模式实现步骤">4.3.工厂模式实现步骤:</h2>
<ol>
<li>编写一个Car接口, 提供run方法</li>
<li>编写一个Falali类实现Car接口,重写run方法</li>
<li>编写一个Benchi类实现Car接口,重写run方法</li>
<li>提供一个CarFactory(汽车工厂),用于生产汽车对象</li>
<li>定义CarFactoryTest测试汽车工厂</li>
</ol>
<h2 id="44工厂模式实现代码">4.4.工厂模式实现代码:</h2>
<p>1.编写一个Car接口, 提供run方法</p>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Car</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;
}</code></pre></div>
<p>2.编写一个Falali类实现Car接口,重写run方法</p>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Falali</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Car</span> {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> {
        System.out.println(<span class="hljs-string">"法拉利以每小时500公里的速度在奔跑....."</span>);
    }
}</code></pre></div>
<p>3.编写一个Benchi类实现Car接口</p>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Benchi</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Car</span> {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> {
        System.out.println(<span class="hljs-string">"奔驰汽车以每秒1米的速度在挪动....."</span>);
    }
}</code></pre></div>
<p>4.提供一个CarFactory(汽车工厂),用于生产汽车对象</p>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CarFactory</span> {
    <span class="hljs-comment">/**
     * <span class="hljs-doctag">@param</span> id : 车的标识
     *           benchi : 代表需要创建Benchi类对象
     *           falali : 代表需要创建Falali类对象
     *           如果传入的车标识不正确,代表当前工厂生成不了当前车对象,则返回null
     * <span class="hljs-doctag">@return</span>
     */</span>
    <span class="hljs-keyword">public</span> Car <span class="hljs-title function_">createCar</span><span class="hljs-params">(String id)</span>{
        <span class="hljs-keyword">if</span>(<span class="hljs-string">"falali"</span>.equals(id)){
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Falali</span>();
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-string">"benchi"</span>.equals(id)){
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Benchi</span>();
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
}</code></pre></div>
<p>5.定义CarFactoryTest测试汽车工厂</p>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CarFactoryTest</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">CarFactory</span> <span class="hljs-variable">carFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CarFactory</span>();
        <span class="hljs-type">Car</span> <span class="hljs-variable">benchi</span> <span class="hljs-operator">=</span> carFactory.createCar(<span class="hljs-string">"benchi"</span>);
        benchi.run();
        <span class="hljs-type">Car</span> <span class="hljs-variable">falali</span> <span class="hljs-operator">=</span> carFactory.createCar(<span class="hljs-string">"falali"</span>);
        falali.run();
    }
}</code></pre></div>
<h2 id="45工厂模式小结">4.5.工厂模式小结</h2>
<p>工厂模式的存在可以改变创建类的方式,解决类与类之间的耦合.</p>
<p>实现步骤:</p>
<ol>
<li>编写一个Car接口, 提供run方法</li>
<li>编写一个Falali类实现Car接口,重写run方法</li>
<li>编写一个Benchi类实现Car接口,重写run方法</li>
<li>提供一个CarFactory(汽车工厂),用于生产汽车对象</li>
<li>定义CarFactoryTest测试汽车工厂</li>
</ol>
<h1 id="第五章-正则表达式">第五章 正则表达式</h1>
<h2 id="51-正则表达式的概念及演示">5.1 正则表达式的概念及演示</h2>
<ul>
<li>在Java中，我们经常需要验证一些字符串，例如：年龄必须是2位的数字、用户名必须是8位长度而且只能包含大小写字母、数字等。正则表达式就是用来验证各种字符串的规则。它内部描述了一些规则，我们可以验证用户输入的字符串是否匹配这个规则。</li>
<li>先看一个不使用正则表达式验证的例子：下面的程序让用户输入一个QQ号码，我们要验证：
<ul>
<li>QQ号码必须是5–15位长度</li>
<li>而且必须全部是数字</li>
<li>而且首位不能为0</li>
</ul>
</li>
</ul>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);
        
        System.out.println(<span class="hljs-string">"请输入你的QQ号码："</span>);
        <span class="hljs-type">String</span> <span class="hljs-variable">qq</span> <span class="hljs-operator">=</span> sc.next();
        
        System.out.println(checkQQ(qq));
    }
    <span class="hljs-comment">//我们自己编写代码，验证QQ号码</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkQQ</span><span class="hljs-params">(String qq)</span> {
        <span class="hljs-comment">//1.验证5--15位</span>
        <span class="hljs-keyword">if</span>(qq.length() &lt; <span class="hljs-number">5</span> || qq.length() &gt; <span class="hljs-number">15</span>){
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        <span class="hljs-comment">//2.必须都是数字；</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; qq.length() ; i++){
            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> qq.charAt(i);
            <span class="hljs-keyword">if</span>(c &lt; <span class="hljs-string">'0'</span> || c &gt; <span class="hljs-string">'9'</span>){
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
        }
        <span class="hljs-comment">//3.首位不能是0；</span>
        <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> qq.charAt(<span class="hljs-number">0</span>);
        <span class="hljs-keyword">if</span>(c == <span class="hljs-string">'0'</span>){
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//验证通过</span>
    }
    
}</code></pre></div>
<ul>
<li>使用正则表达式验证：</li>
</ul>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);
        
        System.out.println(<span class="hljs-string">"请输入你的QQ号码："</span>);
        <span class="hljs-type">String</span> <span class="hljs-variable">qq</span> <span class="hljs-operator">=</span> sc.next();
        
        System.out.println(checkQQ2(qq));
    }
    
    <span class="hljs-comment">//使用正则表达式验证</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkQQ2</span><span class="hljs-params">(String qq)</span>{
        <span class="hljs-type">String</span> <span class="hljs-variable">regex</span> <span class="hljs-operator">=</span> <span class="hljs-string">"[1-9]\\d{4,14}"</span>;<span class="hljs-comment">//正则表达式</span>
        <span class="hljs-keyword">return</span> qq.matches(regex);
    }
    
}</code></pre></div>
<p>上面程序checkQQ2()方法中String类型的变量regex就存储了一个"正则表达式 "，而这个正则表达式就描述了我们需要的三个规则。matches()方法是String类的一个方法，用于接收一个正则表达式，并将"本对象"与参数"正则表达式"进行匹配，如果本对象符合正则表达式的规则，则返回true，否则返回false。</p>
<p><strong>我们接下来就重点学习怎样写正则表达式</strong></p>
<h2 id="52-正则表达式-字符类">5.2 正则表达式-字符类</h2>
<ul>
<li>
<p>语法示例：</p>
<ol>
<li>[abc]：代表a或者b，或者c字符中的一个。</li>
<li>[^abc]：代表除a,b,c以外的任何字符。</li>
<li>[a-z]：代表a-z的所有小写字符中的一个。</li>
<li>[A-Z]：代表A-Z的所有大写字符中的一个。</li>
<li>[0-9]：代表0-9之间的某一个数字字符。</li>
<li>[a-zA-Z0-9]：代表a-z或者A-Z或者0-9之间的任意一个字符。</li>
<li>[a-dm-p]：a 到 d 或 m 到 p之间的任意一个字符。</li>
</ol>
</li>
<li>
<p>代码示例：</p>
</li>
</ul>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">"ead"</span>;
        
        <span class="hljs-comment">//1.验证str是否以h开头，以d结尾，中间是a,e,i,o,u中某个字符</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">regex</span> <span class="hljs-operator">=</span> <span class="hljs-string">"h[aeiou]d"</span>;
        System.out.println(<span class="hljs-string">"1."</span> + str.matches(regex));
        
        <span class="hljs-comment">//2.验证str是否以h开头，以d结尾，中间不是a,e,i,o,u中的某个字符</span>
        regex = <span class="hljs-string">"h[^aeiou]d"</span>;
        System.out.println(<span class="hljs-string">"2."</span> +  str.matches(regex));
        
        <span class="hljs-comment">//3.验证str是否a-z的任何一个小写字符开头，后跟ad</span>
        regex = <span class="hljs-string">"[a-z]ad"</span>;
        System.out.println(<span class="hljs-string">"3."</span> + str.matches(regex));
        
        <span class="hljs-comment">//4.验证str是否以a-d或者m-p之间某个字符开头，后跟ad</span>
        regex = <span class="hljs-string">"[[a-d][m-p]]ad"</span>;
        System.out.println(<span class="hljs-string">"4."</span> + str.matches(regex));
    }
}
</code></pre></div>
<h2 id="53-正则表达式-逻辑运算符">5.3 正则表达式-逻辑运算符</h2>
<ul>
<li>
<p>语法示例：</p>
<ol>
<li>&amp;&amp;：并且</li>
<li>|    ：或者</li>
</ol>
</li>
<li>
<p>代码示例：</p>
</li>
</ul>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">"had"</span>;
        
        <span class="hljs-comment">//1.要求字符串是否是除a、e、i、o、u外的其它小写字符开头，后跟ad</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">regex</span> <span class="hljs-operator">=</span> <span class="hljs-string">"[a-z&amp;&amp;[^aeiou]]ad"</span>;
        System.out.println(<span class="hljs-string">"1."</span> + str.matches(regex));
        
        <span class="hljs-comment">//2.要求字符串是aeiou中的某个字符开头，后跟ad</span>
        regex = <span class="hljs-string">"[a|e|i|o|u]ad"</span>;<span class="hljs-comment">//这种写法相当于：regex = "[aeiou]ad";</span>
        System.out.println(<span class="hljs-string">"2."</span> + str.matches(regex));
    }
}
</code></pre></div>
<h2 id="54-正则表达式-预定义字符">5.4 正则表达式-预定义字符</h2>
<ul>
<li>
<p>语法示例：</p>
<ol>
<li>“.” ： 匹配任何字符。</li>
<li>“\d”：任何数字[0-9]的简写；</li>
<li>“\D”：任何非数字[^0-9]的简写；</li>
<li>“\s”： 空白字符：[ \t\n\x0B\f\r] 的简写</li>
<li>“\S”： 非空白字符：[^\s] 的简写</li>
<li>“\w”：单词字符：[a-zA-Z_0-9]的简写</li>
<li>“\W”：非单词字符：[^\w]</li>
</ol>
</li>
<li>
<p>代码示例：</p>
</li>
</ul>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">"258"</span>;
        
        <span class="hljs-comment">//1.验证str是否3位数字</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">regex</span> <span class="hljs-operator">=</span> <span class="hljs-string">"\\d\\d\\d"</span>;
        System.out.println(<span class="hljs-string">"1."</span> + str.matches(regex));
        
        <span class="hljs-comment">//2.验证手机号：1开头，第二位：3/5/8，剩下9位都是0-9的数字</span>
        str = <span class="hljs-string">"13513153355"</span>;<span class="hljs-comment">//要验证的字符串</span>
        regex = <span class="hljs-string">"1[358]\\d\\d\\d\\d\\d\\d\\d\\d\\d"</span>;<span class="hljs-comment">//正则表达式</span>
        System.out.println(<span class="hljs-string">"2."</span> + str.matches(regex));
        
        <span class="hljs-comment">//3.验证字符串是否以h开头，以d结尾，中间是任何字符</span>
        str = <span class="hljs-string">"had"</span>;<span class="hljs-comment">//要验证的字符串</span>
        regex = <span class="hljs-string">"h.d"</span>;<span class="hljs-comment">//正则表达式</span>
        System.out.println(<span class="hljs-string">"3."</span> + str.matches(regex));
        
        <span class="hljs-comment">//4.验证str是否是：had.</span>
        str = <span class="hljs-string">"had."</span>;<span class="hljs-comment">//要验证的字符串</span>
        regex = <span class="hljs-string">"had\\."</span>;<span class="hljs-comment">//\\.代表'.'符号，因为.在正则中被预定义为"任意字符"，不能直接使用</span>
        System.out.println(<span class="hljs-string">"4."</span> + str.matches(regex));
        
    }
}</code></pre></div>
<h2 id="55-正则表达式-数量词">5.5 正则表达式-数量词</h2>
<ul>
<li>
<p>语法示例：</p>
<ol>
<li>X? : 0次或1次</li>
<li>X* : 0次到多次</li>
<li>X+ : 1次或多次</li>
<li>X{n} : 恰好n次</li>
<li>X{n,} : 至少n次</li>
<li>X{n,m}: n到m次(n和m都是包含的)</li>
</ol>
</li>
<li>
<p>代码示例：</p>
</li>
</ul>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">""</span>;
        
        <span class="hljs-comment">//1.验证str是否是三位数字</span>
        str = <span class="hljs-string">"012"</span>;
        <span class="hljs-type">String</span> <span class="hljs-variable">regex</span> <span class="hljs-operator">=</span> <span class="hljs-string">"\\d{3}"</span>;
        System.out.println(<span class="hljs-string">"1."</span> + str.matches(regex));
        
        <span class="hljs-comment">//2.验证str是否是多位数字</span>
        str = <span class="hljs-string">"88932054782342"</span>;
        regex = <span class="hljs-string">"\\d+"</span>;
        System.out.println(<span class="hljs-string">"2."</span> + str.matches(regex));
        
        <span class="hljs-comment">//3.验证str是否是手机号：</span>
        str = <span class="hljs-string">"13813183388"</span>;
        regex = <span class="hljs-string">"1[358]\\d{9}"</span>;
        System.out.println(<span class="hljs-string">"3."</span> + str.matches(regex));
        
        <span class="hljs-comment">//4.验证小数:必须出现小数点，但是只能出现1次</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">"3.1"</span>;
        regex = <span class="hljs-string">"\\d*\\.{1}\\d+"</span>;
        System.out.println(<span class="hljs-string">"4."</span> + s2.matches(regex));
        
        <span class="hljs-comment">//5.验证小数：小数点可以不出现，也可以出现1次</span>
        regex = <span class="hljs-string">"\\d+\\.?\\d+"</span>;
        System.out.println(<span class="hljs-string">"5."</span> + s2.matches(regex));
        
        <span class="hljs-comment">//6.验证小数：要求匹配：3、3.、3.14、+3.14、-3.</span>
        s2 = <span class="hljs-string">"-3."</span>;
        regex = <span class="hljs-string">"[+-]\\d+\\.?\\d*"</span>;
        System.out.println(<span class="hljs-string">"6."</span> + s2.matches(regex));
        
        <span class="hljs-comment">//7.验证qq号码：1).5--15位；2).全部是数字;3).第一位不是0</span>
        s2 = <span class="hljs-string">"1695827736"</span>;
        regex = <span class="hljs-string">"[1-9]\\d{4,14}"</span>;
        System.out.println(<span class="hljs-string">"7."</span> + s2.matches(regex));
    }
}
</code></pre></div>
<h2 id="56-正则表达式-分组括号">5.6 正则表达式-分组括号( )</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">"DG8FV-B9TKY-FRT9J-99899-XPQ4G"</span>;
        
        <span class="hljs-comment">//验证这个序列号：分为5组，每组之间使用-隔开，每组由5位A-Z或者0-9的字符组成</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">regex</span> <span class="hljs-operator">=</span> <span class="hljs-string">"([A-Z0-9]{5}-){4}[A-Z0-9]{5}"</span>;
        System.out.println(str.matches(regex));
    }
}
</code></pre></div>
<h2 id="57-string的split方法中使用正则表达式">5.7 String的split方法中使用正则表达式</h2>
<ul>
<li>
<p>String类的split()方法原型：</p>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> String[] split(String regex)<span class="hljs-comment">//参数regex就是一个正则表达式。可以将当前字符串中匹配regex正则表达式的符号作为"分隔符"来切割字符串。</span></code></pre></div>
</li>
<li>
<p>代码示例：</p>
</li>
</ul>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">"18  4 567       99     56"</span>;
        String[] strArray = str.split(<span class="hljs-string">" +"</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; strArray.length; i++) {
            System.out.println(strArray[i]);
        }
    }
}
</code></pre></div>
<h2 id="58-string类的replaceall方法中使用正则表达式">5.8 String类的replaceAll方法中使用正则表达式</h2>
<ul>
<li>String类的replaceAll()方法原型：</li>
</ul>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> String <span class="hljs-title function_">replaceAll</span><span class="hljs-params">(String regex,String newStr)</span><span class="hljs-comment">//参数regex就是一个正则表达式。可以将当前字符串中匹配regex正则表达式的字符串替换为newStr。</span></code></pre></div>
<ul>
<li>代码示例：</li>
</ul>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">//将下面字符串中的"数字"替换为"*"</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">"jfdk432jfdk2jk24354j47jk5l31324"</span>;
        System.out.println(str.replaceAll(<span class="hljs-string">"\\d+"</span>, <span class="hljs-string">"*"</span>));
    }
}</code></pre></div>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[day07-异常&线程安全]]></title>
            <guid>ee82dd4907f44a85bec4be25a0d301fa</guid>
            <pubDate>Tue, 06 Apr 2021 00:48:53 GMT</pubDate>
            <content:encoded><![CDATA[<nav class="table-of-contents"><ul><li><a href="#day07-异常线程安全">day07-异常&amp;线程安全</a></li><li><a href="#一-异常">一 异常</a><ul><li><a href="#1什么是异常">1).什么是异常:</a></li><li><a href="#2异常处理">2)异常处理:</a></li><li><a href="#3java遇到的异常情况">3)java遇到的异常情况:</a></li><li><a href="#4java中遗产类的系统结构">4)java中遗产类的系统结构:</a></li><li><a href="#5-异常处理的基本语句">5) 异常处理的基本语句:</a></li><li><a href="#6多catch情况多种异常同时">6)多catch情况(多种异常同时)</a></li><li><a href="#7finally语句">7)finally语句</a></li><li><a href="#8-trycatchfinally的几种组合情况">8) try…catch…finally的几种组合情况</a></li><li><a href="#9-方法中处理异常的方式">9) 方法中处理异常的方式</a></li><li><a href="#10操作异常对象">10)操作异常对象</a></li></ul></li></ul></nav><h1 id="day07-异常线程安全">day07-异常&amp;线程安全</h1>
<hr />
<h1 id="一-异常">一 异常</h1>
<h2 id="1什么是异常">1).什么是异常:</h2>
<p>异常指的是程序除了某些问题</p>
<h2 id="2异常处理">2)异常处理:</h2>
<p>一种语法,可以让程序,在出现“异常情况”是,能够跳过错误代码继续执行下去</p>
<h2 id="3java遇到的异常情况">3)java遇到的异常情况:</h2>
<blockquote>
<p>​ ①JVM执行到有异常的代码;</p>
<p>​ ②JVM能够识别出这种异常情况</p>
<p>​ ③JVM到类库中找到这种异常情况</p>
<p>​ ④JVM到代码中查看我们代码是否希望“捕获(catch)”,这种异常</p>
<p>​ 是:将异常打印到控制台,结束掉程序</p>
<p>​ 否:将这个异常对象传给catch,并且执行catch中的代码,我们的程序会继续运行下去.</p>
</blockquote>
<h2 id="4java中遗产类的系统结构">4)java中遗产类的系统结构:</h2>
<p>​ ①Throwable(类):所有异常的父类</p>
<blockquote>
<p>​ |–Error(错误):程序遇到不能被捕获的错误,，程序必须死掉，也不希望被捕获如内存溢出</p>
<p>​ |–Exception(异常),程序遇到的异常情况，我们程序需要捕获，捕获后，程序就可以继续运行下去。</p>
<p>​ |–RuntimeException（运行时异常）：一些比较轻的异常情况，通常通过一些判断手段，</p>
<p>​ |–除RuntimException</p>
</blockquote>
<h2 id="5-异常处理的基本语句">5) 异常处理的基本语句:</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">try</span>{
    ...<span class="hljs-comment">//可能出现的异常代码</span>
}<span class="hljs-keyword">case</span>(异常类名 变量名){<span class="hljs-comment">//Exception e(通用)不建议</span>
 	...<span class="hljs-comment">//如果try中出现了于"异常类名   </span>
}</code></pre></div>
<h2 id="6多catch情况多种异常同时">6)多catch情况(多种异常同时)</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">try</span>(){
    ...
}<span class="hljs-keyword">catch</span>{(异常类名 变量名)
    
}<span class="hljs-keyword">catch</span>{(异常类名 变量名)
    
}<span class="hljs-keyword">catch</span>{(异常类名 变量名)
    
}
注意:通常多个<span class="hljs-keyword">catch</span>的异常类型是<span class="hljs-string">"同级的"</span>,也可以是<span class="hljs-string">"子父级"</span>的,但<span class="hljs-string">"父级的异常"</span>放在最后面</code></pre></div>
<h2 id="7finally语句">7)finally语句</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">try</span>(){
    ...
}<span class="hljs-keyword">catch</span>{(异常类名 变量名)
    
}<span class="hljs-keyword">catch</span>{(异常类名 变量名)
    
}<span class="hljs-keyword">finally</span>{(异常类名 变量名)
    <span class="hljs-comment">//无论是否出现异常,都会执行finally中的语句</span>
    <span class="hljs-comment">//尤其是在try/catch中有return 语句的情况下:当try中或catch中，都要执行的语句可以写在finally中</span>
}</code></pre></div>
<h2 id="8-trycatchfinally的几种组合情况">8) try…catch…finally的几种组合情况</h2>
<p>​</p>
<div><pre class="hljs"><code>① 
    <span class="hljs-keyword">try</span>…<span class="hljs-keyword">catch</span>…

②
    <span class="hljs-keyword">try</span>…<span class="hljs-keyword">catch</span> … <span class="hljs-keyword">catch</span>…

③
    <span class="hljs-keyword">try</span>…<span class="hljs-keyword">catch</span>…<span class="hljs-keyword">finally</span>

④
    <span class="hljs-keyword">try</span>…<span class="hljs-keyword">catch</span>…<span class="hljs-keyword">catch</span>…<span class="hljs-keyword">finally</span>

⑤
    rty…<span class="hljs-keyword">finally</span>…</code></pre></div>
<h2 id="9-方法中处理异常的方式">9) 方法中处理异常的方式</h2>
<blockquote>
<p>​ ①在一个方法中(除main()方法),可以使用try…catch处理异常,建议将异常“抛出”,抛出给调用的代码</p>
<p>​ ②抛出异常的第一种方式:throws 声明抛出</p>
<p>​ ③方法抛出异常</p>
<p>​ ④throws和throw的区别:</p>
</blockquote>
<p>​ 1):throws:</p>
<blockquote>
<p>​ (1)用在方法的“声明处”</p>
<p>​ (2)throws后面跟“异常类名”,可以有多个</p>
</blockquote>
<p>​ 2)throw:</p>
<blockquote>
<p>​ (1)用在方法的“内部”，真正的抛出一个异常对象，通常是基于判断后</p>
<p>​ (2)throe后面跟的是“异常对象”,而且只能有一个:</p>
</blockquote>
<h2 id="10操作异常对象">10)操作异常对象</h2>
<blockquote>
<p>​ ①getMessage():获取异常信息;</p>
<p>​ ②toString():获取异常类名;</p>
<p>​ ③printStackTrace():打印异常详细信息</p>
</blockquote>
<p>​</p>
]]></content:encoded>
        </item>
    </channel>
</rss>