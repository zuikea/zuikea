<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta http-equiv="X-UA-Compatible" content="ie=edge" />
<link rel="stylesheet" href="/_assets/main.css" />

    <title>day7-选择排序、二分法、异常 - zblog</title>
  <link rel="stylesheet" href="/_markdown_plugin_assets/highlight.js/atom-one-light.css" /></head>
  <body>
    <div class="main">
      <nav class="navigation">
        <a href="/">zblog</a>
      </nav>
      <article>
        <header>
          <h1 class="article-title">day7-选择排序、二分法、异常</h1>
          <div class="article-info">
            <div>
              <span
                >Created At：<time datetime="1617670133874"
                  >2021-04-06 08:48</time
                ></span
              >
              <span
                >Updated At：<time datetime="1638180113795"
                  >2021-11-29 18:01</time
                ></span
              >
            </div>
            
          </div>
        </header>
        <div class="article-content markdown-body"><nav class="table-of-contents"><ul><li><a href="#学习目标">学习目标</a></li><li><a href="#第一章-选择排序重点">第一章 选择排序(重点)</a><ul><li><a href="#1原理">1.原理</a></li><li><a href="#2代码实现">2.代码实现</a></li></ul></li><li><a href="#第二章-二分折半查找重点">第二章  二分(折半)查找(重点)</a><ul><li><a href="#1原理-1">1.原理</a></li><li><a href="#2代码实现-1">2.代码实现</a></li></ul></li><li><a href="#第三章-异常">第三章 异常</a><ul><li><a href="#1异常的概念">1.异常的概念</a></li><li><a href="#2异常的体系重点">2.异常的体系(重点)</a></li><li><a href="#3异常的产生过程解析面试">3.异常的产生过程解析(面试)</a></li><li><a href="#4throw关键字重点">4.throw关键字(重点)</a></li><li><a href="#5throws关键字重点">5.throws关键字(重点)</a></li><li><a href="#6throws抛出子父类异常的处理重点">6.throws抛出子父类异常的处理(重点)</a></li><li><a href="#7trycatch关键字重点">7.try…catch关键字(重点)</a></li><li><a href="#8objects类中requirenonnull方法了解">8.Objects类中requireNonNull方法(了解)</a></li><li><a href="#9throwable类中定义的异常处理逻辑了解">9.Throwable类中定义的异常处理逻辑(了解)</a></li><li><a href="#10finally关键字重点">10.finally关键字(重点)</a></li><li><a href="#11异常处理的注意事项了解">11.异常处理的注意事项(了解)</a><ul><li><a href="#1运行时期异常">1).运行时(期)异常</a></li><li><a href="#2子父类异常的处理">2).子父类异常的处理</a></li><li><a href="#3多个异常使用捕获又该如何处理">3).多个异常使用捕获又该如何处理</a></li></ul></li><li><a href="#12自定义异常使用">12.自定义异常(使用)</a><ul><li><a href="#1概述和基本定义格式">1).概述和基本定义格式</a></li><li><a href="#2自定义异常的使用">2).自定义异常的使用</a><ul><li><a href="#a自定义异常类是编译异常必须处理">a.自定义异常类是编译异常:必须处理</a></li><li><a href="#b自定义异常是运行期异常不用处理">b.自定义异常是运行期异常:不用处理</a></li></ul></li></ul></li><li><a href="#异常总结重点中的重点">异常总结(重点中的重点):</a></li></ul></li></ul></nav><h1 id="学习目标">学习目标</h1>
<div><pre class="hljs"><code>能够理解选择排序的执行原理
    选择排序:使用数组中的元素依次和其他的元素比较,把小的值往前放
能够理解二分查找的执行原理
    使用公式:mid = (min+max)/<span class="hljs-number">2</span>;
    使用被查找的元素和中间索引指向的元素比较,循环执行的条件 min&lt;=max
    <span class="hljs-number">1.</span>被查找的元素&gt;中间指针执向的元素 min = mid+<span class="hljs-number">1</span>;
    <span class="hljs-number">2.</span>被查找的元素&lt;中间指针执向的元素 max = mid-<span class="hljs-number">1</span>;
    <span class="hljs-number">3.</span>被查找的元素==中间指针执向的元素 找到了,返回mid
能够辨别程序中异常和错误的区别
    错误:严重的问题,必须修改代码才能解决
    异常:可以解决的问题,使用<span class="hljs-keyword">try</span>...<span class="hljs-keyword">catch</span>解决异常之后,程序可以继续执行
说出异常的分类
    编译期异常==&gt;Exception:写代码的时候会报的异常
    运行期(时)异常==&gt;RuntimeException:运行代码的时候报的异常
列举出常见的三个运行期异常
    ClassCastException:类型转换异常(向下转型)
    NullPointerException:空指针异常
    IndexOutOfBoundsException:索引越界异常(集合会抛出)
    ArrayIndexOutOfBoundsException:数组索引越界异常
    StringIndexOutOfBoundsException:字符串索引越界异常
能够使用<span class="hljs-keyword">try</span>...<span class="hljs-keyword">catch</span>关键字处理异常(重点)  ctrl+alt+t
    <span class="hljs-keyword">try</span>{
        可能产生异常的代码
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">xxxException</span>(<span class="hljs-string">"异常的信息"</span>);
        ...
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">yyyException</span>(<span class="hljs-string">"异常的信息"</span>);
    }<span class="hljs-keyword">catch</span>(xxxException e){ 
        异常的处理逻辑
    }
    ...
    <span class="hljs-keyword">catch</span>(yyyException e){
        异常的处理逻辑
    }
能够使用<span class="hljs-keyword">throws</span>关键字处理异常(重点) alt+回车
    修饰符 返回值类型 方法名(参数) <span class="hljs-keyword">throws</span> xxxException,...,yyyException{
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">xxxException</span>(<span class="hljs-string">"异常的信息"</span>);
        ...
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">yyyException</span>(<span class="hljs-string">"异常的信息"</span>);
    }
能够自定义并使用异常类
    <span class="hljs-number">1.</span>自定义异常的类名,一般都是以Exception结尾,说明这个类是一个异常相关的类(见名知意)
    <span class="hljs-number">2.</span>自定义异常
        a.必须继承Exception:自定义的异常就是一个编译期异常
            使用:如果在方法内部抛出了编译期异常,那么我们就必须处理这个异常
                <span class="hljs-number">1.</span>使用<span class="hljs-keyword">throws</span>声明抛出异常,最终抛出给方法的调用者处理
                <span class="hljs-number">2.</span>使用<span class="hljs-keyword">try</span>...<span class="hljs-keyword">catch</span>自己捕获处理异常
        b.必须继承RuntimeException:z自定义的异常就是一个运行期异常
            使用:如果在方法内部抛出了运行期异常,我们无需处理,默认交给JVM处理(中断处理)</code></pre></div>
<h1 id="第一章-选择排序重点">第一章 选择排序(重点)</h1>
<h2 id="1原理">1.原理</h2>
<p><img src="/_resources/a327c4c658da40f9970b6eefca3e714d.png" /></p>
<h2 id="2代码实现">2.代码实现</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo01sort;

<span class="hljs-keyword">import</span> java.util.Arrays;

<span class="hljs-comment">/*
    选择排序:使用中的元素依次和其他的元素进行比较,每次选出最小的值,把小的值往前放
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01SelectSort</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">//定义一个数组</span>
        <span class="hljs-type">int</span>[] arr = {<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">3</span>};
        System.out.println(<span class="hljs-string">"排序前数组中的元素:"</span>+ Arrays.toString(arr));
        <span class="hljs-comment">/*
            选择排序
                1.定义一个循环嵌套
                    外层循环:控制比较的次数 arr.length-1
                    内层循环:控制每次比较几对元素 int j = 1+i
                2.在循环中依次比较arr[i]和arr[j]的值,每次选出最小的
                    在if语句中使用第三方变量交互两个元素的位置
         */</span>
        <span class="hljs-comment">//1.定义一个循环嵌套</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>+i; j &lt; arr.length; j++) {
                <span class="hljs-comment">//2.在循环中依次比较arr[i]和arr[j]的值,每次选出最小的</span>
                <span class="hljs-keyword">if</span>(arr[i]&gt;arr[j]){
                    <span class="hljs-comment">//在if语句中使用第三方变量交互两个元素的位置</span>
                    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];
                    arr[i] = arr[j];
                    arr[j] = temp;
                }
            }
            System.out.println(<span class="hljs-string">"每次排序的结果:"</span>+ Arrays.toString(arr));
        }
        System.out.println(<span class="hljs-string">"排序后数组中的元素:"</span>+ Arrays.toString(arr));
    }
}</code></pre></div>
<div><pre class="hljs"><code>排序前数组中的元素:<span class="hljs-string">[5, 1, 8, 3]</span>
每次排序的结果:<span class="hljs-string">[1, 5, 8, 3]</span>
每次排序的结果:<span class="hljs-string">[1, 3, 8, 5]</span>
每次排序的结果:<span class="hljs-string">[1, 3, 5, 8]</span>
排序后数组中的元素:<span class="hljs-string">[1, 3, 5, 8]</span></code></pre></div>
<h1 id="第二章-二分折半查找重点">第二章  二分(折半)查找(重点)</h1>
<h2 id="1原理-2">1.原理</h2>
<p><img src="/_resources/f58d638a7c634ff19c75104d3cd59fbe.png" /></p>
<h2 id="2代码实现-2">2.代码实现</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo02search;

<span class="hljs-comment">/*
    二分(折半)查找
    前提:
        数组|集合中的元素必须是有序的(升序)
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01BinarySearch</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">int</span>[] arr = {-<span class="hljs-number">10</span>,<span class="hljs-number">0</span>,<span class="hljs-number">11</span>,<span class="hljs-number">30</span>,<span class="hljs-number">66</span>,<span class="hljs-number">88</span>};
        <span class="hljs-type">int</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> binarySearch(arr, <span class="hljs-number">66</span>);
        System.out.println(<span class="hljs-string">"i1:"</span>+i1);<span class="hljs-comment">//i1:4</span>

        <span class="hljs-type">int</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> binarySearch(arr, <span class="hljs-number">100</span>);
        System.out.println(<span class="hljs-string">"i2:"</span>+i2);<span class="hljs-comment">//i2:-1</span>

        <span class="hljs-type">int</span> <span class="hljs-variable">i3</span> <span class="hljs-operator">=</span> binarySearch(arr, -<span class="hljs-number">10</span>);
        System.out.println(<span class="hljs-string">"i3:"</span>+i3);<span class="hljs-comment">//i3:0</span>
    }

    <span class="hljs-comment">/*
        定义一个实现二分查找法的一个方法
        1.方法的参数传递要查找的数组和被查找的数组
        2.定义3个指针(min,mid,max)
        3.遍历数组,使用被查找的数和中间指针指向的元素比较,循环执行的条件(min&lt;=max)
            被查找的元素&gt;中间指针指向的元素 min = mid+1;
            被查找的元素&lt;中间指针指向的元素 max = mid-1;
            被查找的元素==中间指针指向的元素 找到了,返回mid
        4.循环结束了,还没有找到,返回-1
     */</span>
    <span class="hljs-comment">//1.方法的参数传递要查找的数组和被查找的数组</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr,<span class="hljs-type">int</span> number)</span>{
        <span class="hljs-comment">//2.定义3个指针(min,mid,max)</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//指向最小的元素</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> arr.length-<span class="hljs-number">1</span>;<span class="hljs-comment">//指向最大的元素</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
        <span class="hljs-comment">//3.遍历数组,使用被查找的数和中间指针指向的元素比较,循环执行的条件(min&lt;=max)</span>
        <span class="hljs-keyword">while</span> (min&lt;=max){
            <span class="hljs-comment">//使用折半公式,计算mid的</span>
            mid = (min+max)/<span class="hljs-number">2</span>;
            <span class="hljs-keyword">if</span>(number&gt;arr[mid]){
                <span class="hljs-comment">//被查找的元素&gt;中间指针指向的元素 min = mid+1;</span>
                min = mid+<span class="hljs-number">1</span>;
            }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(number&lt;arr[mid]){
                <span class="hljs-comment">//被查找的元素&lt;中间指针指向的元素 max = mid-1;</span>
                max = mid-<span class="hljs-number">1</span>;
            }<span class="hljs-keyword">else</span>{
                <span class="hljs-comment">//被查找的元素==中间指针指向的元素 找到了,返回mid</span>
                <span class="hljs-keyword">return</span> mid;
            }
        }
        <span class="hljs-comment">//4.循环结束了,还没有找到,返回-1</span>
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }
}</code></pre></div>
<h1 id="第三章-异常">第三章 异常</h1>
<h2 id="1异常的概念">1.异常的概念</h2>
<p><strong>异常</strong> ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。</p>
<p><strong>在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对</strong></p>
<p><strong>象。Java处理异常的方式是中断处理(停止java虚拟机JVM)。</strong></p>
<h2 id="2异常的体系重点">2.异常的体系(重点)</h2>
<p><img src="/_resources/375bb933dc3a4dd287cd2c3c2a4facbe.png" /></p>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo03Exception;

<span class="hljs-keyword">import</span> java.text.ParseException;
<span class="hljs-keyword">import</span> java.text.SimpleDateFormat;
<span class="hljs-keyword">import</span> java.util.Date;

<span class="hljs-comment">/*
    异常和错误的区别(了解)
    java.lang.Throwable:是异常和错误的父类
        1.java.lang.Exception extends Throwable:异常(编译期异常),小问题,可以解决的,解决了异常之后,程序可以继续执行
            java.lang.RuntimeException extends Exception:运行期异常,程序运行期间出现的异常
        2.java.lang.Error extends Throwable:错误,严重的问题,不能解决
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01Exception</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">//编译期异常:写代码的时候(编译期,把.java文件编译生成.class文件),报的异常</span>
        <span class="hljs-comment">/*try {
            SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
            Date date = sdf.parse("2021-1129");
            System.out.println(date);
        } catch (ParseException e) {
            e.printStackTrace();
        }*/</span>

        <span class="hljs-comment">//运行期异常,程序运行期间出现的异常</span>
        <span class="hljs-comment">/*try {
            int[] arr = {10,20,30};
            System.out.println(arr[3]);
        } catch (Exception e) {
            e.printStackTrace();
        }*/</span>

        <span class="hljs-comment">/*
            错误,严重的问题,不能解决
            OutOfMemoryError: Java heap space 内存溢出的错误
            创建的数组太大了,超出了内存使用范围,(内存中装不下了),就会报内存溢出的错误
            必须的修改源码码,不让错误出现
         */</span>
        <span class="hljs-comment">//int[] arr = new int[1024*1000*1000];</span>
        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">1000</span>];

        System.out.println(<span class="hljs-string">"后续代码"</span>);
        System.out.println(<span class="hljs-string">"后续代码"</span>);
        System.out.println(<span class="hljs-string">"后续代码"</span>);
        System.out.println(<span class="hljs-string">"后续代码"</span>);
        System.out.println(<span class="hljs-string">"后续代码"</span>);
        System.out.println(<span class="hljs-string">"后续代码"</span>);
    }
}</code></pre></div>
<h2 id="3异常的产生过程解析面试">3.异常的产生过程解析(面试)</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo03Exception;

<span class="hljs-comment">/*
    异常的产生过程解析
    分析异常是如何产生的,产生异常之后,JVM是如何处理异常的
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo02Exception</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">int</span>[] arr = {<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>};
        <span class="hljs-type">int</span> <span class="hljs-variable">ele</span> <span class="hljs-operator">=</span> getElement(arr, <span class="hljs-number">3</span>);
        System.out.println(ele);
    }

    <span class="hljs-comment">/*
        定义一个方法,获取数组指定索引处的元素返回
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr,<span class="hljs-type">int</span> index)</span>{
        <span class="hljs-type">int</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> arr[index];
        <span class="hljs-keyword">return</span> e;
    }
}
</code></pre></div>
<p><img src="/_resources/7b91f90e00d94bd0bdc39a58d707a72c.png" /></p>
<h2 id="4throw关键字重点">4.throw关键字(重点)</h2>
<p>throw:抛</p>
<p><strong>作用:可以在方法中抛出指定的异常对象</strong></p>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo03Exception;

<span class="hljs-comment">/*
    throw关键字(重点)
    作用:可以在方法中抛出指定的异常对象
    格式:
        修饰符 返回值类型 方法名(参数列表){
            throw new Exception("异常信息");
            throw new RuntimeException("异常信息");
            throw new xxxxException("异常信息");
        }
    注意:
        1.throw关键字必须写在方法中使用
        2.throw关键字后边创建的异常对象,必须使用Exception或者RuntimeException的子类对象,不能使用(Person,Student...)
        3.在方法中使用throw关键字抛出了编译异常,我们就必须处理这个编译异常
          在方法中使用throw关键字抛出了运行期异常,我们可以不用处理这个异常,最终交给JVM处理(中断)
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo03throw</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">//int[] arr = {10,20,30};</span>
        <span class="hljs-type">int</span>[] arr = <span class="hljs-literal">null</span>;
        <span class="hljs-type">int</span> <span class="hljs-variable">ele</span> <span class="hljs-operator">=</span> getElement(arr, <span class="hljs-number">2</span>);
        System.out.println(ele);
    }

    <span class="hljs-comment">/*
        定义一个方法,获取数组指定索引处的元素返回
        在工作中:都会对方法传递进来的参数进行一些合法性的校验
        参数合法,程序正常执行
        参数不合法,以抛出异常的方法,告之方法调用者,传递的参数有问题
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr,<span class="hljs-type">int</span> index)</span>{
        <span class="hljs-comment">/*
            对方法的参数数组arr进行合法性校验,判断arr是否为null
            是null,使用throw关键字抛出空指针异常,告之方法的调用者"您传递的数组arr的值是null"
         */</span>
        <span class="hljs-keyword">if</span>(arr==<span class="hljs-literal">null</span>){
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">"您传递的数组arr的值是null"</span>);
        }
        <span class="hljs-comment">/*
            对方法的参数数组索引index进行合法性校验,判断索引是否在数组索引的范围内
            不在索引范围内,使用throw关键字,抛出数组的索引越界异常,告之方法的调用者"您传递的数组的索引"+index+"不存在"
         */</span>
        <span class="hljs-keyword">if</span>(index&lt;<span class="hljs-number">0</span> || index&gt;arr.length-<span class="hljs-number">1</span>){
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayIndexOutOfBoundsException</span>(<span class="hljs-string">"您传递的数组的索引"</span>+index+<span class="hljs-string">"不存在"</span>);
        }
        <span class="hljs-type">int</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> arr[index];
        <span class="hljs-keyword">return</span> e;
    }
}</code></pre></div>
<h2 id="5throws关键字重点">5.throws关键字(重点)</h2>
<p>throws:抛出</p>
<p><strong>异常处理的第一种方式:把产生的异常对象抛出给方法的调用者去处理</strong></p>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo03Exception;

<span class="hljs-comment">/*
    throws关键字(重点)
        异常处理的第一种方式:把产生的异常对象抛出给方法的调用者去处理,建议练习的时候使用
     作用:
        方法的内部抛出了编译期异常对象,我们就必须的处理这个异常对象
        可以使用throws关键字来处理异常对象,把这个异常对象抛出给方法的调用者处理
        最终抛出给JVM处理,JVM会以红色的字体把异常对象相关信息打印的控制台,中断当前正在执行的程序
    弊端:
        产生异常的代码后边,还有其他的代码想执行,执行不到了,程序已经终止了
    格式:
        修饰符 返回值类型 方法名(参数列表) throws xxxException,...,yyyException{
            throw new xxxException("异常的信息");
            ...
            throw new yyyException("异常的信息");
        }
    注意:
        1.throws关键字必须写在方法声明处
        2.一般在方法内部抛出了什么异常对象,就使用throws关键字在方法上声明抛出什么异常对象
            a.在方法内部抛出了多个异常对象,就需要使用throws关键字在方法上声明多个异常对象
            b.在方法内部抛出的多个异常对象,如果有子父类关系,在方法上声明父类异常即可
        3.调用一个使用throws关键字声明异常的方法,那么我们就必须处理这个异常对象
            a.可以使用throws关键字继续声明抛出这个异常对象,最终会抛出给JVM处理
            b.可以使用try...catch自己手动的处理异常
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo04throws</span> {
    <span class="hljs-comment">/*
        public static void main(String[] args) throws Exception
        main方法接收到了getElement方法抛出的异常对象,把对象再继续抛出给JVM来处理==&gt;中断处理
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception{
        <span class="hljs-type">int</span>[] arr = {<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>};
        <span class="hljs-comment">//int[] arr = null;</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">ele</span> <span class="hljs-operator">=</span> getElement(arr, <span class="hljs-number">3</span>);
        System.out.println(ele);
        System.out.println(<span class="hljs-string">"后续100行代码..."</span>);
    }

    <span class="hljs-comment">/*
        定义一个方法,获取数组指定索引处的元素返回
        在工作中:都会对方法传递进来的参数进行一些合法性的校验
        参数合法,程序正常执行
        参数不合法,以抛出异常的方法,告之方法调用者,传递的参数有问题
        public static int getElement(int[] arr,int index)throws Exception
        使用throws关键字:把创建的异常对象声明抛出给方法的调用者main方法处理
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr,<span class="hljs-type">int</span> index)</span><span class="hljs-keyword">throws</span> Exception{
        <span class="hljs-keyword">if</span>(arr==<span class="hljs-literal">null</span>){
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(<span class="hljs-string">"您传递的数组arr的值是null"</span>);
        }
        <span class="hljs-keyword">if</span>(index&lt;<span class="hljs-number">0</span> || index&gt;arr.length-<span class="hljs-number">1</span>){
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(<span class="hljs-string">"您传递的数组的索引"</span>+index+<span class="hljs-string">"不存在"</span>);
        }
        <span class="hljs-type">int</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> arr[index];
        <span class="hljs-keyword">return</span> e;
    }
}</code></pre></div>
<h2 id="6throws抛出子父类异常的处理重点">6.throws抛出子父类异常的处理(重点)</h2>
<p><strong>在方法内部抛出的多个异常对象,如果有子父类关系,在方法上声明父类异常即可</strong></p>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo03Exception;

<span class="hljs-keyword">import</span> java.io.FileNotFoundException;
<span class="hljs-keyword">import</span> java.io.IOException;

<span class="hljs-comment">/*
    在方法内部抛出的多个异常对象,如果有子父类关系,在方法上声明父类异常即可
    public class FileNotFoundException extends IOException extends Exception
    FileNotFoundException:文件找不到异常
    IOException:读写异常
        public static void main(String[] args)throws FileNotFoundException,IOException
    FileNotFoundException和IOException是子父类异常,抛出父类异常即可
    简化为:
        public static void main(String[] args)throws IOException
        public static void main(String[] args)throws Exception
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo05throws</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">//readFile("d:\\abc.java");</span>
        <span class="hljs-comment">//readFile(null);</span>
        readFile(<span class="hljs-string">"c:\\a.txt"</span>);
        System.out.println(<span class="hljs-string">"后续代码!"</span>);
    }

    <span class="hljs-comment">/*
        定义一个方法,方法的参数传递一个文件的路径:  d:\\abc.java
        在方法中根据文件的路径读取文件
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFile</span><span class="hljs-params">(String path)</span><span class="hljs-keyword">throws</span> FileNotFoundException,IOException{
        <span class="hljs-comment">//判断路径path是否为null,是null抛出IOException</span>
        <span class="hljs-keyword">if</span>(path==<span class="hljs-literal">null</span>){
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">"您传递的路径是null"</span>);
        }
        <span class="hljs-comment">//判断路径path是否为d:\\abc.java,不是抛出FileNotFoundException</span>
        <span class="hljs-keyword">if</span>(!<span class="hljs-string">"d:\\abc.java"</span>.equals(path)){
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileNotFoundException</span>(<span class="hljs-string">"您传递的路径不是d:\\abc.java"</span>);
        }
        <span class="hljs-comment">//根据路径读取文件</span>
        System.out.println(<span class="hljs-string">"读取到了d:\\abc.java文件,文件中的内容是abc!"</span>);
    }
}</code></pre></div>
<h2 id="7trycatch关键字重点">7.try…catch关键字(重点)</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo03Exception;

<span class="hljs-keyword">import</span> java.io.FileNotFoundException;
<span class="hljs-keyword">import</span> java.io.IOException;

<span class="hljs-comment">/*
    try...catch关键字(重点):异常处理的第二种方式,建议在工作中使用
    作用:
        方法内部抛出了指定的编译期异常对象,我们就需要处理这个异常对象
        调用的方法上声明抛出了异常对象,我们需要处理这个异常对象
        可以使用try...catch关键字捕获处理异常,自己定义异常的处理方式
    好处:
        处理了异常对象之后,后续如果有代码,可以继续执行
    格式:
        try{
            可能产生异常的代码(没有异常的代码)
        }catch(定义一个异常相关的变量){ 变量的作用就是用来接收产生的异常对象
            异常的处理逻辑(想怎么写就怎么写)
        }
        ...
        catch(定义一个异常相关的变量){
            异常的处理逻辑(想怎么写就怎么写)
        }
    注意:
        1.try中可能产生什么异常对象,catch中就要定义什么异常变量来接收这个异常对象
        2.如果try中产生了异常对象,就会执行catch中异常的处理逻辑,执行完catch中的代码,继续执行try...catch后边的代码
        3.如果try中没有产生异常对象,就不会执行catch中异常的处理逻辑,正常执行完try中的代码,继续执行try...catch后边的代码
        4.如果try中产生了多个异常对象,就需要定义多个catch来捕获处理这些异常对象
    -------------------------------------------
    选中要添加try...catch的代码:按快捷键 ctrl+alt+t==&gt;选择try...catch
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo06TryCatch</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">//可能会产生异常的代码</span>
            readFile(<span class="hljs-string">"d:\\abc.java"</span>);
            <span class="hljs-comment">//readFile(null);</span>
            <span class="hljs-comment">//readFile("c:\\a.txt");</span>
        }<span class="hljs-keyword">catch</span> (FileNotFoundException e){<span class="hljs-comment">//FileNotFoundException e = new FileNotFoundException("您传递的路径不是d:\\abc.java");</span>
            <span class="hljs-comment">//异常的处理逻辑</span>
            System.out.println(<span class="hljs-string">"哈哈"</span>);
        }<span class="hljs-keyword">catch</span> (IOException e) {<span class="hljs-comment">//IOException e = new IOException("您传递的路径是null");</span>
            <span class="hljs-comment">//异常的处理逻辑</span>
            System.out.println(<span class="hljs-string">"呵呵"</span>);
        }
        System.out.println(<span class="hljs-string">"后续代码!"</span>);
    }

    <span class="hljs-comment">/*
        定义一个方法,方法的参数传递一个文件的路径:  d:\\abc.java
        在方法中根据文件的路径读取文件
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFile</span><span class="hljs-params">(String path)</span> <span class="hljs-keyword">throws</span> FileNotFoundException,IOException{
        <span class="hljs-comment">//判断路径path是否为null,是null抛出IOException</span>
        <span class="hljs-keyword">if</span>(path==<span class="hljs-literal">null</span>){
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">"您传递的路径是null"</span>);
        }
        <span class="hljs-comment">//判断路径path是否为d:\\abc.java,不是抛出FileNotFoundException</span>
        <span class="hljs-keyword">if</span>(!<span class="hljs-string">"d:\\abc.java"</span>.equals(path)){
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileNotFoundException</span>(<span class="hljs-string">"您传递的路径不是d:\\abc.java"</span>);
        }
        <span class="hljs-comment">//根据路径读取文件</span>
        System.out.println(<span class="hljs-string">"读取到了d:\\abc.java文件,文件中的内容是abc!"</span>);
    }
}</code></pre></div>
<h2 id="8objects类中requirenonnull方法了解">8.Objects类中requireNonNull方法(了解)</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo03Exception;

<span class="hljs-keyword">import</span> java.util.Objects;

<span class="hljs-comment">/*
    java.util.Objects:操作对象的工具类
    静态方法:容忍空指针安全的
    requireNonNull:判断传递的对象是否为null
        如果传递的对象是null,方法内部就会抛出空指针异常
        如果传递的对象不是null,则方法内部返回这个对象
    public static &lt;T&gt; T requireNonNull(T obj) {
        if (obj == null)
            throw new NullPointerException();
        return obj;
    }
    public static &lt;T&gt; T requireNonNull(T obj, String message) {
        if (obj == null)
            throw new NullPointerException(message);
        return obj;
    }
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo07Objects</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();
        <span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> Objects.requireNonNull(p);
        System.out.println(p);<span class="hljs-comment">//com.itheima.demo03Exception.Person@4554617c</span>
        System.out.println(p2);<span class="hljs-comment">//com.itheima.demo03Exception.Person@4554617c</span>
        System.out.println(p==p2);<span class="hljs-comment">//true</span>
        <span class="hljs-type">Person</span> <span class="hljs-variable">p3</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
        <span class="hljs-comment">//Person p4 = Objects.requireNonNull(p3);//NullPointerException</span>
        <span class="hljs-type">Person</span> <span class="hljs-variable">p4</span> <span class="hljs-operator">=</span> Objects.requireNonNull(p3,<span class="hljs-string">"您传递的对象是null"</span>);<span class="hljs-comment">//NullPointerException: 您传递的对象是null</span>
        System.out.println(p4);
    }
}</code></pre></div>
<h2 id="9throwable类中定义的异常处理逻辑了解">9.Throwable类中定义的异常处理逻辑(了解)</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo03Exception;

<span class="hljs-comment">/*
    Throwable类中定义的异常处理逻辑(了解)
        仅供参考,我们可以使用处理异常的方式,也可以自己定义异常的处理方式
    Throwable类中定义的方法:
        String getMessage() 返回此 throwable 的简短描述。
        String toString()  返回此 throwable 的详细消息字符串。重写Object类的toStirng方法
        void printStackTrace()  JVM把异常信息打印在控制台,默认调用就是此方法
     Exception类继承了Throwable,所以Exception所有的子类都可以使用这个三个方法
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo08Throwable</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-comment">/*throws Exception*/</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(<span class="hljs-string">"异常了!"</span>);
        } <span class="hljs-keyword">catch</span> (Exception e) {<span class="hljs-comment">//Exception e = new Exception("异常了!");</span>
            <span class="hljs-comment">//异常的处理逻辑:可以是任意的代码</span>
            <span class="hljs-comment">//System.out.println("哈哈");</span>

            <span class="hljs-comment">//String getMessage() 返回此 throwable 的简短描述。</span>
            <span class="hljs-comment">//System.out.println(e.getMessage());//异常了!</span>

            <span class="hljs-comment">//String toString()  返回此 throwable 的详细消息字符串。重写Object类的toStirng方法</span>
            <span class="hljs-comment">//System.out.println(e.toString());//java.lang.Exception: 异常了!</span>
            <span class="hljs-comment">//System.out.println(e);//java.lang.Exception: 异常了!</span>

            <span class="hljs-comment">//void printStackTrace()  JVM把异常信息打印在控制台,默认调用就是此方法,打印的异常信息是最全面的</span>
            e.printStackTrace();
            <span class="hljs-comment">/*
                java.lang.Exception: 异常了!
                at com.itheima.demo03Exception.Demo08Throwable.main(Demo08Throwable.java:15)
             */</span>
        }
    }
}</code></pre></div>
<h2 id="10finally关键字重点">10.finally关键字(重点)</h2>
<p><strong>finally关键字里边定义的代码,无论程序是否有异常,都会执行</strong></p>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo03Exception;

<span class="hljs-keyword">import</span> java.text.ParseException;
<span class="hljs-keyword">import</span> java.text.SimpleDateFormat;
<span class="hljs-keyword">import</span> java.util.Date;

<span class="hljs-comment">/*
    finally关键字(重点)
    作用:
        finally关键字里边定义的代码,无论程序是否有异常,都会执行
        工作中一般用于资源释放(IO)
     格式:
        try{
            可能产生异常的代码
        }catch(定义一个异常相关的变量){
            异常的处理逻辑(想怎么写就怎么写)
        }
        ...
        catch(定义一个异常相关的变量){
            异常的处理逻辑(想怎么写就怎么写)
        }finally{
            无论是否异常,都会执行的代码
        }
   注意:
       1.finally关键字不能单独使用,必须和try一起使用
       2.如果try中出现了异常,会先执行catch中异常的处理逻辑,再执行finally中定义的代码
            执行完毕,继续执行try...catch...finally之后的代码
       3.如果try中没有出现异常,执行完try中的代码,再执行finally中定义的代码
            执行完毕,继续执行try...catch...finally之后的代码
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo09finally</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ParseException {
        <span class="hljs-comment">/*
            程序执行流程:
            没有异常:A==&gt;C==&gt;D
            有异常:B==&gt;C==&gt;D
         */</span>
        <span class="hljs-comment">/*try {
            //可能产生异常的代码
            SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
            Date date = sdf.parse("2021-1129");
            System.out.println("A:"+date);
        } catch (ParseException e) {
            //异常的处理逻辑
            System.out.println("B:"+e.toString());
        } finally {
            //无论是否异常,都会执行的代码
            System.out.println("C:无论是否异常,都会执行的代码");
        }*/</span>

        <span class="hljs-comment">/*
            程序执行流程:
            没有异常:A==&gt;C==&gt;D
            有异常:C==&gt;JVM终止程序
         */</span>
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">//可能产生异常的代码</span>
            <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">"yyyy-MM-dd"</span>);
            <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> sdf.parse(<span class="hljs-string">"2021-1129"</span>);
            System.out.println(<span class="hljs-string">"A:"</span>+date);
        }<span class="hljs-keyword">finally</span> {
            <span class="hljs-comment">//无论是否异常,都会执行的代码</span>
            System.out.println(<span class="hljs-string">"C:无论是否异常,都会执行的代码"</span>);
        }
        System.out.println(<span class="hljs-string">"D:后续代码!"</span>);
    }
}
</code></pre></div>
<h2 id="11异常处理的注意事项了解">11.异常处理的注意事项(了解)</h2>
<h3 id="1运行时期异常">1).运行时(期)异常</h3>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo04Exception;

<span class="hljs-comment">/*
    异常的注意事项:
        1.运行时(期)异常被抛出可以不处理。
            即不捕获(不使用try...catch来捕获处理异常)
            也不声明抛出(不使用throws关键声明抛出异常)。
       运行时异常,我们无需处理,默认会交给JVM处理==&gt;中断
       运行时异常,处理没有意义,处理了也是为了执行后续代码
       但是使用数组,超出了数组索引的使用范围,就算我们使用try...catch处理了运行时异常
       实际上数组还是越界
       这时候我们应该修改代码,不让数组的索引越界,从根本上解决问题
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01Exception</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">//使用try...catch,处理了运行时异常,也是为了执行后续代码,异常本身还存在</span>
        <span class="hljs-comment">/*try {
            int[] arr = {10,20,30};
            System.out.println(arr[3]);//throw new ArrayIndexOutOfBoundsException("3")
        } catch (Exception e) {
            e.printStackTrace();
        }*/</span>

        <span class="hljs-comment">//在实际工作中:运行时异常修改代码,不让运行时异常出现,从根本上解决异常</span>
        <span class="hljs-type">int</span>[] arr = {<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>};
        System.out.println(arr[<span class="hljs-number">2</span>]);
        System.out.println(<span class="hljs-string">"后续代码!"</span>);
    }
}</code></pre></div>
<h3 id="2子父类异常的处理">2).子父类异常的处理</h3>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo04Exception;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo02Fu</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show01</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span> Exception{}

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show02</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span> Exception{}
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show03</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span> Exception{}

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show04</span><span class="hljs-params">()</span>{}
}</code></pre></div>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo04Exception;

<span class="hljs-keyword">import</span> java.text.ParseException;
<span class="hljs-keyword">import</span> java.text.SimpleDateFormat;
<span class="hljs-keyword">import</span> java.util.Date;

<span class="hljs-comment">/*
    异常处理的注意事项:
    2.子父类异常的处理
    a.如果父类的方法抛出了多个异常,
        子类重写父类方法时,子类可以抛出和父类相同的异常
        子类重写父类方法时,抛出父类异常的子类
        子类重写父类方法时,可以不抛出异常
    b.父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出

    重点:
        父类异常什么样,子类重写父类方法就和父类一样就可以了,无需考虑异常问题
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo03Zi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Demo02Fu</span> {
    <span class="hljs-comment">//子类重写父类方法时,子类可以抛出和父类相同的异常</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show01</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span> Exception{}

    <span class="hljs-comment">//子类重写父类方法时,抛出父类异常的子类</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-comment">//public void show02() throws NullPointerException { }</span>
    <span class="hljs-comment">//public void show02() throws ArrayIndexOutOfBoundsException { }</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show02</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> RuntimeException { }

    <span class="hljs-comment">//子类重写父类方法时,可以不抛出异常</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show03</span><span class="hljs-params">()</span>{}

    <span class="hljs-comment">//父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。</span>
    <span class="hljs-comment">//overridden method does not throw 'java.lang.Exception'</span>
    <span class="hljs-comment">//public void show04()throws Exception{}</span>

    <span class="hljs-comment">//此时子类产生该异常，只能捕获处理，不能声明抛出(throws处理异常的方式不能使用了)</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show04</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">"yyyy-MM-dd"</span>);
            <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> sdf.parse(<span class="hljs-string">"2021-1129"</span>);
            System.out.println(<span class="hljs-string">"A:"</span>+date);
        } <span class="hljs-keyword">catch</span> (ParseException e) {
            e.printStackTrace();
        }
    }
}</code></pre></div>
<h3 id="3多个异常使用捕获又该如何处理">3).多个异常使用捕获又该如何处理</h3>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo04Exception;

<span class="hljs-keyword">import</span> java.util.ArrayList;

<span class="hljs-comment">/*
    异常处理的注意事项:
    多个异常使用捕获(try...catch)又该如何处理呢？
    1. 多个异常分别处理。
    2. 多个异常一次捕获，多次处理。
    3. 多个异常一次捕获一次处理。
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo04Exception</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">//1. 多个异常分别处理:一个try catch处理一个异常</span>
        <span class="hljs-comment">/*try {
            int[] arr = {10,20,30};
            System.out.println(arr[3]);
        } catch (ArrayIndexOutOfBoundsException e) {
            e.printStackTrace();
        }

        try {
            ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
            list.add("aaa");
            list.add("bbb");
            System.out.println(list.get(2));
        } catch (IndexOutOfBoundsException e) {
            e.printStackTrace();
        }*/</span>

        <span class="hljs-comment">/*
            2. 多个异常一次捕获，多次处理。
            一次捕获:把所有的代码写在一个try中
            多次处理:一个异常使用一个catch处理
                每个catch中,都可以针对异常写特有的处理方式
         */</span>
        <span class="hljs-comment">/*try {
            int[] arr = {10,20,30};
            //System.out.println(arr[3]);

            ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
            list.add("aaa");
            list.add("bbb");
            System.out.println(list.get(2));
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println("数组索引越界了:"+e);
        }catch (IndexOutOfBoundsException e) {
            System.out.println("集合索引越界了:"+e);
        }*/</span>

        <span class="hljs-comment">//3. 多个异常一次捕获一次处理。</span>
        <span class="hljs-keyword">try</span> {
            <span class="hljs-type">int</span>[] arr = {<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>};
            <span class="hljs-comment">//System.out.println(arr[3]);</span>

            ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
            list.add(<span class="hljs-string">"aaa"</span>);
            list.add(<span class="hljs-string">"bbb"</span>);
            System.out.println(list.get(<span class="hljs-number">2</span>));
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-comment">/*
                多态
                    Exception e = new ArrayIndexOutOfBoundsException();
                    Exception e = new IndexOutOfBoundsException();
             */</span>
            e.printStackTrace();
        }

        System.out.println(<span class="hljs-string">"后续代码!"</span>);
    }
}
</code></pre></div>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo04Exception;

<span class="hljs-keyword">import</span> java.util.ArrayList;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo05Exception</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">/*
            2. 多个异常一次捕获，多次处理。
            一次捕获:把所有的代码写在一个try中
            多次处理:一个异常使用一个catch处理
                每个catch中,都可以针对异常写特有的处理方式
            注意:
                当多异常分别处理时，捕获处理，前边的类不能是后边类的父类
                 public class ArrayIndexOutOfBoundsException extends IndexOutOfBoundsException
         */</span>
        <span class="hljs-keyword">try</span> {
            <span class="hljs-type">int</span>[] arr = {<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>};
            <span class="hljs-comment">//System.out.println(arr[3]);</span>

            ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
            list.add(<span class="hljs-string">"aaa"</span>);
            list.add(<span class="hljs-string">"bbb"</span>);
            System.out.println(list.get(<span class="hljs-number">2</span>));
        }<span class="hljs-keyword">catch</span> (IndexOutOfBoundsException e) {
            System.out.println(<span class="hljs-string">"集合索引越界了:"</span>+e);
        } <span class="hljs-comment">/*catch (ArrayIndexOutOfBoundsException e) {
            System.out.println("数组索引越界了:"+e);
        }*/</span>
    }
}</code></pre></div>
<p><img src="/_resources/b0f495a7ed264cb4b5da0a6aa85f13fb.png" /></p>
<h2 id="12自定义异常使用">12.自定义异常(使用)</h2>
<p><strong>自定义异常:自己定义一个异常类</strong></p>
<h3 id="1概述和基本定义格式">1).概述和基本定义格式</h3>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo05Exception;

<span class="hljs-comment">/*
    自定义异常:
        java给我们提供的异常类不够我们使用,就需要我们自己定义一些异常相关的类
    注意:
        1.自定义异常,一般都是以Exception结尾的,说着这个类是一个异常相关的类(见名知意)
        2.自定义异常
            a.可以继承Exception:自定义异常就是一个编译期异常
                使用:如果在方法内部抛出了编译期异常,那么我们就必须处理这个异常
                    1).使用throws在方法上声明抛出异常对象,最终抛出给JVM处理
                    2).使用try...catch自己捕获处理异常
           b.可以继承RuntimeException:自定义异常就是一个运行时异常
                使用:如果在方法内部抛出了运行时异常,我们无需处理,默认会交给JVM处理(中断)
    格式:
         public class xxxException  extends  Exception|RuntimeException{
            //定义一个空参数构造方法
            public xxxException(){
                super(); //调用父类的空参数构造方法
            }
            
            //定义一个带异常信息的构造方法
            //我们查询异常相关类的源码发现,每个异常类都会定义一个带异常信息的构造方法,把异常信息传递给父类处理
            public xxxException(String message){
                super(message); //调用父类带异常信息的构造方法
            }
         }                 
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RegisterException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Exception</span>|RuntimeException{
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RegisterException</span><span class="hljs-params">()</span> {
        <span class="hljs-built_in">super</span>();
    }

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RegisterException</span><span class="hljs-params">(String message)</span> {
        <span class="hljs-built_in">super</span>(message);
    }
}</code></pre></div>
<h3 id="2自定义异常的使用">2).自定义异常的使用</h3>
<h4 id="a自定义异常类是编译异常必须处理">a.自定义异常类是编译异常:必须处理</h4>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo05MyException;

<span class="hljs-comment">/*
    自定义异常:RegisterException 继承 Exception
    自定义异常:就是一个编译期异常
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RegisterException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Exception</span>{
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RegisterException</span><span class="hljs-params">()</span> {
        <span class="hljs-built_in">super</span>();
    }

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RegisterException</span><span class="hljs-params">(String message)</span> {
        <span class="hljs-built_in">super</span>(message);
    }
}</code></pre></div>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo05MyException;

<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Collections;
<span class="hljs-keyword">import</span> java.util.Scanner;

<span class="hljs-comment">/*
    自定义异常的使用
    注册案例:
        1.定义一个ArrayList集合,存储用户已经注册过的用户名
        2.使用Scanner获取一个用户本次输入的注册用户名
        3.定一个方法,在方法中判断用户输入的用户名是否已经被注册
            a.遍历ArrayList集合,获取每一个已经注册的用户名
            b.使用已经注册的用户名和用户本次输入的用户名比较
                true:一样,用户名已经被注册了==&gt;抛出一个RegisterException注册异常
                false:继续遍历获取用户名比较
            c:遍历结束了,还没有找到相同的用户名
                 进行注册:把用户名存储到ArrayList集合中
                 提示用户"恭喜您xx名字注册成功!"
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01Test</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> RegisterException {
        <span class="hljs-comment">//1.定义一个ArrayList集合,存储用户已经注册过的用户名</span>
        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        Collections.addAll(list,<span class="hljs-string">"张三"</span>,<span class="hljs-string">"李四"</span>,<span class="hljs-string">"jack"</span>,<span class="hljs-string">"rose"</span>);
        <span class="hljs-comment">//2.使用Scanner获取一个用户本次输入的注册用户名</span>
        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);
        System.out.println(<span class="hljs-string">"请输入您要注册的用户名:"</span>);
        <span class="hljs-type">String</span> <span class="hljs-variable">regName</span> <span class="hljs-operator">=</span> sc.nextLine();
        <span class="hljs-comment">//调用校验的方法</span>
        checkName(list,regName);
    }

    <span class="hljs-comment">//3.定一个方法,在方法中判断用户输入的用户名是否已经被注册</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkName</span><span class="hljs-params">(ArrayList&lt;String&gt; list,String regName)</span> <span class="hljs-keyword">throws</span> RegisterException {
        <span class="hljs-comment">//a.遍历ArrayList集合,获取每一个已经注册的用户名</span>
        <span class="hljs-keyword">for</span> (String name : list) {
            <span class="hljs-comment">//b.使用已经注册的用户名和用户本次输入的用户名比较</span>
            <span class="hljs-keyword">if</span>(name.equals(regName)){
                <span class="hljs-comment">//true:一样,用户名已经被注册了==&gt;抛出一个RegisterException注册异常(编译期异常,必须使用throws或者try...catch处理)</span>
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegisterException</span>(<span class="hljs-string">"您输入的用户名["</span>+regName+<span class="hljs-string">"]已经被注册了!"</span>);
            }
            <span class="hljs-comment">//false:继续遍历获取用户名比较</span>
        }
        <span class="hljs-comment">//c:遍历结束了,还没有找到相同的用户名</span>
        <span class="hljs-comment">//进行注册:把用户名存储到ArrayList集合中</span>
        list.add(regName);
        System.out.println(list);
        <span class="hljs-comment">//提示用户"恭喜您xx名字注册成功!"</span>
        System.out.println(<span class="hljs-string">"恭喜您用户名["</span>+regName+<span class="hljs-string">"]注册成功!"</span>);
    }
}</code></pre></div>
<h4 id="b自定义异常是运行期异常不用处理">b.自定义异常是运行期异常:不用处理</h4>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo06MyException;

<span class="hljs-comment">/*
    自定义异常:RegisterException 继承 RuntimeException
    自定义异常:就是一个运行期异常
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RegisterException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span>{
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RegisterException</span><span class="hljs-params">()</span> {
        <span class="hljs-built_in">super</span>();
    }

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RegisterException</span><span class="hljs-params">(String message)</span> {
        <span class="hljs-built_in">super</span>(message);
    }
}</code></pre></div>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo06MyException;

<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Collections;
<span class="hljs-keyword">import</span> java.util.Scanner;

<span class="hljs-comment">/*
    自定义异常的使用
    注册案例:
        1.定义一个ArrayList集合,存储用户已经注册过的用户名
        2.使用Scanner获取一个用户本次输入的注册用户名
        3.定一个方法,在方法中判断用户输入的用户名是否已经被注册
            a.遍历ArrayList集合,获取每一个已经注册的用户名
            b.使用已经注册的用户名和用户本次输入的用户名比较
                true:一样,用户名已经被注册了==&gt;抛出一个RegisterException注册异常
                false:继续遍历获取用户名比较
            c:遍历结束了,还没有找到相同的用户名
                 进行注册:把用户名存储到ArrayList集合中
                 提示用户"恭喜您xx名字注册成功!"
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01Test</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>  {
        <span class="hljs-comment">//1.定义一个ArrayList集合,存储用户已经注册过的用户名</span>
        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        Collections.addAll(list,<span class="hljs-string">"张三"</span>,<span class="hljs-string">"李四"</span>,<span class="hljs-string">"jack"</span>,<span class="hljs-string">"rose"</span>);
        <span class="hljs-comment">//2.使用Scanner获取一个用户本次输入的注册用户名</span>
        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);
        System.out.println(<span class="hljs-string">"请输入您要注册的用户名:"</span>);
        <span class="hljs-type">String</span> <span class="hljs-variable">regName</span> <span class="hljs-operator">=</span> sc.nextLine();
        <span class="hljs-comment">//调用校验的方法</span>
        checkName(list,regName);
    }

    <span class="hljs-comment">//3.定一个方法,在方法中判断用户输入的用户名是否已经被注册</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkName</span><span class="hljs-params">(ArrayList&lt;String&gt; list,String regName)</span>  {
        <span class="hljs-comment">//a.遍历ArrayList集合,获取每一个已经注册的用户名</span>
        <span class="hljs-keyword">for</span> (String name : list) {
            <span class="hljs-comment">//b.使用已经注册的用户名和用户本次输入的用户名比较</span>
            <span class="hljs-keyword">if</span>(name.equals(regName)){
                <span class="hljs-comment">//true:一样,用户名已经被注册了==&gt;抛出一个RegisterException注册异常(运行时异常,无需处理.默认交给JVM处理)</span>
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegisterException</span>(<span class="hljs-string">"您输入的用户名["</span>+regName+<span class="hljs-string">"]已经被注册了!"</span>);
            }
            <span class="hljs-comment">//false:继续遍历获取用户名比较</span>
        }
        <span class="hljs-comment">//c:遍历结束了,还没有找到相同的用户名</span>
        <span class="hljs-comment">//进行注册:把用户名存储到ArrayList集合中</span>
        list.add(regName);
        System.out.println(list);
        <span class="hljs-comment">//提示用户"恭喜您xx名字注册成功!"</span>
        System.out.println(<span class="hljs-string">"恭喜您用户名["</span>+regName+<span class="hljs-string">"]注册成功!"</span>);
    }
}</code></pre></div>
<h2 id="异常总结重点中的重点">异常总结(重点中的重点):</h2>
<p><img src="/_resources/9317fc27c58a4bb1ad4ccff273368f7a.png" /></p>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo07Exception;

<span class="hljs-keyword">import</span> java.text.ParseException;
<span class="hljs-keyword">import</span> java.text.SimpleDateFormat;
<span class="hljs-keyword">import</span> java.util.Date;

<span class="hljs-comment">/*
    异常:程序不正常
    throw:在方法中抛出指定的异常对象
        运行期异常对象:无需处理,默认交给JVM处理(中断)
        编译期异常对象:必须处理
    throws:异常处理的第一种方式,把异常对象抛出给方法的调用者处理,最终抛出给JVM(中断)
        最终抛给虚拟机,程序中断,无法执行后续代码
    try...catch:异常处理的第二种方式,使用try捕获异常对象,把异常对象抛给catch(接住)处理
        自己处理了异常,可以执行后续代码
    finally:无论程序是否有异常,都会执行finally中的代码
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01Exception</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-comment">/*throws Exception */</span>{
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(<span class="hljs-string">"长绿毛了!"</span>);
        } <span class="hljs-keyword">catch</span> (Exception e) {
            e.printStackTrace();
        } <span class="hljs-keyword">finally</span> {
            System.out.println(<span class="hljs-string">"无论程序是否有异常,都会执行finally中的代码"</span>);
        }

        <span class="hljs-comment">//ctrl+alt+t</span>
        <span class="hljs-keyword">try</span> {
            <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">"yyyy-MM-dd"</span>);
            <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> sdf.parse(<span class="hljs-string">"2021-1129"</span>);
            System.out.println(<span class="hljs-string">"A:"</span>+date);
        } <span class="hljs-keyword">catch</span> (ParseException e) {
            e.printStackTrace();
        }

        System.out.println(<span class="hljs-string">"后续代码!"</span>);
    }
}</code></pre></div>
</div>
      </article>
    </div>
  </body>
</html>
