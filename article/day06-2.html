<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta http-equiv="X-UA-Compatible" content="ie=edge" />
<link rel="stylesheet" href="/_assets/main.css" />

    <title>day06-集合2 - zblog</title>
  <link rel="stylesheet" href="/_markdown_plugin_assets/highlight.js/atom-one-light.css" /></head>
  <body>
    <div class="main">
      <nav class="navigation">
        <a href="/">zblog</a>
      </nav>
      <article>
        <header>
          <h1 class="article-title">day06-集合2</h1>
          <div class="article-info">
            <div>
              <span
                >Created At：<time datetime="1625577115570"
                  >2021-07-06 21:11</time
                ></span
              >
              <span
                >Updated At：<time datetime="1637896852964"
                  >2021-11-26 11:20</time
                ></span
              >
            </div>
            
          </div>
        </header>
        <div class="article-content markdown-body"><nav class="table-of-contents"><ul><li><a href="#一-list接口">一、List接口：</a><ul><li><a href="#1特点">1.特点：</a></li><li><a href="#2新增的方法">2.新增的方法：</a></li></ul></li><li><a href="#二-list的子类arraylist数组结构">二、List的子类：ArrayList(数组结构)</a><ul><li><a href="#1特点-1">1).特点：</a></li></ul></li><li><a href="#三-list的子类linkedlist链表结构">三、List的子类：LinkedList(链表结构)</a><ul><li><a href="#1-特点增删快-查询慢">1. 特点：增删快、查询慢</a></li><li><a href="#2-我们做信息管理系统尽量不要使用此类因为我们经常查询">2. 我们做信息管理系统尽量不要使用此类，因为我们经常查询。</a></li><li><a href="#3-今天我们用linkedlist模拟栈-队列">3. 今天我们用LinkedList模拟栈、队列：</a></li></ul></li><li><a href="#四-javautilcollectionscollection集合工具类">四、java.util.Collections(Collection集合工具类)：</a></li><li><a href="#五-可变参数参数的个数">五、可变参数：参数的个数</a><ul><li><a href="#1-指方法的形参">1. 指"方法的形参"，</a></li><li><a href="#2-可变参数可以是任何类型">2. 可变参数，可以是任何"类型"</a></li><li><a href="#3-可变参数编译后就是数组-在方法内部按数组的方式处理">3. 可变参数编译后，就是"数组"， 在方法内部按"数组"的方式处理。</a></li><li><a href="#4-一个方法中最多只能有一个可变参数而且必须放在整个参数列表的末尾">4. 一个方法中，最多只能有一个"可变参数"，而且必须放在整个参数列表的"末尾"。</a></li></ul></li><li><a href="#六-set集合">六、Set集合：</a><ul><li><a href="#1特点-2">1.特点：</a></li><li><a href="#2无特有方法全是从父类继承的">2.无特有方法，全是从父类继承的。</a></li><li><a href="#3hashset内部采用的哈希表结构">3).HashSet内部采用的：哈希表结构</a></li><li><a href="#4hashset内部结构">4).HashSet内部结构：</a></li><li><a href="#5linkedhashset链表-哈希表它是set的特例有序的">5).LinkedHashSet：链表 + 哈希表，它是Set的特例：有序的</a></li></ul></li><li><a href="#七-map集合">七、Map集合：</a><ul><li><a href="#1特点无序的集合">1).特点：无序的集合</a></li><li><a href="#2map的常用方法">2).Map的常用方法：</a></li><li><a href="#3map集合不能直接遍历">3).Map集合不能直接遍历</a></li><li><a href="#4map使用自定义对象做键自定义对象需要重写hashcode和equals方法">4).Map使用自定义对象做键：自定义对象需要重写hashCode()和equals()方法。</a></li><li><a href="#5linkedhashmap有序的map集合键是链表-哈希表有序-唯一">5).LinkedHashMap：有序的Map集合，键是：链表 + 哈希表(有序 + 唯一)</a></li></ul></li></ul></nav><h2 id="一-list接口">一、List接口：</h2>
<h3 id="1特点">1.特点：</h3>
<ul>
<li>
<ol>
<li>有序的；</li>
</ol>
</li>
<li>
<ol start="2">
<li>可以存储重复元素；</li>
</ol>
</li>
<li>
<ol start="3">
<li>可以同索引访问；</li>
</ol>
</li>
</ul>
<h3 id="2新增的方法">2.新增的方法：</h3>
<ul>
<li>
<ol>
<li>增：public void add(int index , E e)：</li>
</ol>
</li>
<li>
<ol start="2">
<li>删：public E remove(int index):</li>
</ol>
</li>
<li>
<ol start="3">
<li>改：public E set(int index, E e)：</li>
</ol>
</li>
<li>
<ol start="4">
<li>查：public E get(int index):</li>
</ol>
</li>
</ul>
<h2 id="二-list的子类arraylist数组结构">二、List的子类：ArrayList(数组结构)</h2>
<h3 id="1特点-2">1).特点：</h3>
<ul>
<li>
<ol>
<li>增删慢、查询快；</li>
</ol>
</li>
<li>
<ol start="2">
<li>无特有方法，全是从父类(接口)继承的，我们学习了12个方法。</li>
</ol>
</li>
</ul>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo02</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        ArrayList &lt;String&gt;list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
 		 list.add(<span class="hljs-string">"郭德纲"</span>);
            list.add(<span class="hljs-string">"于谦"</span>);
            list.add(<span class="hljs-string">"郭麒麟"</span>);
            list.add(<span class="hljs-string">"岳云鹏"</span>);

            <span class="hljs-comment">//1.迭代器</span>
            Iterator&lt;String&gt; it = list.iterator();
            <span class="hljs-keyword">while</span> (it.hasNext()) {
                System.out.println(it.next());
            }
            System.out.println(<span class="hljs-string">"-----------------------------"</span>);
            <span class="hljs-comment">//2.增强for</span>
            <span class="hljs-keyword">for</span> (String s : list) {
                System.out.println(s);
            }
            System.out.println(<span class="hljs-string">"-----------------------------"</span>);

            <span class="hljs-comment">//3.普通for</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) {
                System.out.println(list.get(i));
            }

        }
    } </code></pre></div>
<h2 id="三-list的子类linkedlist链表结构">三、List的子类：LinkedList(链表结构)</h2>
<h3 id="1-特点增删快-查询慢">1. 特点：增删快、查询慢</h3>
<h3 id="2-我们做信息管理系统尽量不要使用此类因为我们经常查询">2. 我们做信息管理系统尽量不要使用此类，因为我们经常查询。</h3>
<h3 id="3-今天我们用linkedlist模拟栈-队列">3. 今天我们用LinkedList模拟栈、队列：</h3>
<ul>
<li>
<ol>
<li>栈：后进先出：</li>
</ol>
<ul>
<li>
<ol>
<li>push(E e)：压栈</li>
</ol>
</li>
<li>
<ol start="2">
<li>pop()：弹栈:</li>
</ol>
</li>
</ul>
</li>
</ul>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo03</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
<span class="hljs-comment">//模拟栈:</span>
        <span class="hljs-comment">//1.创建LinkedList对象</span>
        LinkedList &lt;string&gt;list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
 			list.push(<span class="hljs-string">"孙悟空"</span>);
            list.push(<span class="hljs-string">"猪八戒"</span>);
            list.push(<span class="hljs-string">"沙和尚"</span>);
            list.push(<span class="hljs-string">"唐三藏"</span>);

            System.out.println(<span class="hljs-string">"集合大小："</span> + list.size());<span class="hljs-comment">//4</span>

            <span class="hljs-keyword">while</span> (list.size() &gt; <span class="hljs-number">0</span>) {
                System.out.println(<span class="hljs-string">"弹出一个："</span> + list.pop());
            }
            System.out.println(list);

        
            <span class="hljs-comment">//模拟队列</span>
            LinkedList&lt;String&gt; list2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
            list2.add(<span class="hljs-string">"贾宝玉"</span>);<span class="hljs-comment">//排队</span>
            list2.add(<span class="hljs-string">"王宝强"</span>);<span class="hljs-comment">//排队</span>
            list2.add(<span class="hljs-string">"郭德纲"</span>);<span class="hljs-comment">//...</span>
            list2.add(<span class="hljs-string">"薛宝钗"</span>);<span class="hljs-comment">//...</span>

            <span class="hljs-keyword">while</span> (list2.size() &gt; <span class="hljs-number">0</span>) {
                System.out.println(<span class="hljs-string">"弹出一个："</span> + list2.pop());
            }
        }
    } </code></pre></div>
<h2 id="四-javautilcollectionscollection集合工具类">四、java.util.Collections(Collection集合工具类)：</h2>
<p>它里面包含了一些静态方法，可以很方便的操作Collection集合。</p>
<ul>
<li>
<ol>
<li>public static void shuffle(List&lt;?&gt; list)：打乱集合中元素的顺序；</li>
</ol>
</li>
<li>
<ol start="2">
<li>public static <t class="jop-noMdConv">void sort(List <t class="jop-noMdConv">list):</t></t></li>
</ol>
</li>
</ul>
<p>要求集合中的元素必须实现Comparable接口，重写compareTo()方法</p>
<ul>
<li>
<ol start="3">
<li>public static <t class="jop-noMdConv">void sort(List <t class="jop-noMdConv">list,Comparator&lt;? super T&gt; c)：<br />
使用第二个参数的比较器，将第一个参数集合中的元素进行排序。 有两种情况可以使用此方法：</t></t></li>
</ol>
<ul>
<li>
<ol>
<li>集合元素没有实现Comparable接口;</li>
</ol>
</li>
<li>
<ol start="2">
<li>集合元素实现了Comparable接口，也重写了compareTo()方法，但我们想按其他的方式排序。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="五-可变参数参数的个数">五、可变参数：参数的个数</h2>
<h3 id="1-指方法的形参">1. 指"方法的形参"，</h3>
<p>如果不确定需要多少个某个类型的参数，可以定义为：可变参数 public static void getSum(int … nums){ }</p>
<h3 id="2-可变参数可以是任何类型">2. 可变参数，可以是任何"类型"</h3>
<h3 id="3-可变参数编译后就是数组-在方法内部按数组的方式处理">3. 可变参数编译后，就是"数组"， 在方法内部按"数组"的方式处理。</h3>
<h3 id="4-一个方法中最多只能有一个可变参数而且必须放在整个参数列表的末尾">4. 一个方法中，最多只能有一个"可变参数"，而且必须放在整个参数列表的"末尾"。</h3>
<div><pre class="hljs"><code> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo09</span> {
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
            <span class="hljs-type">int</span>[] arr = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">43</span>, <span class="hljs-number">25</span>, <span class="hljs-number">25</span>};
            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> getSum(arr);
            System.out.println(sum);

            <span class="hljs-type">int</span> <span class="hljs-variable">sum1</span> <span class="hljs-operator">=</span> getSum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">60</span>, <span class="hljs-number">60</span>, <span class="hljs-number">432</span>, <span class="hljs-number">43</span>, <span class="hljs-number">25</span>, <span class="hljs-number">23</span>, <span class="hljs-number">25</span>);<span class="hljs-comment">//编译后：int sum1 = getSum(new int[]{10,20,30,...25});</span>
            System.out.println(sum1);

            <span class="hljs-type">int</span> <span class="hljs-variable">sum2</span> <span class="hljs-operator">=</span> getSum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<span class="hljs-comment">//编译后：int sum2 = getSum(new int[]{10,20});</span>
            System.out.println(sum2);

            <span class="hljs-type">int</span> <span class="hljs-variable">sum3</span> <span class="hljs-operator">=</span> getSum();<span class="hljs-comment">//编译后：int sum3 = getSum(new int[0]);</span>
            System.out.println(sum3);
        }

        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSum</span><span class="hljs-params">(<span class="hljs-type">int</span> ...arr)</span> {<span class="hljs-comment">//语法糖——假的。编译后：getSum(int[] arr)</span>
            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
                sum += arr[i];
            }
            <span class="hljs-keyword">return</span> sum;
        }
    } </code></pre></div>
<hr />
<h2 id="六-set集合">六、Set集合：</h2>
<h3 id="1特点-3">1.特点：</h3>
<ul>
<li>
<ol>
<li>无序的；</li>
</ol>
</li>
<li>
<ol start="2">
<li>不能存储重复元素；</li>
</ol>
</li>
<li>
<ol start="3">
<li>不能通过索引访问；</li>
</ol>
</li>
</ul>
<h3 id="2无特有方法全是从父类继承的">2.无特有方法，全是从父类继承的。</h3>
<h3 id="3hashset内部采用的哈希表结构">3).HashSet内部采用的：哈希表结构</h3>
<ul>
<li>
<ol>
<li>无序：通过哈希值 % 16 决定存储位置。</li>
</ol>
</li>
<li>
<ol start="2">
<li>唯一：通过哈希值 % 16 决定存储位置，如果位置上有数据，再调用元素的equals(),如果仍然相同，不存。</li>
</ol>
</li>
</ul>
<h3 id="4hashset内部结构">4).HashSet内部结构：</h3>
<ul>
<li>
<ol>
<li>JDK8以前：数组 + 链表</li>
</ol>
</li>
<li>
<ol start="2">
<li>JDK8以后：数组 + 链表(大于8个)–&gt;转换为：红黑树(查找快)</li>
</ol>
</li>
</ul>
<h3 id="5linkedhashset链表-哈希表它是set的特例有序的">5).LinkedHashSet：链表 + 哈希表，它是Set的特例：有序的</h3>
<h2 id="七-map集合">七、Map集合：</h2>
<h3 id="1特点无序的集合">1).特点：无序的集合</h3>
<ul>
<li>1.键值对存储；</li>
<li>2.可以通过"键"找对应的"值"</li>
<li>3.键不能重复(值可以重复)</li>
</ul>
<h3 id="2map的常用方法">2).Map的常用方法：</h3>
<ul>
<li>
<ol>
<li>增、改 public V put(K key, V value):</li>
</ol>
<blockquote>
<p>把指定的键与指定的值添加到Map集合中。<br />
注意：正常添加，返回：null 执行修改，会用新值，替换旧值，返回：旧值</p>
</blockquote>
</li>
<li>
<ol start="2">
<li>删 public V remove(Object key):</li>
</ol>
<blockquote>
<p>把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</p>
</blockquote>
</li>
<li>
<ol start="3">
<li>查：</li>
</ol>
<blockquote>
<p>public V get(Object key) 根据指定的键，在Map集合中获取对应的值。<br />
public Set<k class="jop-noMdConv"> keySet(): 获取Map集合中所有的键，存储到Set集合中。<br />
public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): 获取Map集合中所有的键值对对象的集合(Set集合)。<br />
public boolean containKey(Object key):判断该集合中是否有此键。</k></p>
</blockquote>
</li>
</ul>
<h3 id="3map集合不能直接遍历">3).Map集合不能直接遍历</h3>
<ul>
<li>
<ol>
<li>keySet():简单</li>
</ol>
</li>
<li>
<ol start="2">
<li>entrySet():</li>
</ol>
</li>
</ul>
<h3 id="4map使用自定义对象做键自定义对象需要重写hashcode和equals方法">4).Map使用自定义对象做键：自定义对象需要重写hashCode()和equals()方法。</h3>
<h3 id="5linkedhashmap有序的map集合键是链表-哈希表有序-唯一">5).LinkedHashMap：有序的Map集合，键是：链表 + 哈希表(有序 + 唯一)</h3>
</div>
      </article>
    </div>
  </body>
</html>
