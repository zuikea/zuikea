<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta http-equiv="X-UA-Compatible" content="ie=edge" />
<link rel="stylesheet" href="/_assets/main.css" />

    <title>day02-static、接口、多态、内部类 - zblog</title>
  <link rel="stylesheet" href="/_markdown_plugin_assets/highlight.js/atom-one-light.css" /></head>
  <body>
    <div class="main">
      <nav class="navigation">
        <a href="/">zblog</a>
      </nav>
      <article>
        <header>
          <h1 class="article-title">day02-static、接口、多态、内部类</h1>
          <div class="article-info">
            <div>
              <span
                >Created At：<time datetime="1625556738412"
                  >2021-07-06 15:32</time
                ></span
              >
              <span
                >Updated At：<time datetime="1638092802748"
                  >2021-11-28 17:46</time
                ></span
              >
            </div>
            
          </div>
        </header>
        <div class="article-content markdown-body"><nav class="table-of-contents"><ul><li><a href="#第一章static关键字">第一章：static关键字</a><ul><li><a href="#11-static关键字_概述">1.1 static关键字_概述</a></li><li><a href="#12-static关键字_静态原理图">1.2 static关键字_静态原理图</a></li><li><a href="#13-static关键字_静态代码块">1.3 static关键字_静态代码块</a><ul><li><a href="#对于有些静态属性不能在声明的同时初始化例如">对于有些”静态属性”不能在声明的同时初始化，例如：</a></li></ul></li><li><a href="#14-以后开发中static的应用">1.4 以后开发中static的应用</a><ul><li><a href="#1static可以修饰">1).static可以修饰：</a></li><li><a href="#2以后开发中使用">2).以后开发中使用：</a></li><li><a href="#3其它注意事项">3).其它注意事项：</a></li></ul></li></ul></li><li><a href="#第二章接口">第二章：接口</a><ul><li><a href="#21-接口的概念视频">2.1 接口的概念(视频)</a><ul><li><a href="#1接口是一种特殊数据类型使用关键字interface定义">1).接口：是一种“特殊”数据类型，使用关键字：interface定义</a></li><li><a href="#2为什么要有接口">2).为什么要有接口：</a></li><li><a href="#3接口的定义使用关键字interface">3).接口的定义：使用关键字：interface</a></li><li><a href="#4接口中的成员jdk8有四种成员">4).接口中的成员(JDK8：有四种成员)</a></li></ul></li><li><a href="#22-子类和接口的关系_实现视频">2.2 子类和接口的关系_实现(视频)</a></li><li><a href="#23-子类多实现时的几种冲突情况">2.3 子类多实现时的几种冲突情况</a><ul><li><a href="#a公有-静态-常量的冲突">A).公有、静态、常量的冲突：</a></li><li><a href="#b公有-抽象方法的冲突">B).公有、抽象方法的冲突：</a></li><li><a href="#c公有-默认方法">C).公有、默认方法：</a></li><li><a href="#d公有-静态方法">D).公有、静态方法：</a></li></ul></li><li><a href="#24-接口继承接口视频">2.4 接口继承接口(视频)</a><ul><li><a href="#1接口和接口之间有一个继承的关系而且可以多继承">1).接口和接口之间，有一个“继承”的关系，而且可以“多继承”：</a></li></ul></li></ul></li><li><a href="#第三章多态">第三章：多态</a><ul><li><a href="#31-多态的概念">3.1 多态的概念</a><ul><li><a href="#1什么是多态指一类事物的多种表现形式">1).什么是“多态”：指“一类事物的多种表现形式”</a></li><li><a href="#2关于java的引用类型">2).关于“Java的引用类型”：</a></li></ul></li><li><a href="#32-多态时访问成员的特点">3.2 多态时访问成员的特点</a></li><li><a href="#33-多态的弊端和好处">3.3 多态的弊端和好处</a><ul><li><a href="#1弊端不能访问子类特有成员">1).弊端：不能访问子类特有成员！</a></li><li><a href="#2好处尤其是作为形参多态时对于程序扩展非常有好处">2).好处：尤其是作为“形参多态”时，对于“程序扩展非常有好处”：</a></li></ul></li><li><a href="#34-多态的几种应用">3.4 多态的几种应用</a><ul><li><a href="#1多态的三种使用方式">1).多态的三种使用方式：</a></li><li><a href="#2多态的三种应用">2).多态的三种应用：</a></li></ul></li><li><a href="#35-多态的转型">3.5 多态的转型</a><ul><li><a href="#1向上转型">1).向上转型：</a></li><li><a href="#2向下转型强制转换">2).向下转型(强制转换)</a></li></ul></li><li><a href="#36-笔记本电脑案例">3.6 笔记本电脑案例</a></li></ul></li><li><a href="#第四章内部类">第四章：内部类</a><ul><li><a href="#41-内部类_概念">4.1 内部类_概念</a><ul><li><a href="#1定义在另一个类内部的类叫内部类">1).定义在另一个类内部的类叫：内部类。</a></li><li><a href="#2内部类有两种">2).内部类有两种：</a></li></ul></li><li><a href="#42-内部类_成员内部类">4.2 内部类_成员内部类</a><ul><li><a href="#1成员内部类是定义在外部类的成员位置类体中方法外">1).成员内部类：是定义在“外部类的成员位置”——类体中，方法外</a></li></ul></li><li><a href="#43-内部类_局部内部类">4.3 内部类_局部内部类</a><ul><li><a href="#1局部内部类是定义在方法内部的类">1).局部内部类：是定义在“方法内部的类”</a></li></ul></li><li><a href="#44-内部类_匿名内部类重点掌握">4.4 内部类_匿名内部类【重点掌握】</a><ul><li><a href="#1匿名内部类是局部内部类的一种它也是定义在方法中的只是没有名字-但是它必须要有一个外部的父类父接口">1).匿名内部类是“局部内部类”的一种，它也是定义在“方法中”的，只是“没有名字”。但是它必须要有一个“外部的父类/父接口”。</a></li><li><a href="#示例">示例：</a></li></ul></li></ul></li><li><a href="#总结">总结：</a><ul><li><a href="#1能够掌握static关键字修饰的变量调用方式">1.能够掌握static关键字修饰的变量调用方式</a><ul><li><a href="#1可以通过对象调用">1).可以通过”对象”调用：</a></li><li><a href="#2可以通过类名调用推荐">2).可以通过”类名”调用：【推荐】</a></li></ul></li><li><a href="#2能够掌握static关键字修饰的方法调用方式">2.能够掌握static关键字修饰的方法调用方式</a><ul><li><a href="#1通过对象调用">1).通过“对象”调用：</a></li><li><a href="#2通过类名调用">2).通过“类名”调用：</a></li></ul></li><li><a href="#3能够写出接口的定义格式">3.能够写出接口的定义格式</a></li><li><a href="#4能够写出接口的实现格式">4.能够写出接口的实现格式</a></li><li><a href="#5能够说出接口中的成员特点">5.能够说出接口中的成员特点</a></li><li><a href="#6能够说出多态的前提">6.能够说出多态的前提</a></li><li><a href="#7能够写出多态的格式">7.能够写出多态的格式</a></li><li><a href="#8能够理解多态向上转型和向下转型">8.能够理解多态向上转型和向下转型</a></li><li><a href="#9能够说出内部类概念">9.能够说出内部类概念</a></li><li><a href="#10能够理解匿名内部类的编写格式">10.能够理解匿名内部类的编写格式</a></li></ul></li></ul></nav><h1 id="第一章static关键字">第一章：static关键字</h1>
<h2 id="11-static关键字_概述">1.1 static关键字_概述</h2>
<p><img src="/_resources/78bfe7deb84043079b39b4286ee25417.png" /></p>
<h2 id="12-static关键字_静态原理图">1.2 static关键字_静态原理图</h2>
<p><img src="/_resources/cd41b34cb2e24080a342a0e1adcb882c.png" /></p>
<h2 id="13-static关键字_静态代码块">1.3 static关键字_静态代码块</h2>
<h3 id="对于有些静态属性不能在声明的同时初始化例如">对于有些”静态属性”不能在声明的同时初始化，例如：</h3>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Var</span>{
    <span class="hljs-comment">//要求：为这个静态的数组的每个元素初始化为：1–100的随机数</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];
    <span class="hljs-comment">//只能使用”静态代码块”对其初始化</span>
    <span class="hljs-comment">//当第一次使用Var类，会先执行一次静态代码块，而且只执行一次。</span>
    <span class="hljs-keyword">static</span>{
        Random rdm = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Random</span>();
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; arr.length ; i++){
            arr[i] = rdm.<span class="hljs-built_in">nextInt</span>(<span class="hljs-number">100</span>) + <span class="hljs-number">1</span>;
        }
    }
}</code></pre></div>
<h2 id="14-以后开发中static的应用">1.4 以后开发中static的应用</h2>
<h3 id="1static可以修饰">1).static可以修饰：</h3>
<blockquote>
<p>1).成员属性：表示：静态属性，存储在”静态存储区”，只有一份存储空间，可以通过“类名”直接访问，比较方便。<br />
2).成员方法：表示：静态方法，存储在”静态存储区”，可以通过“类名”直接访问，比较方便。</p>
</blockquote>
<h3 id="2以后开发中使用">2).以后开发中使用：</h3>
<p>通常对于“一些共享的成员变量、工具性的方法”将其修饰为：static，使用起来比较方便。
例如：
<img src="/_resources/a6e0b272c63e4af5ae45baee1fae834a.png" /></p>
<h3 id="3其它注意事项">3).其它注意事项：</h3>
<blockquote>
<p>由于“静态成员”总是早于“普通成员”进入内存，</p>
<p>所以：静态方法，只能“直接访问”静态成员，不能访问普通成员</p>
<p>普通方法，可以访问“静态成员”，也可以访问“普通成员”。</p>
</blockquote>
<h1 id="第二章接口">第二章：接口</h1>
<h2 id="21-接口的概念视频">2.1 接口的概念(视频)</h2>
<h3 id="1接口是一种特殊数据类型使用关键字interface定义">1).接口：是一种“特殊”数据类型，使用关键字：interface定义</h3>
<div><pre class="hljs"><code>例如：<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">Animal</span>{
}</code></pre></div>
<h3 id="2为什么要有接口">2).为什么要有接口：</h3>
<p><img src="/_resources/8497cad798f64a43a808a24a9dbdd5f7.png" /></p>
<h3 id="3接口的定义使用关键字interface">3).接口的定义：使用关键字：interface</h3>
<div><pre class="hljs"><code>例如：

<span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span>eface ILog{ <span class="hljs-comment">//建议I开头，表示是一个接口</span>

}

编译后，会生成<span class="hljs-keyword">class</span>文件，但“接口”不能被创建对象。

做“父级”的类使用，供子类去实现，重写抽象方法，达到“功能扩展”的目的。</code></pre></div>
<h3 id="4接口中的成员jdk8有四种成员">4).接口中的成员(JDK8：有四种成员)</h3>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ILog</span> {
    <span class="hljs-comment">//1.公有、静态、常量(JDK8以前)：可以被子类继承</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> final <span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span>;
    <span class="hljs-built_in">int</span> b = <span class="hljs-number">20</span>;<span class="hljs-comment">//编译后，会变为：public static final int b = 20;</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> c = <span class="hljs-number">30</span>;<span class="hljs-comment">//编译后，会变为：pubic static fina int c = 30;</span>
    
    <span class="hljs-comment">//2.公有、抽象方法(JDK8以前)：强制子类必须重写</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">log</span>(<span class="hljs-params"></span>)</span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span>(<span class="hljs-params"></span>)</span>;<span class="hljs-comment">//编译后：public abstract void show();</span>
    
    <span class="hljs-comment">//3.公有、默认方法：(JDK8开始)必须用public，default修饰，必须有方法体：被子类继承，子类可以重写，也可以不重写。</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-literal">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show1</span>(<span class="hljs-params"></span>)</span>{
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"默认方法show1()"</span>);
    }
    
    <span class="hljs-comment">//4.公有、静态方法(JDK8开始)：不能被子类继承，就属于本接口，通过"接口名.静态方法名"访问，工具性方法。</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show2</span>(<span class="hljs-params"></span>)</span>{
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"公有、静态的show2()"</span>);
    }
}</code></pre></div>
<h2 id="22-子类和接口的关系_实现视频">2.2 子类和接口的关系_实现(视频)</h2>
<ol>
<li>子类可以“实现”一个或者多个接口，使用关键字：implements</li>
<li>子类实现接口后，必须重写接口中所有的“公有、抽象方法”，否则子类必须是一个“抽象类”。</li>
<li>实现的几种方式：</li>
</ol>
<ul>
<li>
<ol>
<li>子类可以实现一个接口</li>
</ol>
</li>
</ul>
<div><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-symbol">Student</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">ILog</span>{

}</code></pre></div>
<ul>
<li>
<ol start="2">
<li>子类可以同时实现多个接口：</li>
</ol>
</li>
</ul>
<div><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-symbol">Student</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">ILog,<span class="hljs-symbol">IAnimal</span></span>{

}</code></pre></div>
<ul>
<li>
<ol start="3">
<li>子类可以在“继承”的同时，实现一个或多个接口</li>
</ol>
</li>
</ul>
<div><pre class="hljs"><code>public inteface <span class="hljs-type">ILog</span>{}
public inteface <span class="hljs-type">IA</span>{}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Human</span> <span class="hljs-title">implements</span> <span class="hljs-title">ILog</span> , <span class="hljs-title">IA</span></span>{<span class="hljs-comment">//一定要“先继承，后实现”</span>

}</code></pre></div>
<h2 id="23-子类多实现时的几种冲突情况">2.3 子类多实现时的几种冲突情况</h2>
<p>当一个子类同时“实现多个接口”时，在“多个接口”中可能会有一些：成员属性的冲突、抽象方法的冲突、默认方法的冲突、静态方法的冲突：</p>
<h3 id="a公有-静态-常量的冲突">A).公有、静态、常量的冲突：</h3>
<p><img src="/_resources/0cf1e3e3bfce4b1c981931849b367fc8.png" /></p>
<h3 id="b公有-抽象方法的冲突">B).公有、抽象方法的冲突：</h3>
<p><img src="/_resources/d32eec679ae241d4b49e93d0984030b0.png" /></p>
<h3 id="c公有-默认方法">C).公有、默认方法：</h3>
<p><img src="/_resources/508293bc46ef4454b5620a1aa3acef73.png" /></p>
<h3 id="d公有-静态方法">D).公有、静态方法：</h3>
<p><img src="/_resources/4863bc9245bc43eca0dc8902a6ecf949.png" /></p>
<h2 id="24-接口继承接口视频">2.4 接口继承接口(视频)</h2>
<h3 id="1接口和接口之间有一个继承的关系而且可以多继承">1).接口和接口之间，有一个“继承”的关系，而且可以“多继承”：</h3>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">IA</span>{}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">IB</span>{}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">IC</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">IA</span>,<span class="hljs-symbol">IB</span>{<span class="hljs-comment">//接口可以继承其它接口，而且可以多继承</span>
}</code></pre></div>
<p>接口和接口之间：继承关系，而且可以多继承<br />
类和接口之间：实现关系，可以多实现；<br />
类和类之间：继承关系，只能单继承<br />
-------------------------------------------------------------------------------<br />
课后测试：<br />
1).一个接口继承多个接口的冲突情况：<br />
2).一个子类继承父类同时实现一个或多个接口的冲突情况：</p>
<h1 id="第三章多态">第三章：多态</h1>
<p>面向对象语言的三个特征：封装、继承、多态</p>
<h2 id="31-多态的概念">3.1 多态的概念</h2>
<h3 id="1什么是多态指一类事物的多种表现形式">1).什么是“多态”：指“一类事物的多种表现形式”</h3>
<p>Java代码中体现的：“父类类型的变量”存储了它的“子类对象的引用”。`
示例：</p>
<div><pre class="hljs"><code>//<span class="hljs-number">2</span>.多态
Animal a1 <span class="hljs-operator">=</span> new Cat()<span class="hljs-comment">;</span>
a1.eat()<span class="hljs-comment">;</span>

Animal a2 <span class="hljs-operator">=</span> new Dog()<span class="hljs-comment">;</span>
a2.eat()<span class="hljs-comment">;</span></code></pre></div>
<p>“多态”的使用前提：必须要有“继承”/“实现”关系。</p>
<h3 id="2关于java的引用类型">2).关于“Java的引用类型”：</h3>
<div><pre class="hljs"><code>ArrayList list = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>();<span class="hljs-comment">//右边产生的是ArrayList对象的空间，左边是：ArrayList类型的变量存储这个地址。</span>

<span class="hljs-keyword">String</span> str = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>();<span class="hljs-comment">//编译错误，不能用String类型的变量存储ArrayList对象的地址。</span>

Random rdm = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>();<span class="hljs-comment">//编译错误</span>

ArrayList list = <span class="hljs-keyword">new</span> <span class="hljs-type">String</span>(“”);<span class="hljs-comment">//编译错误</span></code></pre></div>
<h2 id="32-多态时访问成员的特点">3.2 多态时访问成员的特点</h2>
<p>1).多态时访问的成员都是“父类的”，只有当子类重写方法时，访问的才是“子类”的。多态时，不能访问子类特有成员。
<img src="/_resources/a5de677b78f64a2dabb799ac9ae686cc.png" /></p>
<h2 id="33-多态的弊端和好处">3.3 多态的弊端和好处</h2>
<h3 id="1弊端不能访问子类特有成员">1).弊端：不能访问子类特有成员！</h3>
<h3 id="2好处尤其是作为形参多态时对于程序扩展非常有好处">2).好处：尤其是作为“形参多态”时，对于“程序扩展非常有好处”：</h3>
<p><img src="/_resources/05624e67e3a24d48b215fcceafc58270.png" /></p>
<h2 id="34-多态的几种应用">3.4 多态的几种应用</h2>
<h3 id="1多态的三种使用方式">1).多态的三种使用方式：</h3>
<div><pre class="hljs"><code><span class="hljs-number">1</span>).父类的多态：
    public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span>{}
    public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span></span>{}
    main(){
    <span class="hljs-type">Animal</span> a = <span class="hljs-keyword">new</span> <span class="hljs-type">Cat</span>();
    }
<span class="hljs-number">2</span>).父抽象类的多态：
    public <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span>{}
    public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span></span>{}
    main(){
    <span class="hljs-type">Animal</span> a = <span class="hljs-keyword">new</span> <span class="hljs-type">Cat</span>();
    }
 <span class="hljs-number">3</span>).父接口的多态
        public interface <span class="hljs-type">IAnimal</span>{}
        public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-title">implements</span> <span class="hljs-title">IAnimal</span></span>{}
        main(){
            <span class="hljs-type">IAnimal</span> a = <span class="hljs-keyword">new</span> <span class="hljs-type">Cat</span>();
        }</code></pre></div>
<h3 id="2多态的三种应用">2).多态的三种应用：</h3>
<div><pre class="hljs"><code><span class="hljs-number">1</span>).变量的多态使用：
<span class="hljs-title class_">Animal</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();

<span class="hljs-number">2</span>).形参的多态使用：
<span class="hljs-comment">//可以接收任何Animal及其子类对象的引用</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">print</span>(<span class="hljs-params">Animal a </span>){

}

<span class="hljs-number">3</span>).返回值的多态：
<span class="hljs-title function_">main</span>(<span class="hljs-params"></span>){
    <span class="hljs-title class_">Animal</span> a = <span class="hljs-title function_">getAnimal</span>();<span class="hljs-comment">//相当于：Animal a = new Cat();</span>
}
<span class="hljs-comment">//可以返回Animal的任何子类对象</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">Animal</span> <span class="hljs-title function_">getAnimal</span>(<span class="hljs-params"></span>){
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<span class="hljs-comment">//也可以return new Dog();</span>
}</code></pre></div>
<h2 id="35-多态的转型">3.5 多态的转型</h2>
<h3 id="1向上转型">1).向上转型：</h3>
<div><pre class="hljs"><code>Animal a = <span class="hljs-keyword">new</span> <span class="hljs-type">Cat</span>();<span class="hljs-comment">//将Cat类型自动提升为Animal类型</span></code></pre></div>
<p>此时不能访问子类特有成员
要想访问子类特有成员，将Animal类型的a转换为Cat类型——向下转型</p>
<h3 id="2向下转型强制转换">2).向下转型(强制转换)</h3>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo12</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String\[\] args)</span> {
    <span class="hljs-comment">//1.向上转型——多态</span>
    <span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();
    a.eat();
    <span class="hljs-comment">// a.catchMouse();//编译错误，不能访问子类特有成员</span>
     <span class="hljs-comment">//2.要想访问子类特有成员，向下转型</span>
        <span class="hljs-keyword">if</span>(a <span class="hljs-keyword">instanceof</span> Cat) {<span class="hljs-comment">//true</span>
            <span class="hljs-type">Cat</span> <span class="hljs-variable">cat</span> <span class="hljs-operator">=</span> (Cat) a;
            cat.eat();
            cat.catchMouse();
        }
        
        <span class="hljs-keyword">if</span>(a <span class="hljs-keyword">instanceof</span> Dog) {<span class="hljs-comment">//false</span>
            <span class="hljs-type">Dog</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> (Dog) a;
            dog.eat();
        }
}</code></pre></div>
<p>}</p>
<h2 id="36-笔记本电脑案例">3.6 笔记本电脑案例</h2>
<p>此案例可以说明“多态的好处”
<img src="/_resources/1f72a2246b634ebcae0ee91429600360.png" /></p>
<p>代码实现：</p>
<p><img src="/_resources/218a08ba83de40fcbd1bc0250b076c79.png" /></p>
<div><pre class="hljs"><code>    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IA</span>{
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show1</span><span class="hljs-params">()</span>;
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IB</span>{
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show2</span><span class="hljs-params">()</span>;
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Zi</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IA</span>,IB{
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show1</span><span class="hljs-params">()</span>{
        }
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show2</span><span class="hljs-params">()</span>{
        }
    }
    main(){
        <span class="hljs-type">IA</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Zi</span>();
        a.show1();
        <span class="hljs-type">IB</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Zi</span>();
        b.show2();
    } </code></pre></div>
<h1 id="第四章内部类">第四章：内部类</h1>
<h2 id="41-内部类_概念">4.1 内部类_概念</h2>
<h3 id="1定义在另一个类内部的类叫内部类">1).定义在另一个类内部的类叫：内部类。</h3>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">Student</span> {
    <span class="hljs-comment">//1.成员属性</span>
    <span class="hljs-comment">//2.成员方法</span>
    <span class="hljs-comment">//3.构造方法</span>
    <span class="hljs-comment">//4.内部类</span>
    <span class="hljs-keyword">class</span> <span class="hljs-symbol">A</span>{
    } 
}</code></pre></div>
<h3 id="2内部类有两种">2).内部类有两种：</h3>
<blockquote>
<p>1).成员内部类：</p>
<p>2).局部内部类：</p>
<ul>
<li>|–匿名局部内部类【常用】</li>
</ul>
</blockquote>
<h2 id="42-内部类_成员内部类">4.2 内部类_成员内部类</h2>
<h3 id="1成员内部类是定义在外部类的成员位置类体中方法外">1).成员内部类：是定义在“外部类的成员位置”——类体中，方法外</h3>
<p><img src="/_resources/7c1726a1808e4fdf9afacc75d3f60c93.png" /></p>
<h2 id="43-内部类_局部内部类">4.3 内部类_局部内部类</h2>
<h3 id="1局部内部类是定义在方法内部的类">1).局部内部类：是定义在“方法内部的类”</h3>
<p><img src="/_resources/edcae83f0e1f4a0d97fb9859a3bea6e1.png" /></p>
<h2 id="44-内部类_匿名内部类重点掌握">4.4 内部类_匿名内部类【重点掌握】</h2>
<h3 id="1匿名内部类是局部内部类的一种它也是定义在方法中的只是没有名字-但是它必须要有一个外部的父类父接口">1).匿名内部类是“局部内部类”的一种，它也是定义在“方法中”的，只是“没有名字”。但是它必须要有一个“外部的父类/父接口”。</h3>
<p>语法：</p>
<div><pre class="hljs"><code><span class="hljs-keyword">new</span> <span class="hljs-type"></span>父类/父接口(){
<span class="hljs-comment">//子类类体</span>
}</code></pre></div>
<h3 id="示例">示例：</h3>
<p><img src="/_resources/b91e9742f7124a29b84fe79d37918a27.png" /></p>
<hr />
<h1 id="总结">总结：</h1>
<h2 id="1能够掌握static关键字修饰的变量调用方式">1.能够掌握static关键字修饰的变量调用方式</h2>
<h3 id="1可以通过对象调用">1).可以通过”对象”调用：</h3>
<div><pre class="hljs"><code>Var v <span class="hljs-operator">=</span> new Var()<span class="hljs-comment">;</span>
System.out.println(v.school)<span class="hljs-comment">;</span></code></pre></div>
<h3 id="2可以通过类名调用推荐">2).可以通过”类名”调用：【推荐】</h3>
<div><pre class="hljs"><code>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">Var</span>.school);</code></pre></div>
<h2 id="2能够掌握static关键字修饰的方法调用方式">2.能够掌握static关键字修饰的方法调用方式</h2>
<h3 id="1通过对象调用">1).通过“对象”调用：</h3>
<div><pre class="hljs"><code>v.getMax<span class="hljs-comment">(…)</span></code></pre></div>
<h3 id="2通过类名调用">2).通过“类名”调用：</h3>
<div><pre class="hljs"><code><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Var</span>.</span></span>get<span class="hljs-constructor">Max(…)</span>;</code></pre></div>
<h2 id="3能够写出接口的定义格式">3.能够写出接口的定义格式</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">IAnimal</span>{}</code></pre></div>
<h2 id="4能够写出接口的实现格式">4.能够写出接口的实现格式</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">Zi</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">IAnimal</span>{}</code></pre></div>
<h2 id="5能够说出接口中的成员特点">5.能够说出接口中的成员特点</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IAnimal</span></span>{
    <span class="hljs-comment">//JDK8(四种成员)</span>
    <span class="hljs-comment">//1.公有、静态、常量</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;
    <span class="hljs-comment">//2.公有、抽象方法</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>;
    <span class="hljs-comment">//3.公有、默认方法</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show1</span><span class="hljs-params">()</span></span>{
    }
    <span class="hljs-comment">//4.公有、静态方法【不能被子类继承】</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show2</span><span class="hljs-params">()</span></span>{
    }
}</code></pre></div>
<h2 id="6能够说出多态的前提">6.能够说出多态的前提</h2>
<p>必须要有“继承”/“实现”</p>
<h2 id="7能够写出多态的格式">7.能够写出多态的格式</h2>
<p>父类/父接口 变量名 = new 子类对象();</p>
<h2 id="8能够理解多态向上转型和向下转型">8.能够理解多态向上转型和向下转型</h2>
<div><pre class="hljs"><code><span class="hljs-number">1</span>).向上转型：多态
Animal a <span class="hljs-operator">=</span> new Cat()<span class="hljs-comment">;</span>
不能访问子类特有成员
<span class="hljs-number">2</span>).向下转型：
if(a instanceof Cat){
Cat c <span class="hljs-operator">=</span> (Cat)a<span class="hljs-comment">;</span>
可以访问子类特有成员
}</code></pre></div>
<h2 id="9能够说出内部类概念">9.能够说出内部类概念</h2>
<p>定义在另一个类内部的类，叫：内部类</p>
<h2 id="10能够理解匿名内部类的编写格式">10.能够理解匿名内部类的编写格式</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">new</span> <span class="hljs-type"></span>父类/父接口(){
<span class="hljs-comment">//子类类体</span>
}</code></pre></div>
</div>
      </article>
    </div>
  </body>
</html>
