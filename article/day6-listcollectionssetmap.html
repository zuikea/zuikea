<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta http-equiv="X-UA-Compatible" content="ie=edge" />
<link rel="stylesheet" href="/_assets/main.css" />

    <title>day6-List、Collections、Set、Map、冒泡排序 - zblog</title>
  <link rel="stylesheet" href="/_markdown_plugin_assets/highlight.js/atom-one-light.css" /></head>
  <body>
    <div class="main">
      <nav class="navigation">
        <a href="/">zblog</a>
      </nav>
      <article>
        <header>
          <h1 class="article-title">day6-List、Collections、Set、Map、冒泡排序</h1>
          <div class="article-info">
            <div>
              <span
                >Created At：<time datetime="1637919519440"
                  >2021-11-26 17:38</time
                ></span
              >
              <span
                >Updated At：<time datetime="1638180111648"
                  >2021-11-29 18:01</time
                ></span
              >
            </div>
            
          </div>
        </header>
        <div class="article-content markdown-body"><nav class="table-of-contents"><ul><li><a href="#学习目标">学习目标</a></li><li><a href="#第一章-list接口">第一章 List接口</a><ul><li><a href="#1list接口的概述">1.List接口的概述</a></li><li><a href="#2list接口中常用的方法重点">2.List接口中常用的方法(重点)</a></li><li><a href="#3arraylist集合数组">3.ArrayList集合(数组)</a></li><li><a href="#4linkedlist集合双向链表">4.LinkedList集合(双向链表)</a><ul><li><a href="#alinkedlist集合概述">a.LinkedList集合概述</a></li><li><a href="#blinkedlist集合特有的方法使用">b.LinkedList集合特有的方法(使用)</a></li></ul></li><li><a href="#5vector集合扩展-了解">5.Vector集合(扩展-了解)</a></li></ul></li><li><a href="#第二章-collections类">第二章 Collections类</a><ul><li><a href="#1collections的常用功能重点">1.Collections的常用功能(重点)</a></li><li><a href="#2comparator比较器重点">2.Comparator比较器(重点)</a></li><li><a href="#3对student进行排序指定排序的规则">3.对Student进行排序(指定排序的规则)</a></li><li><a href="#4可变参数">4.可变参数</a></li><li><a href="#5collections集合工具类中的方法addall">5.Collections集合工具类中的方法addAll</a></li></ul></li><li><a href="#第三章-set接口">第三章 Set接口</a><ul><li><a href="#1set接口的介绍记住">1.Set接口的介绍(记住)</a></li><li><a href="#2hashset集合的介绍和基本使用重点">2.HashSet集合的介绍和基本使用(重点)</a></li><li><a href="#3哈希值扩展-了解">3.哈希值(扩展-了解)</a></li><li><a href="#4string类的哈希值扩展-了解">4.String类的哈希值(扩展-了解)</a></li><li><a href="#5hashset集合存储数据的结构哈希表">5.HashSet集合存储数据的结构（哈希表）</a></li><li><a href="#6使用hashset集合存储string不重复的原理扩展-了解">6.使用HashSet集合存储String不重复的原理(扩展-了解)</a></li><li><a href="#7hashset存储自定义类型元素重点中的重点">7.HashSet存储自定义类型元素(重点中的重点)</a></li><li><a href="#2linkedhashset集合了解">2.LinkedHashSet集合(了解)</a></li><li><a href="#3treeset集合使用">3.TreeSet集合(使用)</a></li></ul></li><li><a href="#第四章-map集合">第四章 Map集合</a><ul><li><a href="#1map集合的概述">1.Map集合的概述</a></li><li><a href="#2map集合常用的子类">2.Map集合常用的子类</a></li><li><a href="#3map的常用方法重点">3.Map的常用方法(重点)</a></li><li><a href="#4map集合的遍历重点">4.Map集合的遍历(重点)</a><ul><li><a href="#1键找值的方式">1).键找值的方式</a><ul><li><a href="#概述">概述</a></li><li><a href="#代码实现">代码实现</a></li></ul></li><li><a href="#2键值对方式">2).键值对方式</a><ul><li><a href="#概述-1">概述</a></li><li><a href="#代码实现-1">代码实现</a></li></ul></li></ul></li><li><a href="#5hashmap存储自定义类型重点">5.HashMap存储自定义类型(重点)</a></li><li><a href="#6linkedhashmap集合了解">6.LinkedHashMap集合(了解)</a></li><li><a href="#7treemap集合了解">7.TreeMap集合(了解)</a></li><li><a href="#8hashtable集合扩展-了解">8.Hashtable集合(扩展-了解)</a></li><li><a href="#9map集合的练习">9.Map集合的练习</a><ul><li><a href="#需求">需求：</a></li><li><a href="#分析">分析:</a></li><li><a href="#代码实现-2">代码实现:</a></li></ul></li><li><a href="#10集合嵌套">10.集合嵌套</a><ul><li><a href="#1list嵌套list重点">1).List嵌套List(重点)</a></li><li><a href="#2list集合嵌套map集合了解">2).List集合嵌套Map集合(了解)</a></li><li><a href="#3map集合嵌套map集合了解">3).Map集合嵌套Map集合(了解)</a></li></ul></li></ul></li><li><a href="#第五章-斗地主综合案例重点">第五章 斗地主综合案例(重点)</a><ul><li><a href="#1需求分析">1.需求分析:</a></li><li><a href="#2代码实现">2.代码实现:</a></li></ul></li><li><a href="#第六章-冒泡排序重点">第六章 冒泡排序(重点)</a><ul><li><a href="#1原理">1.原理</a></li><li><a href="#2代码实现-1">2.代码实现</a></li></ul></li></ul></nav><h1 id="学习目标">学习目标</h1>
<div><pre class="hljs"><code>能够说出List集合特点
    <span class="hljs-number">1.</span>有序
    <span class="hljs-number">2.</span>允许存储重复的元素
    <span class="hljs-number">3.</span>有带索引的特有方法(练习 add,remove,set,get)
能够使用集合工具类
    Collections类:
        <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(List&lt;T&gt; list)</span> 根据元素的自然顺序 对指定列表按升序进行排序。
        <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(List&lt;T&gt; list, Comparator&lt;? <span class="hljs-built_in">super</span> T&gt; c)</span> 根据指定比较器产生的顺序对指定列表进行排序。
        <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shuffle</span><span class="hljs-params">(List&lt;?&gt; list)</span>  随机打乱集合中元素的顺序
能够使用Comparator比较器进行排序
    Collections.sort(list01, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() {
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> {
            <span class="hljs-comment">//降序: o2-o1  升序:o1-o2</span>
            <span class="hljs-keyword">return</span> o2-o1;
        }
    });
能够使用可变参数
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(<span class="hljs-type">int</span>...arr)</span>{}
    调用method方法,参数是一个可变参数,可以接收任意个同种数据类型的数据
    method(),method(<span class="hljs-number">10</span>),method(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>)...
能够说出Set集合的特点
    <span class="hljs-number">1.</span>不允许存储重复的元素
    <span class="hljs-number">2.</span>不包含带索引的方法
能够说出哈希表的特点
    JDK1<span class="hljs-number">.8</span>之前:数组+单向链表
    JDK1<span class="hljs-number">.8</span>之后:数组+单向链表|数组+红黑树
    查询的效率高
使用HashSet集合存储自定义元素(重点)
    想要保证存储的元素(Person对象,Student对象...)同名和同年龄的人视为同一个人
    自定义类型(Person对象,Student对象...)必须重写hashCode和equals方法</code></pre></div>
<h1 id="第一章-list接口">第一章 List接口</h1>
<h2 id="1list接口的概述">1.List接口的概述</h2>
<div><pre class="hljs"><code><span class="hljs-comment">/*
    java.uil.List&lt;E&gt;接口 extends Collection&lt;E&gt;接口
    List接口的特点:
        1.是一个有序的集合:存储元素和取出元素的顺序是一致的  存储:123  取出:123
        2.允许存储重复的元素  add(10)  add(10)
        3.包含一些带索引的特有方法
    List接口特有的带索引的方法:
        void add(int index, E element)  在指定索引处,添加一个新的元素
        E get(int index)  获取指定索引处的元素
        E remove(int index)  移除并返回指定索引处的元素,返回的就是被移除的元素
        E set(int index, E element)  替换并返回指定索引处的元素,返回的是被替换的元素
    注意:
        使用带索引的方法,必须防止索引越界异常(不要超过集合索引的使用范围:0--&gt;集合的长度-1)         
 */</span></code></pre></div>
<h2 id="2list接口中常用的方法重点">2.List接口中常用的方法(重点)</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo01List;

<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Iterator;
<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-comment">/*
    List接口中常用的方法(重点)
    IndexOutOfBoundsException:索引越界异常,一般集合会抛出
        StringIndexOutOfBoundsException:字符串索引越界异常
        ArrayIndexOutOfBoundsException:数组索引越界异常
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01List</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">//创建List集合对象</span>
        List&lt;String&gt; list =<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        list.add(<span class="hljs-string">"aaa"</span>);
        list.add(<span class="hljs-string">"bbb"</span>);
        list.add(<span class="hljs-string">"ccc"</span>);
        list.add(<span class="hljs-string">"aaa"</span>);
        list.add(<span class="hljs-string">"ddd"</span>);
        System.out.println(list);<span class="hljs-comment">//[aaa, bbb, ccc, aaa, ddd]</span>

        <span class="hljs-comment">//void add(int index, E element)  在指定索引处,添加一个新的元素</span>
        <span class="hljs-comment">//需求:在2索引处添加一个元素"你好"</span>
        list.add(<span class="hljs-number">2</span>,<span class="hljs-string">"你好"</span>);
        System.out.println(list);<span class="hljs-comment">//[aaa, bbb, 你好, ccc, aaa, ddd]</span>

        <span class="hljs-comment">//E get(int index)  获取指定索引处的元素</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">0</span>);
        System.out.println(<span class="hljs-string">"s1:"</span>+s1);<span class="hljs-comment">//s1:aaa</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">3</span>);
        System.out.println(<span class="hljs-string">"s2:"</span>+s2);<span class="hljs-comment">//s2:ccc</span>
        <span class="hljs-comment">//String s3 = list.get(10);//IndexOutOfBoundsException: Index: 10, Size: 6</span>

        <span class="hljs-comment">//E remove(int index)  移除并返回指定索引处的元素,返回的就是被移除的元素</span>
        <span class="hljs-comment">//需求:移除ccc和ddd之间的aaa</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> list.remove(<span class="hljs-number">4</span>);
        System.out.println(<span class="hljs-string">"s4:"</span>+s4);<span class="hljs-comment">//s4:aaa 被移除的元素</span>
        System.out.println(list);<span class="hljs-comment">//[aaa, bbb, 你好, ccc, ddd]</span>

        <span class="hljs-comment">//E set(int index, E element)  替换并返回指定索引处的元素,返回的是被替换的元素</span>
        <span class="hljs-comment">//需求:把"你好",替换为"大家好"</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">s5</span> <span class="hljs-operator">=</span> list.set(<span class="hljs-number">2</span>, <span class="hljs-string">"大家好"</span>);
        System.out.println(<span class="hljs-string">"s5:"</span>+s5);<span class="hljs-comment">//s5:你好 被替换的元素</span>
        System.out.println(list);<span class="hljs-comment">//[aaa, bbb, 大家好, ccc, ddd]</span>
        System.out.println(<span class="hljs-string">"-------------------使用普通for循环遍历------------------------"</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) {
            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> list.get(i);
            System.out.println(s);
        }
        System.out.println(<span class="hljs-string">"-------------------使用迭代器遍历------------------------"</span>);
        Iterator&lt;String&gt; it = list.iterator();
        <span class="hljs-keyword">while</span> (it.hasNext()){
            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> it.next();
            System.out.println(s);
        }
        System.out.println(<span class="hljs-string">"-------------------使用增强for循环遍历------------------------"</span>);
        <span class="hljs-keyword">for</span> (String s : list) {
            System.out.println(s);
        }
    }
}</code></pre></div>
<h2 id="3arraylist集合数组">3.ArrayList集合(数组)</h2>
<div><pre class="hljs"><code><span class="hljs-comment">/*
    java.util.ArrayList&lt;E&gt;集合 implements List&lt;E&gt;接口
    List 接口的大小可变数组的实现。
    ArrayList集合底层采用的就是数组结构:查询快,增删慢
    工作中:查询多的时候使用,不对集合的长度进行修改(添加,删除)
*/</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;E&gt;{
    <span class="hljs-keyword">transient</span> Object[] elementData = {};
    add方法:
    list.add(<span class="hljs-string">"aaa"</span>);	
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> {
        ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span>
        elementData[size++] = e;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
    ...
    <span class="hljs-comment">//add方法底层:创建一个新的数组,长度是源数组长度+1,把源数组中的元素使用System类中的arraycopy方法复制到新的数组中    </span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="hljs-type">int</span> newLength, Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">T</span>[]&gt; newType) {
        <span class="hljs-meta">@SuppressWarnings("unchecked")</span>
        T[] copy = ((Object)newType == (Object)Object[].class)
            ? (T[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[newLength]
            : (T[]) Array.newInstance(newType.getComponentType(), newLength);
        System.arraycopy(original, <span class="hljs-number">0</span>, copy, <span class="hljs-number">0</span>,
                         Math.min(original.length, newLength));
        <span class="hljs-keyword">return</span> copy;
    }   
    
}</code></pre></div>
<h2 id="4linkedlist集合双向链表">4.LinkedList集合(双向链表)</h2>
<h3 id="alinkedlist集合概述">a.LinkedList集合概述</h3>
<p><img src="/_resources/f31da0df0bfb44a18e3cb60f80094152.png" /></p>
<div><pre class="hljs"><code><span class="hljs-comment">/*
    java.util.LinkedList&lt;E&gt; implements List&lt;E&gt;接口
    List 接口的链接列表实现。
    LinkedList集合底层是一个双向链表:查询慢,增删快
    双向:是一个有序的集合
    LinkedList集合中含有一些操作链表首尾元素的方法:
        public void addFirst(E e) :将指定元素插入此列表的开头。
        public void push(E e) :将元素推入此列表所表示的堆栈。
        public void addLast(E e) :将指定元素添加到此列表的结尾。
        
        public E getFirst() :返回此列表的第一个元素。
        public E getLast() :返回此列表的最后一个元素。
        public boolean isEmpty() ：如果列表不包含元素，则返回true
        
        public E removeFirst() :移除并返回此列表的第一个元素。
        public E pop() :从此列表所表示的堆栈处弹出一个元素。
        public E removeLast() :移除并返回此列表的最后一个元素。

   注意:
   		使用LinkedList集合特有的方法,不能使用多态创建对象
   		List&lt;String&gt; list = new LinkedList&lt;&gt;();弊端:不能是实现类特有的方法
   		LinkedList&lt;String&gt; linked = (LinkedList&lt;String&gt;)list; 向下转型
   		Collection&lt;String&gt; list = new LinkedList&lt;&gt;();弊端:不能是实现类特有的方法
   		LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;();
*/</span></code></pre></div>
<h3 id="blinkedlist集合特有的方法使用">b.LinkedList集合特有的方法(使用)</h3>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo01List;

<span class="hljs-keyword">import</span> java.util.LinkedList;

<span class="hljs-comment">/*
    LinkedList集合特有的方法(使用)
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo02LinkedList</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        show04();
    }

    <span class="hljs-comment">/*
        public E removeFirst() :移除并返回此列表的第一个元素。
        public E pop() :从此列表所表示的堆栈处弹出一个元素。此方法等效于 removeFirst()。
        public E removeLast() :移除并返回此列表的最后一个元素。
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show04</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">//创建LinkedList集合对象</span>
        LinkedList&lt;String&gt; linked = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
        <span class="hljs-comment">//往集合中添加元素</span>
        linked.add(<span class="hljs-string">"aaa"</span>);
        linked.add(<span class="hljs-string">"bbb"</span>);
        linked.add(<span class="hljs-string">"ccc"</span>);
        linked.add(<span class="hljs-string">"ddd"</span>);
        System.out.println(linked);<span class="hljs-comment">//[aaa, bbb, ccc, ddd]</span>

        <span class="hljs-comment">//public E removeFirst() :移除并返回此列表的第一个元素。</span>
        <span class="hljs-comment">//String first = linked.removeFirst();</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> linked.pop();
        System.out.println(<span class="hljs-string">"first:"</span>+first);<span class="hljs-comment">//first:aaa</span>
        System.out.println(linked);<span class="hljs-comment">//[bbb, ccc, ddd]</span>

        <span class="hljs-comment">//public E removeLast() :移除并返回此列表的最后一个元素。</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> linked.removeLast();
        System.out.println(<span class="hljs-string">"last:"</span>+last);<span class="hljs-comment">//last:ddd</span>
        System.out.println(linked);<span class="hljs-comment">//[bbb, ccc]</span>
    }

    <span class="hljs-comment">/*
        public E getFirst() :返回此列表的第一个元素。
        public E getLast() :返回此列表的最后一个元素。
        public boolean isEmpty() ：如果列表不包含元素，则返回true
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show03</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">//创建LinkedList集合对象</span>
        LinkedList&lt;String&gt; linked = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
        <span class="hljs-comment">//往集合中添加元素</span>
        linked.add(<span class="hljs-string">"aaa"</span>);
        linked.add(<span class="hljs-string">"bbb"</span>);
        linked.add(<span class="hljs-string">"ccc"</span>);
        linked.add(<span class="hljs-string">"ddd"</span>);

        <span class="hljs-comment">//linked.clear();//清空集合</span>

        System.out.println(linked);<span class="hljs-comment">//[]</span>

        <span class="hljs-comment">//增加一个判断,集合不是空的,在获取首尾元素,防止NoSuchElementException:没有这个元素异常</span>
        <span class="hljs-keyword">if</span>(!linked.isEmpty()){
            <span class="hljs-comment">//public E getFirst() :返回此列表的第一个元素。</span>
            <span class="hljs-type">String</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> linked.getFirst();
            System.out.println(<span class="hljs-string">"first:"</span>+first);<span class="hljs-comment">//first:aaa</span>

            <span class="hljs-comment">//public E getLast() :返回此列表的最后一个元素。</span>
            <span class="hljs-type">String</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> linked.getLast();
            System.out.println(<span class="hljs-string">"last:"</span>+last);
        }

    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show02</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">//创建LinkedList集合对象</span>
        LinkedList&lt;String&gt; linked = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
        linked.addFirst(<span class="hljs-string">"a"</span>);
        linked.addFirst(<span class="hljs-string">"b"</span>);
        linked.addFirst(<span class="hljs-string">"c"</span>);
        linked.addLast(<span class="hljs-string">"1"</span>);
        linked.addLast(<span class="hljs-string">"2"</span>);
        linked.addLast(<span class="hljs-string">"3"</span>);
        System.out.println(linked);<span class="hljs-comment">//[c, b, a, 1, 2, 3]</span>
    }

    <span class="hljs-comment">/*
        public void addFirst(E e) :将指定元素插入此列表的开头。
        public void push(E e) :将元素推入此列表所表示的堆栈。此方法等效于 addFirst(E)。
        public void addLast(E e) :将指定元素添加到此列表的结尾。
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show01</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">//创建LinkedList集合对象</span>
        LinkedList&lt;String&gt; linked = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
        <span class="hljs-comment">//往集合中添加元素</span>
        linked.add(<span class="hljs-string">"aaa"</span>);
        linked.add(<span class="hljs-string">"bbb"</span>);
        linked.add(<span class="hljs-string">"ccc"</span>);
        linked.add(<span class="hljs-string">"ddd"</span>);
        System.out.println(linked);<span class="hljs-comment">//[aaa, bbb, ccc, ddd]</span>

        <span class="hljs-comment">//public void addFirst(E e) :将指定元素插入此列表的开头。</span>
        <span class="hljs-comment">//linked.addFirst("www");</span>
        linked.push(<span class="hljs-string">"www"</span>);
        System.out.println(linked);<span class="hljs-comment">//[www, aaa, bbb, ccc, ddd]</span>

        <span class="hljs-comment">//public void addLast(E e) :将指定元素添加到此列表的结尾。</span>
        linked.addLast(<span class="hljs-string">"com"</span>);
        System.out.println(linked);<span class="hljs-comment">//[www, aaa, bbb, ccc, ddd, com]</span>
    }
}
</code></pre></div>
<h2 id="5vector集合扩展-了解">5.Vector集合(扩展-了解)</h2>
<div><pre class="hljs"><code><span class="hljs-comment">/*
    java.util.Vector&lt;E&gt; implements List&lt;E&gt;(jdk1.2之后)
    Vector是JDK1.0时期存在的单列集合,Collection下边的其他集合(ArrayList,LinkedList...)是JDK1.2之后出现的
    Vector 类可以实现可增长的对象数组。Vector集合底层和ArrayList集合是一样的,也是一个数组结构(查询快,增删慢)
    Vector集合1.0时期有一些特有的方法:
    	void addElement(E obj)  往集合中添加元素
    	Enumeration&lt;E&gt; elements() 返回此向量的组件的枚举。 
    	Enumeration&lt;E&gt;接口:向量枚举,是1.0时期的迭代器
    		boolean hasMoreElements()  判断集合中还有没有元素==&gt;hasNext
    		E nextElement()  取出集合的元素==&gt;next
    与新 collection 实现不同，Vector 是同步的。 
    同步技术:可以保证多线程的安全
    同步技术:集合存储数据效率低
    所以Vector集合被效率更高的ArrayList集合取代了
*/</span></code></pre></div>
<h1 id="第二章-collections类">第二章 Collections类</h1>
<h2 id="1collections的常用功能重点">1.Collections的常用功能(重点)</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo02Collections;

<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Collections;

<span class="hljs-comment">/*
    java.util.Collections:操作集合的工具类,里边的方法都是静态的,通过类名可以直接调用
        sort:排序  升序:小==&gt;大  降序:大==&gt;小
        static void sort(List&lt;T&gt; list) 根据元素的自然顺序 对指定列表(集合)按升序进行排序。
        static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) 根据指定比较器产生的顺序对指定列表进行排序。
        static void shuffle(List&lt;?&gt; list) 随机打乱集合中元素的顺序
    注意:
        以上3个方法的参数只能传递List接口下的集合(ArrayList,LinkedList),不能传递Set接口下的集合
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01Collections</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        ArrayList&lt;Integer&gt; list01 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        list01.add(<span class="hljs-number">3</span>);
        list01.add(<span class="hljs-number">4</span>);
        list01.add(<span class="hljs-number">1</span>);
        list01.add(<span class="hljs-number">2</span>);
        System.out.println(list01);<span class="hljs-comment">//[3, 4, 1, 2]</span>

        <span class="hljs-comment">/*
            static void sort(List&lt;T&gt; list) 根据元素的自然顺序 对指定列表(集合)按升序进行排序。
         */</span>
        Collections.sort(list01);
        System.out.println(list01);<span class="hljs-comment">//[1, 2, 3, 4]</span>

        <span class="hljs-comment">/*
            static void shuffle(List&lt;?&gt; list) 随机打乱集合中元素的顺序
         */</span>
        Collections.shuffle(list01);
        System.out.println(list01);<span class="hljs-comment">//[4, 2, 3, 1] [3, 1, 2, 4] [4, 1, 2, 3]...</span>

        ArrayList&lt;String&gt; list02 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        list02.add(<span class="hljs-string">"ac"</span>);
        list02.add(<span class="hljs-string">"aa"</span>);
        list02.add(<span class="hljs-string">"12"</span>);
        list02.add(<span class="hljs-string">"AB"</span>);
        list02.add(<span class="hljs-string">"AA"</span>);
        System.out.println(list02);<span class="hljs-comment">//[ac, aa, 12, AB, AA]</span>

        <span class="hljs-comment">/*
            static void sort(List&lt;T&gt; list) 根据元素的自然顺序 对指定列表(集合)按升序进行排序。
            自然顺序:编码表的顺序  ASCII表
            48:'0'  65:'A'  97:'a'
         */</span>
        Collections.sort(list02);
        System.out.println(list02);<span class="hljs-comment">//[12, AA, AB, aa, ac]</span>
    }
}</code></pre></div>
<h2 id="2comparator比较器重点">2.Comparator比较器(重点)</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo02Collections;

<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Collections;
<span class="hljs-keyword">import</span> java.util.Comparator;

<span class="hljs-comment">/*
    static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) 根据指定比较器产生的顺序对指定列表进行排序。
    参数:
        List&lt;T&gt; list:传递要排序的List集合
        Comparator&lt;? super T&gt; c:比较器
    java.util.Comparator&lt;T&gt;接口:强行对某个对象 collection 进行整体排序 的比较函数。
    接口中的抽象方法:
        int compare(T o1, T o2) 比较用来排序的两个参数。
        T o1, T o2:依次获取到集合中相邻的元素,进行比较
    排序的规则:
        o1-o2:升序
        o2-o1:降序
        o1==o2:两个元素相等
    匿名内部类:没有名字的类中类
        简化代码:结果就是一个子类|实现类对象
            可以把子类继承父类,重写父类方法,创建子类对象合成一步完成
            可以把实现类实现接口,重写接口中的方法,创建实现类对象合成一步完成
        格式:
            new 爹(){
                重写父类|接口中的方法
            };
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo02Comparator</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        ArrayList&lt;Integer&gt; list01 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        list01.add(<span class="hljs-number">3</span>);
        list01.add(<span class="hljs-number">4</span>);
        list01.add(<span class="hljs-number">4</span>);
        list01.add(<span class="hljs-number">1</span>);
        list01.add(<span class="hljs-number">2</span>);
        System.out.println(list01);<span class="hljs-comment">//[3, 4, 1, 2]</span>

        <span class="hljs-comment">//static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) 根据指定比较器产生的顺序对指定列表进行排序。</span>
        Collections.sort(list01, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> {
                <span class="hljs-comment">//o2-o1:降序</span>
                <span class="hljs-keyword">return</span> o2-o1;
            }
        });
        System.out.println(list01);<span class="hljs-comment">//[4, 4, 3, 2, 1]</span>

        Collections.sort(list01, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> {
                <span class="hljs-comment">//o1-o2:升序</span>
                <span class="hljs-keyword">return</span> o1-o2;
            }
        });
        System.out.println(list01);<span class="hljs-comment">//[1, 2, 3, 4, 4]</span>

        ArrayList&lt;String&gt; list02 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        list02.add(<span class="hljs-string">"ac"</span>);
        list02.add(<span class="hljs-string">"aa"</span>);
        list02.add(<span class="hljs-string">"中"</span>);
        list02.add(<span class="hljs-string">"12"</span>);
        list02.add(<span class="hljs-string">"AB"</span>);
        list02.add(<span class="hljs-string">"AA"</span>);
        System.out.println(list02);<span class="hljs-comment">//[ac, aa, 12, AB, AA]</span>
        Collections.sort(list02, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;String&gt;() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(String o1, String o2)</span> {
                <span class="hljs-comment">//按照字符串的首字母降序排序</span>
                <span class="hljs-keyword">return</span> o2.charAt(<span class="hljs-number">0</span>)-o1.charAt(<span class="hljs-number">0</span>);
            }
        });
        <span class="hljs-comment">//System.out.println("ac".charAt(0)-"aa".charAt(0));</span>
        <span class="hljs-comment">//System.out.println('a'+0);//97</span>
        <span class="hljs-comment">//System.out.println('中'+0);//20013</span>
        System.out.println(list02);
    }
}</code></pre></div>
<h2 id="3对student进行排序指定排序的规则">3.对Student进行排序(指定排序的规则)</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo02Collections;

<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Collections;
<span class="hljs-keyword">import</span> java.util.Comparator;

<span class="hljs-comment">/*
    对学生Student进行排序
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo03Student</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        ArrayList&lt;Student&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">"azhagnsan"</span>,<span class="hljs-number">18</span>));
        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">"lisi"</span>,<span class="hljs-number">20</span>));
        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">"wangwu"</span>,<span class="hljs-number">22</span>));
        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">"bzhaoliu"</span>,<span class="hljs-number">18</span>));
        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">"tianqi"</span>,<span class="hljs-number">21</span>));
        Collections.sort(list, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Student&gt;() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Student o1, Student o2)</span> {
                <span class="hljs-comment">//按照学生的年龄升序排序</span>
                <span class="hljs-keyword">return</span> o1.getAge()-o2.getAge();
            }
        });
        <span class="hljs-keyword">for</span> (Student s : list) {
            System.out.println(s);
        }
        Collections.sort(list, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Student&gt;() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Student o1, Student o2)</span> {
                <span class="hljs-comment">//按照学生的年龄升序排序</span>
                <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span>  o1.getAge()-o2.getAge();
                <span class="hljs-keyword">if</span>(a==<span class="hljs-number">0</span>){
                    <span class="hljs-comment">//两个学生年龄相等,按照姓名的首字母降序排序</span>
                    <span class="hljs-comment">//a=o2.getName().charAt(0)-o1.getName().charAt(0);</span>
                    <span class="hljs-comment">//按照姓名降序排序==&gt;String类</span>
                    <span class="hljs-comment">//int compareTo(String anotherString)按字典(编码表)顺序比较两个字符串。依次比较每一个字符</span>
                    a = o2.getName().compareTo(o1.getName());
                }
                <span class="hljs-keyword">return</span> a;
            }
        });
        System.out.println(<span class="hljs-string">"---------------------------------"</span>);
        <span class="hljs-keyword">for</span> (Student s : list) {
            System.out.println(s);
        }
    }
}</code></pre></div>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo02Collections;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> {
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> {
    }

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> {
        <span class="hljs-built_in">this</span>.name = name;
        <span class="hljs-built_in">this</span>.age = age;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Student{"</span> +
                <span class="hljs-string">"name='"</span> + name + <span class="hljs-string">'\''</span> +
                <span class="hljs-string">", age="</span> + age +
                <span class="hljs-string">'}'</span>;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> {
        <span class="hljs-built_in">this</span>.name = name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> age;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> {
        <span class="hljs-built_in">this</span>.age = age;
    }
}</code></pre></div>
<h2 id="4可变参数">4.可变参数</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo03varArgs;

<span class="hljs-comment">/*
    可变参数:
        当我们定义一个方法,方法参数列表的参数的类型已经确定了,但是个数不确定,就可以使用可变参数
        是JDK1.5之后出现的
    格式:
        修饰符 返回值类型 方法名(数据类型...变量名){
            方法体;
        }
    数据类型...变量名==&gt;可变参数
    int...a:可以接收任意个int类型的整数
    String...b:可以接收任意个String类型的整数
    底层原理:
        可以参数的底层就是一个数组,传递不同个数个参数,会创建不同长度的数组,来存储数据
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01VarArgs</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">//getSum();</span>
        <span class="hljs-comment">//getSum(10);</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> getSum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);
        System.out.println(<span class="hljs-string">"s1:"</span>+s1);
        <span class="hljs-comment">//int sum = getSum(10, 20, 30, 40, 50, 60, 70, 80, 90, 100);</span>
        <span class="hljs-comment">//System.out.println(sum);//550</span>
    }

    <span class="hljs-comment">/*
        定义一个计算n个int类型整数和的方法
            n个:0个,1个,2个,3个,100个...1000个...100000个...
        需求:
            数据类型确定:int
            参数个数不确定:n个
        使用可变参数解决:可以接收任意个
        getSum();传递0个参数,可变参数就会创建一个长度为0的数组,存储数据 int[] arr = new int[]{ };
        getSum(10);传递1个参数,可变参数就会创建一个长度为1的数组,存储数据 int[] arr = new int[]{10};
        getSum(10,20);传递2个参数,可变参数就会创建一个长度为2的数组,存储数据 int[] arr = new int[]{10,20};
        ...
        getSum(10,20,30,40,50,60,70,80,90,100);传递10个参数
            可变参数就会创建一个长度为10的数组,存储数据 int[] arr = new int[]{10,20,30,40,50,60,70,80,90,100};
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSum</span><span class="hljs-params">(<span class="hljs-type">int</span>...arr)</span>{
        <span class="hljs-comment">//System.out.println(arr);//[I@4554617c</span>
        <span class="hljs-comment">//System.out.println(arr.length);//0,1,2</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : arr) {
            sum+=i;
        }
        <span class="hljs-keyword">return</span> sum;
    }

    <span class="hljs-comment">/*
        定义一个计算四个int类型整数和的方法
     */</span>
    <span class="hljs-comment">/*public static int getSum(int a,int b,int c,int d){
        return a+b+c+d;
    }*/</span>

    <span class="hljs-comment">/*
        定义一个计算三个int类型整数和的方法
     */</span>
    <span class="hljs-comment">/*public static int getSum(int a,int b,int c){
        return a+b+c;
    }*/</span>

    <span class="hljs-comment">/*
        定义一个计算两个int类型整数和的方法
     */</span>
    <span class="hljs-comment">/*public static int getSum(int a,int b){
        return a+b;
    }*/</span>
}</code></pre></div>
<p><strong>重点:记住可变参数可以接收任意个同种数据类型的元素</strong></p>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo03varArgs;

<span class="hljs-comment">/*
    可变参数的注意事项(了解)
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo02VarArgs</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        show04(<span class="hljs-number">10</span>,<span class="hljs-number">1.1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-string">"aa"</span>);
    }
    
    <span class="hljs-comment">//1.一个方法的参数列表如果有多个参数,可变参数必须写在末尾</span>
    <span class="hljs-comment">//Vararg parameter must be the last in the list</span>
    <span class="hljs-comment">//public static void show01(int a,double b,int...d,String s){}</span>
    
    <span class="hljs-comment">//2.一个方法的参数列表,只能写一个可变参数</span>
    <span class="hljs-comment">//public static void show02(String...s,int...a){}</span>
    
    <span class="hljs-comment">//以后查看源码可以看到</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show03</span><span class="hljs-params">(Object...obj)</span>{}
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T[] show04(T...t){
        <span class="hljs-keyword">return</span> t;
    }
}</code></pre></div>
<h2 id="5collections集合工具类中的方法addall">5.Collections集合工具类中的方法addAll</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo03varArgs;

<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Collections;

<span class="hljs-comment">/*
    Collections集合工具类中的方法addAll
    static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt; c, T... elements)
          将所有指定元素添加到指定 collection 中。
          一次往集合中添加多个元素
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo03Collections</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        list.add(<span class="hljs-number">1</span>);
        list.add(<span class="hljs-number">2</span>);
        list.add(<span class="hljs-number">3</span>);
        list.add(<span class="hljs-number">4</span>);
        list.add(<span class="hljs-number">5</span>);
        System.out.println(list);

        ArrayList&lt;Integer&gt; list02 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        Collections.addAll(list02,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>);
        System.out.println(list02);

        <span class="hljs-comment">//可变参数底层就是一个数组,所以可以传递可变参数的地方,都可以传递数组</span>
        Integer[] arr = {<span class="hljs-number">100</span>,<span class="hljs-number">200</span>,<span class="hljs-number">300</span>,<span class="hljs-number">400</span>,<span class="hljs-number">500</span>};
        Collections.addAll(list02,arr);
        System.out.println(list02);<span class="hljs-comment">//[1, 2, 3, 4, 5, 100, 200, 300, 400, 500]</span>
    }
}</code></pre></div>
<h1 id="第三章-set接口">第三章 Set接口</h1>
<h2 id="1set接口的介绍记住">1.Set接口的介绍(记住)</h2>
<div><pre class="hljs"><code><span class="hljs-comment">/*
    java.util.Set&lt;E&gt;接口 extends Collection&lt;E&gt;接口
    Set接口的特点:
        1.不允许存储重复的元素  add(1) add(1) ==&gt;集合中只有一个1
        2.不包含带索引的方法,里边的方法和Collection接口是一样
*/</span></code></pre></div>
<h2 id="2hashset集合的介绍和基本使用重点">2.HashSet集合的介绍和基本使用(重点)</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo04Set;

<span class="hljs-keyword">import</span> java.util.Collections;
<span class="hljs-keyword">import</span> java.util.HashSet;
<span class="hljs-keyword">import</span> java.util.Iterator;

<span class="hljs-comment">/*
    java.util.HashSet&lt;E&gt;集合 implements Set&lt;E&gt;接口
        此类实现 Set 接口，由哈希表（实际上是一个 HashMap 实例）支持。
        它不保证 set 的迭代顺序；特别是它不保证该顺序恒久不变。
    HashSet集合的特点:
        1.不允许存储重复的元素
        2.不包含带索引的方法(不能使用普通for循环遍历)
        3.底层是一个哈希表结构
            JDK1.8之前:数组+单向链表
            JDK1.8以后:数组+单向链表|数组+红黑树
        4.是一个无序的集合(存储的元素和取出元素顺序[有可能]不一致)
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01HashSet</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        HashSet&lt;String&gt; set1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();
        set1.add(<span class="hljs-string">"aaa"</span>);
        set1.add(<span class="hljs-string">"bbb"</span>);
        set1.add(<span class="hljs-string">"ccc"</span>);
        set1.add(<span class="hljs-string">"aaa"</span>);
        set1.add(<span class="hljs-string">"ddd"</span>);
        System.out.println(set1);<span class="hljs-comment">//[aaa, ccc, bbb, ddd]</span>
        <span class="hljs-comment">//使用迭代器遍历HashSet集合</span>
        Iterator&lt;String&gt; it = set1.iterator();
        <span class="hljs-keyword">while</span> (it.hasNext()){
            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> it.next();
            System.out.println(s);
        }
        System.out.println(<span class="hljs-string">"------------------------"</span>);
        HashSet&lt;Integer&gt; set2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();
        Collections.addAll(set2,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);
        System.out.println(set2);<span class="hljs-comment">//[1, 2, 3, 4, 5]</span>
        <span class="hljs-comment">//使用增强for循环遍历HashSet集合</span>
        <span class="hljs-keyword">for</span> (Integer in : set2) {
            System.out.println(in);
        }
    }
}</code></pre></div>
<h2 id="3哈希值扩展-了解">3.哈希值(扩展-了解)</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo04Set;

<span class="hljs-comment">/*
    哈希值:
        是一个十进制的整数,由操作系统随机给出,我们打印对象的地址值,使用的就是哈希值(逻辑地址)
        对象在内存中实际存储的地址,并不是哈希值的地址(物理地址)
    Object类有获取对象哈希值的方法:
        int hashCode() 返回该对象的哈希码值。
        hashCode方法的底层源码:
            public native int hashCode();
            native:调用的是操作系统底层的方法,不是由java语言编写的
   Object类的toString方法
        String toString() 返回该对象的字符串表示。
    底层源码:
        public String toString() {
            return getClass().getName() + "@" + Integer.toHexString(hashCode());
        }
        getClass().getName():使用反射技术,获取包名+类名  com.itheima.demo04Set.Person
        "@":字符串原样输出
        Integer.toHexString(hashCode()):把hashCode方法返回的十进制的整数,转换为十六进制
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo02HashCode</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();
        <span class="hljs-type">int</span> <span class="hljs-variable">h1</span> <span class="hljs-operator">=</span> p1.hashCode();
        System.out.println(h1);<span class="hljs-comment">//1163157884==&gt;重写后 1</span>
        System.out.println(p1.toString());<span class="hljs-comment">//com.itheima.demo04Set.Person@4554617c==&gt;重写后 1</span>
        <span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();
        <span class="hljs-type">int</span> <span class="hljs-variable">h2</span> <span class="hljs-operator">=</span> p2.hashCode();
        System.out.println(h2);<span class="hljs-comment">//1956725890==&gt;重写后 1</span>
        System.out.println(p2.toString());<span class="hljs-comment">//com.itheima.demo04Set.Person@74a14482==&gt;重写后 1</span>
        System.out.println(p1==p2);<span class="hljs-comment">//false 引用数据类型比较的是对象的地址值</span>
    }
}</code></pre></div>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo04Set;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Object</span>{
    <span class="hljs-comment">//重写Object类的hashCode方法</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }
}
</code></pre></div>
<h2 id="4string类的哈希值扩展-了解">4.String类的哈希值(扩展-了解)</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo04Set;

<span class="hljs-comment">/*
    String类的哈希值(了解)
        String类重写了Object类的hashCode方法
        规则:
            相同的字符串返回的哈希值是一样的
            不同的字符串,计算出的哈希值也有可能是一样
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo03StringHashCode</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"abc"</span>);
        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"abc"</span>);
        System.out.println(s1.hashCode());<span class="hljs-comment">//96354</span>
        System.out.println(s2.hashCode());<span class="hljs-comment">//96354</span>
        System.out.println(s1==s2);<span class="hljs-comment">//false</span>

        System.out.println(<span class="hljs-string">"重地"</span>.hashCode());<span class="hljs-comment">//1179395</span>
        System.out.println(<span class="hljs-string">'重'</span>+<span class="hljs-number">0</span>);<span class="hljs-comment">//37325</span>
        System.out.println(<span class="hljs-string">'地'</span>+<span class="hljs-number">0</span>);<span class="hljs-comment">//22320</span>

        System.out.println(<span class="hljs-string">"通话"</span>.hashCode());<span class="hljs-comment">//1179395</span>
    }
}</code></pre></div>
<p><img src="/_resources/1a9e506db1dc4da79034adeb690fb0d0.png" /></p>
<h2 id="5hashset集合存储数据的结构哈希表">5.HashSet集合存储数据的结构（哈希表）</h2>
<p><img src="/_resources/2323d60ece8a4fd383a7fd45bfa9ea27.png" /></p>
<h2 id="6使用hashset集合存储string不重复的原理扩展-了解">6.使用HashSet集合存储String不重复的原理(扩展-了解)</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo04Set;

<span class="hljs-keyword">import</span> java.util.HashSet;

<span class="hljs-comment">/*
    使用HashSet集合存储String不重复的原理(扩展-了解)
    String类重写了hashCode和equals方法,保证元素唯一
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo04HashSetSaveString</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        HashSet&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();
        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"abc"</span>);
        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"abc"</span>);
        set.add(s1);
        set.add(s2);
        set.add(<span class="hljs-string">"重地"</span>);
        set.add(<span class="hljs-string">"通话"</span>);
        set.add(<span class="hljs-string">"abc"</span>);
        System.out.println(set);<span class="hljs-comment">//[重地, 通话, abc]</span>
    }
}</code></pre></div>
<p><img src="/_resources/1e8412be46634fe88622e1e5a17c4c06.png" /></p>
<h2 id="7hashset存储自定义类型元素重点中的重点">7.HashSet存储自定义类型元素(重点中的重点)</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo04Set;

<span class="hljs-keyword">import</span> java.util.HashSet;

<span class="hljs-comment">/*
    HashSet存储自定义类型元素(重点中的重点)
    需求:
        同名同年龄的学生,认为是同一个学生,只能存储一次
    解决:
        自定义类型(Student,Person,Animal...),需要重写hashCode和equals方法,保证元素唯一
        alt+insert==&gt;选择equals and hashCode
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo05HashSetSaveStudent</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">//创建一个HashSet集合,泛型使用Student</span>
        HashSet&lt;Student&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();
        <span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">"a"</span>,<span class="hljs-number">10</span>);
        <span class="hljs-type">Student</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">"a"</span>,<span class="hljs-number">10</span>);
        System.out.println(s1.hashCode());<span class="hljs-comment">//1163157884==&gt;重写后107</span>
        System.out.println(s2.hashCode());<span class="hljs-comment">//1956725890==&gt;重写后107</span>
        set.add(s1);
        set.add(s2);
        <span class="hljs-type">Student</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">"b"</span>,<span class="hljs-number">9</span>);
        System.out.println(s3.hashCode());
        set.add(s3);
        <span class="hljs-keyword">for</span> (Student s : set) {
            System.out.println(s.getName()+<span class="hljs-string">"\t"</span>+s.getAge());
        }
    }
}</code></pre></div>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo04Set;

<span class="hljs-keyword">import</span> java.util.Objects;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> {
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> {
    }

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> {
        <span class="hljs-built_in">this</span>.name = name;
        <span class="hljs-built_in">this</span>.age = age;
    }

    <span class="hljs-comment">/*
        重写Object类中hashCode方法
        重写的规则:name本身就是一个字符串,直接调用字符串重写的hashCode方法+age
            name.hashCode()+age;
        --------------------------------------------------
        Student s1 = new Student("a",10); 哈希值:97+10=107
        Student s2 = new Student("a",10); 哈希值:97+10=107
        set.add(s1); 在集合中找,有没有107这个哈希值,发现没有,就会把s1存储到HashSet集合中
        set.add(s2); 在集合中找,有没有107这个哈希值,发现有, s2.equals(s1)==&gt;true
            两个元素哈希值相同,equals方法返回true,认定s2和s1完全相同,就不会把s2存储到HashSet集合中
        --------------------------------------------------
        Student s3 = new Student("b",9);哈希值:98+9=107
        set.add(s3);在集合中找,有没有107这个哈希值,发现有, s3.equals(s1)==&gt;false
            两个元素哈希值相同,equals方法返回false,认定s3和s1不同,就会把s3存储到HashSet集合中
        --------------------------------------------------
        降低不同元素,出现相同哈希值的概率
        name.hashCode()*2+age;
        Student s1 = new Student("a",10); 哈希值:97*2+10=194+10=204
        Student s3 = new Student("b",9);哈希值:98*2+9=196+9=205
        set.add(s3);在集合中找,有没有205这个哈希值,发现没有,直接把s3存储到HashSet集合中
        sun公司经过无数次计算,任意倍数扩大31被,重复的几率是最低
        name.hashCode()*31+age;
     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> (Student) o;
        <span class="hljs-type">return</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span>= student.age &amp;&amp;
                Objects.equals(name, student.name);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> Objects.hash(name, age);
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> {
        <span class="hljs-built_in">this</span>.name = name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> age;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> {
        <span class="hljs-built_in">this</span>.age = age;
    }
}</code></pre></div>
<p><img src="/_resources/40deb9479ce449cd96543562238e131d.png" /></p>
<h2 id="2linkedhashset集合了解">2.LinkedHashSet集合(了解)</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo04Set;

<span class="hljs-keyword">import</span> java.util.HashSet;
<span class="hljs-keyword">import</span> java.util.LinkedHashSet;

<span class="hljs-comment">/*
    java.util.LinkedHashSet&lt;E&gt;集合 extends HashSet&lt;E&gt;集合 implements Set&lt;E&gt;接口
        具有可预知迭代顺序的 Set 接口的哈希表和链接列表实现。
        此实现与 HashSet 的不同之外在于，后者维护着一个运行于所有条目的双重链接列表。
    LinkedHashSet特点:
        1.不允许存储重复元素
        2.不包含带索引的方法
        3.是一个有序的集合
        4.底层是哈希表+单向链表
            JDK1.8之前:数组+单向链表+单向链表
            JDK1.8之后:数组+单向链表+单向链表|数组+红黑树+单向链表
            底层就是一个双向链表的结构,是一个有序的集合
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo06LinkedHashSet</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        HashSet&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();
        set.add(<span class="hljs-string">"aaa"</span>);
        set.add(<span class="hljs-string">"bbb"</span>);
        set.add(<span class="hljs-string">"ccc"</span>);
        set.add(<span class="hljs-string">"aaa"</span>);
        set.add(<span class="hljs-string">"ddd"</span>);
        System.out.println(set);<span class="hljs-comment">//[aaa, ccc, bbb, ddd] 不允许存储重复元素,是一个无序的集合</span>

        LinkedHashSet&lt;String&gt; linked = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;();
        linked.add(<span class="hljs-string">"aaa"</span>);
        linked.add(<span class="hljs-string">"bbb"</span>);
        linked.add(<span class="hljs-string">"ccc"</span>);
        linked.add(<span class="hljs-string">"aaa"</span>);
        linked.add(<span class="hljs-string">"ddd"</span>);
        System.out.println(linked);<span class="hljs-comment">//[aaa, bbb, ccc, ddd] 不允许存储重复元素,是一个有序的集合</span>
    }
}</code></pre></div>
<h2 id="3treeset集合使用">3.TreeSet集合(使用)</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo04Set;

<span class="hljs-keyword">import</span> java.util.Comparator;
<span class="hljs-keyword">import</span> java.util.TreeSet;

<span class="hljs-comment">/*
    java.util.TreeSet&lt;E&gt;集合 implements Set&lt;E&gt;接口
        基于Set接口的红黑树的实现
        使用元素的自然顺序对元素进行排序(内部会使用Comparator比较器对元素进行默认的升序排序)
        或者根据创建TreeSet集合时提供的 Comparator 进行排序，具体取决于使用的构造方法。
    构造方法:
        TreeSet() 构造一个新的空 set，该 set 根据其元素的自然顺序进行排序。
        TreeSet(Comparator&lt;? super E&gt; comparator) 构造一个新的空 TreeSet，它根据指定比较器进行排序。
     TreeSet集合特点:
        1.不允许存储重复元素
        2.没有带索引的方法
        3.底层是一个红黑树结构(元素是有序的)
        4.可以根据比较器产生的规则对元素进行排序
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo07TreeSet</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">//使用空参数构造方法,创建TreeSet集合对象</span>
        TreeSet&lt;Integer&gt; set1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;();
        set1.add(<span class="hljs-number">1</span>);
        set1.add(<span class="hljs-number">3</span>);
        set1.add(<span class="hljs-number">3</span>);
        set1.add(<span class="hljs-number">2</span>);
        set1.add(<span class="hljs-number">5</span>);
        set1.add(<span class="hljs-number">4</span>);
        System.out.println(set1);<span class="hljs-comment">//[1, 2, 3, 4, 5]</span>

        <span class="hljs-comment">//使用带比较器构造方法,创建TreeSet集合对象</span>
        TreeSet&lt;Integer&gt; set2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> {
                <span class="hljs-comment">//o1-o2:升序  o2-o1:降序</span>
                <span class="hljs-keyword">return</span> o2-o1;
            }
        });
        set2.add(<span class="hljs-number">1</span>);
        set2.add(<span class="hljs-number">3</span>);
        set2.add(<span class="hljs-number">3</span>);
        set2.add(<span class="hljs-number">2</span>);
        set2.add(<span class="hljs-number">5</span>);
        set2.add(<span class="hljs-number">4</span>);
        System.out.println(set2);<span class="hljs-comment">//[5, 4, 3, 2, 1]</span>
    }
}</code></pre></div>
<h1 id="第四章-map集合">第四章 Map集合</h1>
<h2 id="1map集合的概述">1.Map集合的概述</h2>
<div><pre class="hljs"><code>java.util.Map&lt;k,v&gt;:接口  key:键 value:值
特点:
    <span class="hljs-number">1.</span>Map集合是一个双列集合,每个元素包含两个值,一个key一个value
    <span class="hljs-number">2.</span>Map集合中的key是不允许重复的,value可以重复
    <span class="hljs-number">3.</span>Map集合中一个key只能对应一个value
    <span class="hljs-number">4.</span>Map集合中key和value数据类型可以是相同的,也可以是不同</code></pre></div>
<p><img src="/_resources/62e5cb8648864bf6af04764060df9802.png" /></p>
<h2 id="2map集合常用的子类">2.Map集合常用的子类</h2>
<div><pre class="hljs"><code><span class="hljs-number">1.</span>java.util.HashMap&lt;K,V&gt;集合 <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>&lt;K,V&gt;接口
    基于哈希表的 Map 接口的实现。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。
    a.HashMap集合底层是一个哈希表结构和HashSet是一样
    b.是一个无序集合
<span class="hljs-number">2.</span>java.util.LinkedHashMap&lt;K,V&gt;集合 <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HashMap</span>&lt;K,V&gt;集合
    Map 接口的哈希表和链接列表实现，具有可预知的迭代顺序。此实现与 HashMap 的不同之处在于，后者维护着一个运行于所有条目的双重链接列表。
    a.LinkedHashMap集合底层是哈希表+单向链表和LinkedHashSet是一样
    b.是一个有序的集合
<span class="hljs-number">3.</span>java.util.TreeMap&lt;K,V&gt;集合 <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>&lt;K,V&gt;接口
    基于红黑树（Red-Black tree）的 NavigableMap 实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。
    a.TreeMap底层是一个红黑树结构
    b.TreeMap集合自带了一个比较器,里边存储的key是有序的:默认是升序或者可以根据比较器自定义排序规则
       和TreeSet是一样</code></pre></div>
<h2 id="3map的常用方法重点">3.Map的常用方法(重点)</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo01Map;

<span class="hljs-keyword">import</span> java.util.Collection;
<span class="hljs-keyword">import</span> java.util.HashMap;
<span class="hljs-keyword">import</span> java.util.Map;
<span class="hljs-keyword">import</span> java.util.Set;

<span class="hljs-comment">/*
    Map的常用方法(重点)
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01Map</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        show05();
    }

    <span class="hljs-comment">/*
        Set&lt;K&gt; keySet() 把Map集合中所有的key取出来,存储到一个Set集合中
        Collection&lt;V&gt; values() 把Map集合中所有的value取出来,存储到一个Collection集合中
        int size() 返回Map集合中键值对个数
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show05</span><span class="hljs-params">()</span> {
        Map&lt;String,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
        map.put(<span class="hljs-string">"迪丽热巴"</span>,<span class="hljs-number">168</span>);
        map.put(<span class="hljs-string">"古力娜扎"</span>,<span class="hljs-number">165</span>);
        map.put(<span class="hljs-string">"冯提莫"</span>,<span class="hljs-number">150</span>);
        map.put(<span class="hljs-string">"林志玲"</span>,<span class="hljs-number">178</span>);
        Set&lt;String&gt; set = map.keySet();
        System.out.println(set);<span class="hljs-comment">//[林志玲, 迪丽热巴, 冯提莫, 古力娜扎]</span>
        Collection&lt;Integer&gt; coll = map.values();
        System.out.println(coll);<span class="hljs-comment">//[178, 168, 150, 165]</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> map.size();
        System.out.println(size);<span class="hljs-comment">//4</span>
    }

    <span class="hljs-comment">/*
        boolean containsKey(Object key)  判断集合中是否包含指定的key
            返回值:boolean
                包含指定的key,返回true
                不包含指定的key,返回false
        boolean containsValue(Object value) 判断集合中是否包含指定的value(了解)
            返回值:boolean
                包含指定的value,返回true
                不包含指定的value,返回false
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show04</span><span class="hljs-params">()</span> {
        Map&lt;String,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
        map.put(<span class="hljs-string">"迪丽热巴"</span>,<span class="hljs-number">168</span>);
        map.put(<span class="hljs-string">"古力娜扎"</span>,<span class="hljs-number">165</span>);
        map.put(<span class="hljs-string">"冯提莫"</span>,<span class="hljs-number">150</span>);
        map.put(<span class="hljs-string">"林志玲"</span>,<span class="hljs-number">178</span>);
        System.out.println(map.containsKey(<span class="hljs-string">"冯提莫"</span>));<span class="hljs-comment">//true</span>
        System.out.println(map.containsKey(<span class="hljs-string">"胡歌"</span>));<span class="hljs-comment">//false</span>
        System.out.println(map.containsValue(<span class="hljs-number">165</span>));<span class="hljs-comment">//true</span>
        System.out.println(map.containsValue(<span class="hljs-number">210</span>));<span class="hljs-comment">//false</span>
    }

    <span class="hljs-comment">/*
        V remove(Object key) 根据key,移除集合中的键值对
        返回值:V
            集合中存在指定的key,移除键值对,返回被移除键值对中的值
            集合中不存在指定的key,返回null
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show03</span><span class="hljs-params">()</span> {
        Map&lt;String,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
        map.put(<span class="hljs-string">"迪丽热巴"</span>,<span class="hljs-number">168</span>);
        map.put(<span class="hljs-string">"古力娜扎"</span>,<span class="hljs-number">165</span>);
        map.put(<span class="hljs-string">"冯提莫"</span>,<span class="hljs-number">150</span>);
        map.put(<span class="hljs-string">"林志玲"</span>,<span class="hljs-number">178</span>);
        System.out.println(map);<span class="hljs-comment">//{林志玲=178, 迪丽热巴=168, 冯提莫=150, 古力娜扎=165}</span>
        <span class="hljs-type">Integer</span> <span class="hljs-variable">v1</span> <span class="hljs-operator">=</span> map.remove(<span class="hljs-string">"林志玲"</span>);
        System.out.println(<span class="hljs-string">"v1:"</span>+v1);<span class="hljs-comment">//v1:178</span>
        System.out.println(map);<span class="hljs-comment">//{迪丽热巴=168, 冯提莫=150, 古力娜扎=165}</span>

        <span class="hljs-type">Integer</span> <span class="hljs-variable">v2</span> <span class="hljs-operator">=</span> map.remove(<span class="hljs-string">"马尔扎哈"</span>);
        System.out.println(<span class="hljs-string">"v2:"</span>+v2);<span class="hljs-comment">//v2:null</span>
        System.out.println(map);<span class="hljs-comment">//{迪丽热巴=168, 冯提莫=150, 古力娜扎=165}</span>
    }

    <span class="hljs-comment">/*
        V get(Object key) 根据key获取value值
        返回值:V
            集合中存在指定的key,返回对应的value值
            集合中不存在指定的key,返回null
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show02</span><span class="hljs-params">()</span> {
        Map&lt;String,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
        map.put(<span class="hljs-string">"迪丽热巴"</span>,<span class="hljs-number">168</span>);
        map.put(<span class="hljs-string">"古力娜扎"</span>,<span class="hljs-number">165</span>);
        map.put(<span class="hljs-string">"冯提莫"</span>,<span class="hljs-number">150</span>);
        map.put(<span class="hljs-string">"林志玲"</span>,<span class="hljs-number">178</span>);
        System.out.println(map);<span class="hljs-comment">//{林志玲=178, 迪丽热巴=168, 冯提莫=150, 古力娜扎=165}</span>
        <span class="hljs-type">Integer</span> <span class="hljs-variable">v1</span> <span class="hljs-operator">=</span> map.get(<span class="hljs-string">"迪丽热巴"</span>);
        System.out.println(<span class="hljs-string">"v1:"</span>+v1);<span class="hljs-comment">//v1:168</span>

        <span class="hljs-type">Integer</span> <span class="hljs-variable">v2</span> <span class="hljs-operator">=</span> map.get(<span class="hljs-string">"林志颖"</span>);
        System.out.println(<span class="hljs-string">"v2:"</span>+v2);<span class="hljs-comment">//v2:null</span>
    }

    <span class="hljs-comment">/*
        V put(K key, V value) 往Map集合中添加键值对
        返回值:V
            添加的键值对中key不重复,V返回null
            添加的键值对中key重复,会使用新的值替换之前的值,返回V就是被替换的值
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show01</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">//创建Map集合对象</span>
        Map&lt;String,String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
        <span class="hljs-type">String</span> <span class="hljs-variable">v1</span> <span class="hljs-operator">=</span> map.put(<span class="hljs-string">"黄晓明"</span>, <span class="hljs-string">"赵薇"</span>);
        System.out.println(<span class="hljs-string">"v1:"</span>+v1);<span class="hljs-comment">//v1:null</span>
        System.out.println(map);<span class="hljs-comment">//{黄晓明=赵薇} map集合重写了toString方法</span>

        <span class="hljs-type">String</span> <span class="hljs-variable">v2</span> <span class="hljs-operator">=</span> map.put(<span class="hljs-string">"黄晓明"</span>, <span class="hljs-string">"杨颖"</span>);
        System.out.println(<span class="hljs-string">"v2:"</span>+v2);<span class="hljs-comment">//v2:赵薇</span>
        System.out.println(map);<span class="hljs-comment">//{黄晓明=杨颖}</span>

        map.put(<span class="hljs-string">"郭靖"</span>,<span class="hljs-string">"黄蓉"</span>);
        map.put(<span class="hljs-string">"杨过"</span>,<span class="hljs-string">"小龙女"</span>);
        map.put(<span class="hljs-string">"张无忌"</span>,<span class="hljs-string">"赵敏"</span>);
        map.put(<span class="hljs-string">"尹志平"</span>,<span class="hljs-string">"小龙女"</span>);
        System.out.println(map);<span class="hljs-comment">//{杨过=小龙女, 尹志平=小龙女, 郭靖=黄蓉, 张无忌=赵敏, 黄晓明=杨颖}</span>
    }
}</code></pre></div>
<h2 id="4map集合的遍历重点">4.Map集合的遍历(重点)</h2>
<h3 id="1键找值的方式">1).键找值的方式</h3>
<h4 id="概述">概述</h4>
<p><img src="/_resources/58d2dc101a3a4a7a857ceddccf44eb55.png" /></p>
<h4 id="代码实现">代码实现</h4>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo01Map;

<span class="hljs-keyword">import</span> java.util.HashMap;
<span class="hljs-keyword">import</span> java.util.Iterator;
<span class="hljs-keyword">import</span> java.util.Map;
<span class="hljs-keyword">import</span> java.util.Set;

<span class="hljs-comment">/*
    Map集合的遍历(重点)_键找值的方式
    使用Map接口中的方法:
        Set&lt;K&gt; keySet() 把Map集合中所有的key取出来,存储到一个Set集合中
        V get(Object key) 根据key获取value值
    实现步骤:
        1.使用keySet方法,把Map集合中所有的key取出来,存储到一个Set集合中
        2.遍历Set集合,获取Map集合中的每一个key
        3.使用Map集合中get方法,根据key获取value值
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo02Map</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        Map&lt;String,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
        map.put(<span class="hljs-string">"迪丽热巴"</span>,<span class="hljs-number">168</span>);
        map.put(<span class="hljs-string">"古力娜扎"</span>,<span class="hljs-number">165</span>);
        map.put(<span class="hljs-string">"冯提莫"</span>,<span class="hljs-number">150</span>);
        map.put(<span class="hljs-string">"林志玲"</span>,<span class="hljs-number">178</span>);
        <span class="hljs-comment">//1.使用keySet方法,把Map集合中所有的key取出来,存储到一个Set集合中</span>
        Set&lt;String&gt; set = map.keySet();
        <span class="hljs-comment">//2.遍历Set集合,获取Map集合中的每一个key</span>
        <span class="hljs-comment">//使用迭代器遍历Set集合</span>
        Iterator&lt;String&gt; it = set.iterator();
        <span class="hljs-keyword">while</span> (it.hasNext()){
            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> it.next();
            <span class="hljs-comment">//3.使用Map集合中get方法,根据key获取value值</span>
            <span class="hljs-type">Integer</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> map.get(key);
            System.out.println(key+<span class="hljs-string">"="</span>+value);
        }
        System.out.println(<span class="hljs-string">"----------------------------------"</span>);
        <span class="hljs-comment">//使用增强for循环遍历Set集合</span>
        <span class="hljs-keyword">for</span> (String key : set) {
            <span class="hljs-comment">//3.使用Map集合中get方法,根据key获取value值</span>
            <span class="hljs-type">Integer</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> map.get(key);
            System.out.println(key+<span class="hljs-string">"="</span>+value);
        }
    }
}
</code></pre></div>
<h3 id="2键值对方式">2).键值对方式</h3>
<h4 id="概述-2">概述</h4>
<p><img src="/_resources/91dfc024c9294fbbb3eddfcad94872ef.png" /></p>
<h4 id="代码实现-2">代码实现</h4>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo01Map;

<span class="hljs-keyword">import</span> java.util.HashMap;
<span class="hljs-keyword">import</span> java.util.Iterator;
<span class="hljs-keyword">import</span> java.util.Map;
<span class="hljs-keyword">import</span> java.util.Set;

<span class="hljs-comment">/*
    Map集合的遍历(重点)_键值对方式
    使用Map接口中的方法
        Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 取出Map集合中所有的Entry对象,存储到Set集合
    使用Entry接口中的方法:
        K getKey() 获取健
        V getValue() 获取值
    实现步骤:
        1.使用Map集合中的entrySet方法,取出Map集合中所有的Entry对象,存储到Set集合
        2.遍历Set集合,获取每一个Entry对象
        3.使用Entry对象中的方法getKey和getValue,分别获取键与值
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo03Map</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        Map&lt;String,String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
        map.put(<span class="hljs-string">"郭靖"</span>,<span class="hljs-string">"黄蓉"</span>);
        map.put(<span class="hljs-string">"杨过"</span>,<span class="hljs-string">"小龙女"</span>);
        map.put(<span class="hljs-string">"张无忌"</span>,<span class="hljs-string">"赵敏"</span>);
        map.put(<span class="hljs-string">"冷锋"</span>,<span class="hljs-string">"龙小云"</span>);
        <span class="hljs-comment">//1.使用Map集合中的entrySet方法,取出Map集合中所有的Entry对象,存储到Set集合</span>
        Set&lt;Map.Entry&lt;String, String&gt;&gt; set = map.entrySet();
        <span class="hljs-comment">//2.遍历Set集合,获取每一个Entry对象</span>
        <span class="hljs-comment">//使用迭代器遍历Set集合</span>
        Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = set.iterator();
        <span class="hljs-keyword">while</span> (it.hasNext()){
            Map.Entry&lt;String, String&gt; entry = it.next();
            <span class="hljs-comment">//3.使用Entry对象中的方法getKey和getValue,分别获取键与值</span>
            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> entry.getKey();
            <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> entry.getValue();
            System.out.println(key+<span class="hljs-string">"="</span>+value);
        }
        System.out.println(<span class="hljs-string">"------------------------"</span>);
        <span class="hljs-comment">//使用增强for遍历Set集合</span>
        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, String&gt; entry : set) {
            <span class="hljs-comment">//3.使用Entry对象中的方法getKey和getValue,分别获取键与值</span>
            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> entry.getKey();
            <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> entry.getValue();
            System.out.println(key+<span class="hljs-string">"="</span>+value);
        }
    }
}</code></pre></div>
<h2 id="5hashmap存储自定义类型重点">5.HashMap存储自定义类型(重点)</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo01Map;

<span class="hljs-keyword">import</span> java.util.HashMap;
<span class="hljs-keyword">import</span> java.util.Map;
<span class="hljs-keyword">import</span> java.util.Set;

<span class="hljs-comment">/*
    HashMap存储自定义类型(重点)
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo04HashMapSavePerson</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        show02();
    }

    <span class="hljs-comment">/*
        HashMap存储自定义类型(重点)
        key:使用Person类型,必须保证同名同年龄的人,视为同一个人,只能存储一次
            自定义类型,必须重写hashCode和equals
        value:使用String类型,可以重复
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show02</span><span class="hljs-params">()</span> {
        HashMap&lt;Person,String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
        map.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">"习大大"</span>,<span class="hljs-number">18</span>),<span class="hljs-string">"中国"</span>);
        map.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">"女王"</span>,<span class="hljs-number">18</span>),<span class="hljs-string">"英国"</span>);
        map.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">"普京"</span>,<span class="hljs-number">18</span>),<span class="hljs-string">"俄罗斯"</span>);
        map.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">"金三胖"</span>,<span class="hljs-number">8</span>),<span class="hljs-string">"朝鲜"</span>);
        map.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">"女王"</span>,<span class="hljs-number">18</span>),<span class="hljs-string">"毛里求斯"</span>);
        <span class="hljs-comment">//使用entrySet方法+增强for遍历Map集合</span>
        Set&lt;Map.Entry&lt;Person, String&gt;&gt; set = map.entrySet();
        <span class="hljs-keyword">for</span> (Map.Entry&lt;Person, String&gt; entry : set) {
            <span class="hljs-type">Person</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> entry.getKey();
            <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> entry.getValue();
            System.out.println(key+<span class="hljs-string">"==&gt;"</span>+value);
        }
    }

    <span class="hljs-comment">/*
        HashMap存储自定义类型(重点)
        key:使用String类型,key是不允许重复的
            String类重写了hashCode和equals方法,可以保证key的唯一
        value:Person类型,value可以重复
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show01</span><span class="hljs-params">()</span> {
        HashMap&lt;String,Person&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
        map.put(<span class="hljs-string">"中国"</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">"习大大"</span>,<span class="hljs-number">18</span>));
        map.put(<span class="hljs-string">"美国"</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">"特朗普"</span>,<span class="hljs-number">88</span>));
        map.put(<span class="hljs-string">"俄罗斯"</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">"普京"</span>,<span class="hljs-number">18</span>));
        map.put(<span class="hljs-string">"朝鲜"</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">"金三胖"</span>,<span class="hljs-number">3</span>));
        map.put(<span class="hljs-string">"美国"</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">"拜登"</span>,<span class="hljs-number">77</span>));
        <span class="hljs-comment">//使用keySet方法+增强for遍历Map集合</span>
        Set&lt;String&gt; set = map.keySet();
        <span class="hljs-keyword">for</span> (String key : set) {
            <span class="hljs-type">Person</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> map.get(key);
            System.out.println(key+<span class="hljs-string">"==&gt;"</span>+value);
        }
    }
}</code></pre></div>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo01Map;

<span class="hljs-comment">/*
    自定义类型(Person,Student,Car,User),什么时候重写hashCode和equals方法
        1.使用HashSet集合,存储自定义类型元素
        2.使用HashMap集合,key使用自定义类型的元素
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> {
    }

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> {
        <span class="hljs-built_in">this</span>.name = name;
        <span class="hljs-built_in">this</span>.age = age;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Person{"</span> +
                <span class="hljs-string">"name='"</span> + name + <span class="hljs-string">'\''</span> +
                <span class="hljs-string">", age="</span> + age +
                <span class="hljs-string">'}'</span>;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) o;

        <span class="hljs-keyword">if</span> (age != person.age) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">return</span> name != <span class="hljs-literal">null</span> ? name.equals(person.name) : person.name == <span class="hljs-literal">null</span>;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> {
        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> name != <span class="hljs-literal">null</span> ? name.hashCode() : <span class="hljs-number">0</span>;
        result = <span class="hljs-number">31</span> * result + age;
        <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> {
        <span class="hljs-built_in">this</span>.name = name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> age;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> {
        <span class="hljs-built_in">this</span>.age = age;
    }
}</code></pre></div>
<h2 id="6linkedhashmap集合了解">6.LinkedHashMap集合(了解)</h2>
<p><strong>有序:存储元素和取出元素的顺序一致</strong></p>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo01Map;

<span class="hljs-keyword">import</span> java.util.HashMap;
<span class="hljs-keyword">import</span> java.util.LinkedHashMap;
<span class="hljs-keyword">import</span> java.util.LinkedList;

<span class="hljs-comment">/*
    java.util.LinkedHashMap&lt;K,V&gt;集合 extends HashMap&lt;K,V&gt;集合
    Map 接口的哈希表和链接列表实现，具有可预知的迭代顺序。此实现与 HashMap 的不同之处在于，后者维护着一个运行于所有条目的双重链接列表。
    a.LinkedHashMap集合底层是哈希表+单向链表和LinkedHashSet是一样
    b.是一个有序的集合
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo05LinkedHashMap</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        HashMap&lt;String,String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
        map.put(<span class="hljs-string">"aaa"</span>,<span class="hljs-string">"aaa"</span>);
        map.put(<span class="hljs-string">"bbb"</span>,<span class="hljs-string">"bbb"</span>);
        map.put(<span class="hljs-string">"ccc"</span>,<span class="hljs-string">"ccc"</span>);
        map.put(<span class="hljs-string">"ddd"</span>,<span class="hljs-string">"ddd"</span>);
        map.put(<span class="hljs-string">"aaa"</span>,<span class="hljs-string">"hello"</span>);
        System.out.println(map);<span class="hljs-comment">//{aaa=hello, ccc=ccc, bbb=bbb, ddd=ddd} key不允许重复,是一个无序集合</span>

        LinkedHashMap&lt;String,String&gt; linked = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();
        linked.put(<span class="hljs-string">"aaa"</span>,<span class="hljs-string">"aaa"</span>);
        linked.put(<span class="hljs-string">"bbb"</span>,<span class="hljs-string">"bbb"</span>);
        linked.put(<span class="hljs-string">"ccc"</span>,<span class="hljs-string">"ccc"</span>);
        linked.put(<span class="hljs-string">"ddd"</span>,<span class="hljs-string">"ddd"</span>);
        linked.put(<span class="hljs-string">"aaa"</span>,<span class="hljs-string">"hello"</span>);
        System.out.println(linked);<span class="hljs-comment">//{aaa=hello, bbb=bbb, ccc=ccc, ddd=ddd} key不允许重复,是一个有序集合</span>
    }
}</code></pre></div>
<h2 id="7treemap集合了解">7.TreeMap集合(了解)</h2>
<p><strong>key:根据比较器排序</strong></p>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo01Map;

<span class="hljs-keyword">import</span> java.util.Comparator;
<span class="hljs-keyword">import</span> java.util.TreeMap;

<span class="hljs-comment">/*
    java.util.TreeMap&lt;K,V&gt;集合 implements Map&lt;K,V&gt;接口
    基于红黑树（Red-Black tree）的 NavigableMap 实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。
    a.TreeMap底层是一个红黑树结构
    b.TreeMap集合自带了一个比较器,里边存储的key是有序的:默认是升序或者可以根据比较器自定义排序规则
       和TreeSet是一样
    构造方法:
        TreeMap() key默认升序
        TreeMap(Comparator&lt;? super K&gt; comparator) key的顺序就是比较器写的顺序
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo06TreeMap</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">//使用空参数构造方法,创建TreeMap集合对象</span>
        TreeMap&lt;Integer,String&gt; map1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();
        map1.put(<span class="hljs-number">1</span>,<span class="hljs-string">"a"</span>);
        map1.put(<span class="hljs-number">3</span>,<span class="hljs-string">"b"</span>);
        map1.put(<span class="hljs-number">2</span>,<span class="hljs-string">"c"</span>);
        map1.put(<span class="hljs-number">1</span>,<span class="hljs-string">"w"</span>);
        map1.put(<span class="hljs-number">4</span>,<span class="hljs-string">"d"</span>);
        System.out.println(map1);<span class="hljs-comment">//{1=w, 2=c, 3=b, 4=d}</span>

        <span class="hljs-comment">//使用比较器构造方法,创建TreeMap集合对象</span>
        TreeMap&lt;Integer,String&gt; map2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> {
                <span class="hljs-comment">//key升序:o1-o2  key降序:o2-o1</span>
                <span class="hljs-keyword">return</span> o2-o1;
            }
        });
        map2.put(<span class="hljs-number">1</span>,<span class="hljs-string">"a"</span>);
        map2.put(<span class="hljs-number">3</span>,<span class="hljs-string">"b"</span>);
        map2.put(<span class="hljs-number">2</span>,<span class="hljs-string">"c"</span>);
        map2.put(<span class="hljs-number">1</span>,<span class="hljs-string">"w"</span>);
        map2.put(<span class="hljs-number">4</span>,<span class="hljs-string">"d"</span>);
        System.out.println(map2);<span class="hljs-comment">//{4=d, 3=b, 2=c, 1=w}</span>
    }
}</code></pre></div>
<h2 id="8hashtable集合扩展-了解">8.Hashtable集合(扩展-了解)</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo01Map;

<span class="hljs-keyword">import</span> java.util.HashMap;
<span class="hljs-keyword">import</span> java.util.Hashtable;

<span class="hljs-comment">/*
    Hashtable集合(扩展-了解)
    java.util.Hashtable&lt;K,V&gt;:是JDK1.0时期的双列集合
        1.底层是一个哈希表结构(数组+单向链表|数组+红黑树)
        2.不允许存储null键和null值
        3.Hashtable 是同步的,可以保证多线程安全
    java.util.HashMap&lt;K,V&gt;:是JDK1.2时期的双列集合
        1.底层是一个哈希表结构(数组+单向链表|数组+红黑树)
        2.允许存储null键和null值
        3.HashMap 是不同步的,不能保证多线程安全
    Hashtable已经被淘汰了,但是Hashtable的子类Properties依然活跃在历史的舞台(IO)
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo07Hashtable</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        HashMap&lt;String,String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
        map.put(<span class="hljs-literal">null</span>,<span class="hljs-string">"1"</span>);
        map.put(<span class="hljs-string">"2"</span>,<span class="hljs-literal">null</span>);
        map.put(<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>);
        System.out.println(map);<span class="hljs-comment">//{null=null, 2=null}</span>

        Hashtable&lt;String,String&gt; table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>&lt;&gt;();
        <span class="hljs-comment">//table.put(null,"1");//NullPointerException</span>
        <span class="hljs-comment">//table.put("2",null);//NullPointerException</span>
        table.put(<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>);<span class="hljs-comment">//NullPointerException</span>
    }
}</code></pre></div>
<h2 id="9map集合的练习">9.Map集合的练习</h2>
<h3 id="需求">需求：</h3>
<p>​	输入一个字符串,统计字符串中每个字符出现次数</p>
<h3 id="分析">分析:</h3>
<p><img src="/_resources/5114d7e671104f98a9cbfb030b18cc92.png" /></p>
<h3 id="代码实现-3">代码实现:</h3>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo01Map;

<span class="hljs-keyword">import</span> java.util.HashMap;
<span class="hljs-keyword">import</span> java.util.Scanner;

<span class="hljs-comment">/*
    Map集合的练习
    需求：
        输入一个字符串,统计字符串中每个字符出现次数
    分析:
        1.使用Scanner获取用户输入的字符串
        2.创建一个Map集合,key使用Character类型:存储字符,value使用Integer类型:存储字符个数
        3.遍历字符串,获取字符串中的每一个字符
        a.length()+charAt()
        b.toCharArray() 转换为字符数组
        4.使用Map接口中的方法containsKey判断Map集合中是否包含指定的key(字符)
        boolean containsKey(Object key
        true:包含指定的字符,不是第一次存储
            a.根据key,获取value(个数)
            b.value++
            c.map.put('字符',value);更新
        false:不包含指定的字符,第一次存储字符
            map.put('字符',1);
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo08Test</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">//1.使用Scanner获取用户输入的字符串</span>
        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);
        System.out.println(<span class="hljs-string">"请输入一个字符串:"</span>);
        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> sc.nextLine();
        <span class="hljs-comment">//2.创建一个Map集合,key使用Character类型:存储字符,value使用Integer类型:存储字符个数</span>
        HashMap&lt;Character,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
        <span class="hljs-comment">//3.遍历字符串,获取字符串中的每一个字符</span>
        <span class="hljs-comment">//a.length()+charAt()</span>
        <span class="hljs-comment">/*for (int i = 0; i &lt; str.length(); i++) {
            char c = str.charAt(i);
            System.out.println(c);
        }*/</span>
        <span class="hljs-comment">//b.toCharArray() 转换为字符数组</span>
        <span class="hljs-type">char</span>[] chars = str.toCharArray();
        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : chars) {
            <span class="hljs-comment">//System.out.println(c);</span>
            <span class="hljs-comment">//4.使用Map接口中的方法containsKey判断Map集合中是否包含指定的key(字符)</span>
            <span class="hljs-keyword">if</span>(map.containsKey(c)){
                <span class="hljs-comment">//true:包含指定的字符,不是第一次存储</span>
                <span class="hljs-comment">//a.根据key,获取value(个数)</span>
                <span class="hljs-type">Integer</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> map.get(c);
                <span class="hljs-comment">//b.value++</span>
                value++;
                <span class="hljs-comment">//c.map.put('字符',value);更新</span>
                map.put(c,value);
            }<span class="hljs-keyword">else</span>{
                <span class="hljs-comment">//false:不包含指定的字符,第一次存储字符</span>
                <span class="hljs-comment">//map.put('字符',1);</span>
                map.put(c,<span class="hljs-number">1</span>);
            }
        }
        System.out.println(map);
    }
}</code></pre></div>
<h2 id="10集合嵌套">10.集合嵌套</h2>
<ul>
<li>集合的嵌套:集合中的元素仍然是一个集合</li>
<li>任何集合之间都可以相互嵌套</li>
<li>List集合可以嵌套Set集合,Set集合也可以嵌套List集合,List集合可以嵌套Map集合…</li>
<li><strong>注意:只要看到集合就遍历</strong></li>
</ul>
<p><img src="/_resources/c0dfab0553084a12b0fcdf21248deec9.png" /></p>
<h3 id="1list嵌套list重点">1).List嵌套List(重点)</h3>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo02Collection;

<span class="hljs-keyword">import</span> java.util.ArrayList;

<span class="hljs-comment">/*
    List嵌套List(重点)
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01ListList</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">//需求:假如我们有两个班级的学生,分别存储到两个List集合中</span>
        ArrayList&lt;String&gt; list01 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        list01.add(<span class="hljs-string">"张三"</span>);
        list01.add(<span class="hljs-string">"李四"</span>);
        list01.add(<span class="hljs-string">"王五"</span>);
        list01.add(<span class="hljs-string">"赵六"</span>);
        ArrayList&lt;String&gt; list02 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        list02.add(<span class="hljs-string">"tom"</span>);
        list02.add(<span class="hljs-string">"jerry"</span>);
        list02.add(<span class="hljs-string">"小花"</span>);
        list02.add(<span class="hljs-string">"小明"</span>);
        <span class="hljs-comment">//创建一个List集合,存储两个班级</span>
        ArrayList&lt;ArrayList&lt;String&gt;&gt; listList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        listList.add(list01);
        listList.add(list02);
        <span class="hljs-comment">//遍历listList集合,获取每一个元素(ArrayList&lt;String&gt;)</span>
        <span class="hljs-keyword">for</span> (ArrayList&lt;String&gt; list : listList) {
            <span class="hljs-comment">//遍历list集合,获取集合中每一个元素</span>
            <span class="hljs-keyword">for</span> (String s : list) {
                System.out.println(s);
            }
        }
    }
}</code></pre></div>
<p><img src="/_resources/483057e3187e40d697551a9b334c7e03.png" /></p>
<h3 id="2list集合嵌套map集合了解">2).List集合嵌套Map集合(了解)</h3>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo02Collection;

<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.HashMap;
<span class="hljs-keyword">import</span> java.util.Set;

<span class="hljs-comment">/*
    List集合嵌套Map集合
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo02ListMap</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">/*
            需求:假如我们有两个班级的学生,分别存储到两个Map集合中
            key:存储学生的学号
            value:存储学生姓名
         */</span>
        HashMap&lt;String,String&gt; map1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
        map1.put(<span class="hljs-string">"hm001"</span>,<span class="hljs-string">"迪丽热巴"</span>);
        map1.put(<span class="hljs-string">"hm002"</span>,<span class="hljs-string">"古力娜扎"</span>);
        HashMap&lt;String,String&gt; map2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
        map2.put(<span class="hljs-string">"hm007"</span>,<span class="hljs-string">"胡歌"</span>);
        map2.put(<span class="hljs-string">"hm009"</span>,<span class="hljs-string">"霍建华"</span>);
        <span class="hljs-comment">//创建一个List,分别存储两个Map集合</span>
        ArrayList&lt;HashMap&lt;String,String&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        list.add(map1);
        list.add(map2);
        <span class="hljs-comment">//遍历list,获取每一个元素(HashMap&lt;String,String&gt;)</span>
        <span class="hljs-keyword">for</span> (HashMap&lt;String, String&gt; map : list) {
            <span class="hljs-comment">//使用keySet+增强for循环遍历map集合</span>
            Set&lt;String&gt; set = map.keySet();
            <span class="hljs-keyword">for</span> (String key : set) {
                <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> map.get(key);
                System.out.println(key+<span class="hljs-string">"="</span>+value);
            }
        }
    }
}</code></pre></div>
<p><img src="/_resources/8701917d331f4421ac811c446e2928ea.png" /></p>
<h3 id="3map集合嵌套map集合了解">3).Map集合嵌套Map集合(了解)</h3>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo02Collection;

<span class="hljs-keyword">import</span> java.util.HashMap;
<span class="hljs-keyword">import</span> java.util.Set;

<span class="hljs-comment">/*
    Map集合嵌套Map集合
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo03MapMap</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">/*
            需求:假如我们有两个班级的学生,分别存储到两个Map集合中
            key:存储学生的学号
            value:存储学生姓名
         */</span>
        HashMap&lt;String,String&gt; map1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
        map1.put(<span class="hljs-string">"hm001"</span>,<span class="hljs-string">"迪丽热巴"</span>);
        map1.put(<span class="hljs-string">"hm002"</span>,<span class="hljs-string">"古力娜扎"</span>);
        HashMap&lt;String,String&gt; map2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
        map2.put(<span class="hljs-string">"hm007"</span>,<span class="hljs-string">"胡歌"</span>);
        map2.put(<span class="hljs-string">"hm009"</span>,<span class="hljs-string">"霍建华"</span>);
        <span class="hljs-comment">/*
            创建一个Map集合,存储这两个班级的Map集合
            key:存储学生班级名称
            value:HashMap&lt;String,String&gt;
         */</span>
        HashMap&lt;String,HashMap&lt;String,String&gt;&gt; mapMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
        mapMap.put(<span class="hljs-string">"黑马173"</span>,map1);
        mapMap.put(<span class="hljs-string">"黑马174"</span>,map2);

        <span class="hljs-comment">//使用keySet方法+增强for循环,遍历mapMap</span>
        Set&lt;String&gt; set = mapMap.keySet();<span class="hljs-comment">//把所有的班级的名称存储到Set集合</span>
        <span class="hljs-keyword">for</span> (String className : set) {
            <span class="hljs-comment">//通过班级名称,获取每一个班级HashMap&lt;String,String&gt;</span>
            HashMap&lt;String, String&gt; map = mapMap.get(className);
            <span class="hljs-comment">//使用keySet+增强for循环,遍历map集合</span>
            Set&lt;String&gt; idSet = map.keySet();<span class="hljs-comment">//把所有学生的学号,存储到Set集合</span>
            <span class="hljs-keyword">for</span> (String id : idSet) {
                <span class="hljs-comment">//通过学生的学号,获取学生的姓名</span>
                <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> map.get(id);
                System.out.println(className+<span class="hljs-string">"==&gt;"</span>+id+<span class="hljs-string">"="</span>+name);
            }
        }
    }
}</code></pre></div>
<p><img src="/_resources/9e8ee4c580c046bf859052c7362b298c.png" /></p>
<h1 id="第五章-斗地主综合案例重点">第五章 斗地主综合案例(重点)</h1>
<h2 id="1需求分析">1.需求分析:</h2>
<p>实现步骤:</p>
<p>1.准备牌</p>
<p>2.洗牌</p>
<p>3.发牌 每人一张轮流发牌,一人17张牌,剩余3张作为底牌</p>
<p>4.排序</p>
<p>5.看牌</p>
<p><img src="/_resources/f26dfdff49fb45b0b915a5edea3b769c.png" /></p>
<h2 id="2代码实现">2.代码实现:</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo03Test;

<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Collections;
<span class="hljs-keyword">import</span> java.util.HashMap;

<span class="hljs-comment">/*
    斗地主综合案例
    1.准备牌
    2.洗牌
    3.发牌
    4.排序
    5.看牌
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DouDiZhu</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">//1.准备牌</span>
        <span class="hljs-comment">//创建一个HashMap集合,key使用Integer类型:存储牌的索引,value使用String类型:存储组装好的牌</span>
        HashMap&lt;Integer,String&gt; poker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
        <span class="hljs-comment">//创建一个ArrayList集合,使用Integer类型:存储牌的索引</span>
        ArrayList&lt;Integer&gt; pokerIndex = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        <span class="hljs-comment">//定义一个int类型的变量,作为牌的索引0,1,2,3,4...</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
        <span class="hljs-comment">//往集合中添加特殊牌,大王和小王</span>
        poker.put(index,<span class="hljs-string">"大王"</span>);
        pokerIndex.add(index);
        index++;<span class="hljs-comment">//0==&gt;1</span>
        poker.put(index,<span class="hljs-string">"小王"</span>);
        pokerIndex.add(index);
        index++;<span class="hljs-comment">//1==&gt;2</span>

        <span class="hljs-comment">//创建一个ArrayList集合,使用String类型:存储牌的13个序号</span>
        ArrayList&lt;String&gt; numbers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        Collections.addAll(numbers,<span class="hljs-string">"2"</span>,<span class="hljs-string">"A"</span>,<span class="hljs-string">"K"</span>,<span class="hljs-string">"Q"</span>,<span class="hljs-string">"J"</span>,<span class="hljs-string">"10"</span>,<span class="hljs-string">"9"</span>,<span class="hljs-string">"8"</span>,<span class="hljs-string">"7"</span>,<span class="hljs-string">"6"</span>,<span class="hljs-string">"5"</span>,<span class="hljs-string">"4"</span>,<span class="hljs-string">"3"</span>);
        <span class="hljs-comment">//创建一个ArrayList集合,使用String类型:存储牌的4个花色</span>
        ArrayList&lt;String&gt; colors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        Collections.addAll(colors,<span class="hljs-string">"♠"</span>,<span class="hljs-string">"♥"</span>,<span class="hljs-string">"♣"</span>,<span class="hljs-string">"♦"</span>);
        <span class="hljs-comment">//循环嵌套遍历两个ArrayList集合,组装52张牌(序号写在外层)</span>
        <span class="hljs-keyword">for</span> (String number : numbers) {
            <span class="hljs-keyword">for</span> (String color : colors) {
                <span class="hljs-comment">//把组装好的牌存储到集合中</span>
                <span class="hljs-comment">//System.out.println(color+number);</span>
                poker.put(index,color+number);
                pokerIndex.add(index);
                index++;<span class="hljs-comment">//2==&gt;3,4,5,6,7...53</span>
            }
        }
        <span class="hljs-comment">//System.out.println(poker);</span>
        <span class="hljs-comment">//System.out.println(pokerIndex);</span>

        <span class="hljs-comment">//2.洗牌</span>
        Collections.shuffle(pokerIndex);
        <span class="hljs-comment">//System.out.println(pokerIndex);</span>

        <span class="hljs-comment">//3.发牌 要求每人一张轮流发牌,一人17张牌,剩余3张作为底牌</span>
        <span class="hljs-comment">//创建4个ArrayList集合,分别存储玩家的牌和底牌</span>
        ArrayList&lt;Integer&gt; player01 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        ArrayList&lt;Integer&gt; player02 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        ArrayList&lt;Integer&gt; player03 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        ArrayList&lt;Integer&gt; diPai = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        <span class="hljs-comment">//遍历存储牌索引的ArrayList集合,获取每一个牌的索引</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; pokerIndex.size(); i++) {
            <span class="hljs-type">Integer</span> <span class="hljs-variable">pi</span> <span class="hljs-operator">=</span> pokerIndex.get(i);
            <span class="hljs-comment">//索引&gt;=51:给底牌发牌(先判断底牌)</span>
            <span class="hljs-keyword">if</span>(i&gt;=<span class="hljs-number">51</span>){
                diPai.add(pi);
            }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i%<span class="hljs-number">3</span>==<span class="hljs-number">0</span>){
                <span class="hljs-comment">//索引%3==0:给玩家1发牌</span>
                player01.add(pi);
            }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i%<span class="hljs-number">3</span>==<span class="hljs-number">1</span>){
                <span class="hljs-comment">//索引%3==1:给玩家2发牌</span>
                player02.add(pi);
            }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i%<span class="hljs-number">3</span>==<span class="hljs-number">2</span>){
                <span class="hljs-comment">//索引%3==2:给玩家3发牌</span>
                player03.add(pi);
            }
        }
        <span class="hljs-comment">//System.out.println(player01);</span>
        <span class="hljs-comment">//System.out.println(player02);</span>
        <span class="hljs-comment">//System.out.println(player03);</span>
        <span class="hljs-comment">//System.out.println(diPai);</span>

        <span class="hljs-comment">//4.排序</span>
        Collections.sort(player01);
        Collections.sort(player02);
        Collections.sort(player03);
        Collections.sort(diPai);
        <span class="hljs-comment">//System.out.println(player01);</span>
        <span class="hljs-comment">//System.out.println(player02);</span>
        <span class="hljs-comment">//System.out.println(player03);</span>
        <span class="hljs-comment">//System.out.println(diPai);</span>

        <span class="hljs-comment">//5.看牌:调用看牌的方法</span>
        lookPoker(<span class="hljs-string">"周星驰"</span>,player01,poker);
        lookPoker(<span class="hljs-string">"周润发"</span>,player02,poker);
        lookPoker(<span class="hljs-string">"刘德华"</span>,player03,poker);
        lookPoker(<span class="hljs-string">"底牌"</span>,diPai,poker);

    }

    <span class="hljs-comment">/*
        定义一个看牌的方法(提高代码复用性)
        参数:
            String name:玩家姓名
            ArrayList&lt;Integer&gt; list:玩家的牌和底牌
            HashMap&lt;Integer,String&gt; poker:存储牌的Map集合
        查表法:
            遍历玩家|底牌集合,获取Map集合中每一个key
            通过key,获取value(组装的牌),给用户显示
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lookPoker</span><span class="hljs-params">(String name,ArrayList&lt;Integer&gt; list,HashMap&lt;Integer,String&gt; poker)</span>{
        <span class="hljs-comment">//打印玩家名称,不换行</span>
        System.out.print(name+<span class="hljs-string">": "</span>);
        <span class="hljs-comment">//遍历玩家|底牌集合,获取Map集合中每一个key</span>
        <span class="hljs-keyword">for</span> (Integer key : list) {
            <span class="hljs-comment">//通过key,获取value(组装的牌),给用户显示</span>
            <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> poker.get(key);
            System.out.print(value+<span class="hljs-string">" "</span>);
        }
        <span class="hljs-comment">//打印完每一个玩家的牌换行(一个玩家一行)</span>
        System.out.println();
    }
}</code></pre></div>
<h1 id="第六章-冒泡排序重点">第六章 冒泡排序(重点)</h1>
<h2 id="1原理">1.原理</h2>
<p><img src="/_resources/789fa37eb36848d8b4d96a26f4b66a51.png" /></p>
<h2 id="2代码实现-2">2.代码实现</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo04bubbleSort;

<span class="hljs-keyword">import</span> java.util.Arrays;

<span class="hljs-comment">/*
    冒泡排序
    使用数组中的元素依次比较,每次选出最大的元素
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01BubbleSort</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">int</span>[] arr = {<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">8</span>,<span class="hljs-number">1</span>};
        System.out.println(<span class="hljs-string">"排序前数组中的元素:"</span>+ Arrays.toString(arr));<span class="hljs-comment">//排序前数组中的元素:[5, 3, 8, 1]</span>

        <span class="hljs-comment">/*
            实现冒泡排序
            1.定义一个循环嵌套
                外层循环:控制比较的次数 arr.length-1
                内层循环:控制每次比较几对元素
                    为了防止索引越界异常 arr.length-1
                    为了每次比较的元素对数依次减少 arr.length-1-i
            2.在循环中依次比较arr[j]和arr[j+1]的,选出最大的
                比较两个元素,使用第三方变量交换位置
         */</span>
        <span class="hljs-comment">//1.定义一个循环嵌套</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length-<span class="hljs-number">1</span>; i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; arr.length-<span class="hljs-number">1</span>-i; j++) {
                <span class="hljs-comment">//2.在循环中依次比较arr[j]和arr[j+1]的,选出最大的</span>
                <span class="hljs-keyword">if</span>(arr[j]&gt;arr[j+<span class="hljs-number">1</span>]){
                    <span class="hljs-comment">//比较两个元素,使用第三方变量交换位置</span>
                    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[j];
                    arr[j] = arr[j+<span class="hljs-number">1</span>];
                    arr[j+<span class="hljs-number">1</span>] = temp;
                }
            }
        }
        System.out.println(<span class="hljs-string">"排序后数组中的元素:"</span>+ Arrays.toString(arr));<span class="hljs-comment">//排序后数组中的元素:[1, 3, 5, 8]</span>
    }
}</code></pre></div>
</div>
      </article>
    </div>
  </body>
</html>
