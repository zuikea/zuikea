<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta http-equiv="X-UA-Compatible" content="ie=edge" />
<link rel="stylesheet" href="/_assets/main.css" />

    <title>06-kafka&amp;用户行为操作 - zkblog</title>
  <link rel="stylesheet" href="/_markdown_plugin_assets/highlight.js/atom-one-light.css" /></head>
  <body>
    <div class="main">
      <nav class="navigation">
        <a href="/">zkblog</a>
      </nav>
      <article>
        <header>
          <h1 class="article-title">06-kafka&amp;用户行为操作</h1>
          <div class="article-info">
            <div>
              <span
                >Created At：<time datetime="1650100065935"
                  >2022-04-16 17:07</time
                ></span
              >
              <span
                >Updated At：<time datetime="1650100225024"
                  >2022-04-16 17:10</time
                ></span
              >
            </div>
            
          </div>
        </header>
        <div class="article-content markdown-body"><h1 id="第6章-kafka用户行为操作">第6章 kafka&amp;用户行为操作</h1>
<h2 id="学习目标">学习目标</h2>
<ul>
<li>能够了解kafka基本信息</li>
<li>能够运用kafka进行消息的收发</li>
<li>能够理解kafka生产者的原理和机制</li>
<li>能够理解kafka消费者的原理和机制</li>
<li>能够完成自媒体文章上下架功能</li>
<li>能够完成App用户关注行为</li>
</ul>
<p>上次课程总结:<a title="https://www.processon.com/view/link/6191b08ee401fd59f24496fa" href="https://www.processon.com/view/link/6191b08ee401fd59f24496fa">https://www.processon.com/view/link/6191b08ee401fd59f24496fa</a></p>
<h2 id="0-消息中间件对比">0 消息中间件对比</h2>
<p><img src="/_resources/aa2e6934dd134275b9c294f46bdcf76c.png" /></p>
<h2 id="1-kafka">1 kafka</h2>
<h3 id="11-kafka介绍">1.1 kafka介绍</h3>
<p>Kafka 是一个分布式流媒体平台</p>
<p>kafka官网：<a title="http://kafka.apache.org/" href="http://kafka.apache.org/">http://kafka.apache.org/</a></p>
<p>（1）流媒体平台有三个关键功能：</p>
<ul>
<li><strong>发布和订阅记录流</strong>，类似于消息队列或企业消息传递系统。</li>
<li>以<strong>容错的持久方式存储记录流</strong>。</li>
<li>记录发生时处理流。</li>
</ul>
<p>（2）Kafka通常用于两大类应用：</p>
<ul>
<li>构建可在<strong>系统或应用程序之间</strong>可靠获取数据的实时流数据管道</li>
<li>构建转换或响应数据流的实时流应用程序</li>
</ul>
<p><img src="/_resources/c9305c800b834ed591f445efeae6f9a7.png" /></p>
<p>（3）kafka名词解释</p>
<ul>
<li>topic：Kafka将消息分门别类，每一类的消息称之为一个主题（Topic）</li>
<li>producer：发布消息的对象称之为主题生产者（Kafka topic producer）</li>
<li>consumer：订阅消息并处理发布的消息的对象称之为主题消费者（consumers）</li>
<li>broker：已发布的消息保存在一组服务器中，称之为Kafka集群。集群中的每一个服务器都是一个代理（Broker）。 消费者可以订阅一个或多个主题（topic），并从Broker拉数据，从而消费这些已发布的消息。</li>
</ul>
<h3 id="12-kafka安装和配置">1.2 kafka安装和配置</h3>
<h4 id="121-kafka安装">1.2.1 kafka安装</h4>
<p>使用docker-compose ,配置参考day01资料</p>
<p><img src="/_resources/d338cf8620a04954bddc9ff04c7414e3.png" /></p>
<p>注: 这里修改下kafdrop的端口: 9080:9000, 这里如果用9000会跟minio冲突</p>
<p>启动前先删除之前的kafka容器</p>
<div><pre class="hljs"><code><span class="hljs-meta"># </span><span class="language-bash">找到已经存在的容器</span>
docker ps -a 
<span class="hljs-meta"># </span><span class="language-bash">删除kafka和zookeeper对应的id</span>
docker rm 容器ID</code></pre></div>
<p><img src="/_resources/6bdf8eacbcac47cf8f81204b81a1a120.png" /></p>
<p><img src="/_resources/23b8fe4da9d4418b81eed28b131fc028.png" /></p>
<p>启动</p>
<div><pre class="hljs"><code><span class="hljs-meta"># </span><span class="language-bash">切换到目录</span>
cd /opt/hmtt/kafka
<span class="hljs-meta"># </span><span class="language-bash">通过docker-compose启动</span>
./start.sh</code></pre></div>
<p><img src="/_resources/e336d4b2faf1440d864fb517bade5f05.png" /></p>
<h4 id="122-kafka管理工具">1.2.2 kafka管理工具</h4>
<p><strong>kafka-eagle</strong></p>
<p>官网: <a title="https://www.kafka-eagle.org/" href="https://www.kafka-eagle.org/">https://www.kafka-eagle.org/</a></p>
<p>虚拟机镜像中已安装好,启动kafka-eagle</p>
<div><pre class="hljs"><code>ke.sh start</code></pre></div>
<p>停止服务</p>
<div><pre class="hljs"><code>ke.sh stop</code></pre></div>
<p><img src="/_resources/a2e850b375ee44319119e5aa2b002952.png" /></p>
<p>浏览器打开http://192.168.85.143:8048/</p>
<p>登录用户名密码: admin/123456</p>
<p><img src="/_resources/464195b2d9a14986b98984b584a3193c.png" /></p>
<p>可以在KSQL页面执行类似SQL查询</p>
<p><img src="/_resources/69ac41a0a67b4dd29f402bf6684a5568.png" /></p>
<div><pre class="hljs"><code>select * from hello_1 where `partition` in (2) and `offset` &gt; 0 limit 10</code></pre></div>
<p><img src="/_resources/c06447ada7714c0db0e2b54c08d4a57f.png" /></p>
<p>如需自行安装,参考如下(可选):</p>
<p>下载包在资料中<code>kafka-eagle-bin-2.0.2.tar.gz</code></p>
<div><pre class="hljs"><code><span class="hljs-meta"># </span><span class="language-bash">
<span class="hljs-built_in">cd</span> /opt/hmtt</span>
mkdir kafka-eagle
cd kafka-eagle</code></pre></div>
<p>上传压缩包到<code>/opt/hmtt/kafka-eagle</code>目录</p>
<div><pre class="hljs"><code><span class="hljs-meta"># </span><span class="language-bash">解压</span>
tar xzf kafka-eagle-bin-2.0.2.tar.gz
cd kafka-eagle-bin-2.0.2
tar xzf kafka-eagle-web-2.0.2-bin.tar.gz
mv kafka-eagle-web-2.0.2/ /opt/hmtt/kafka-eagle-web
cd /opt/hmtt/kafka-eagle-web/</code></pre></div>
<p>配置环境</p>
<div><pre class="hljs"><code>vi /etc/profile</code></pre></div>
<p>在末尾加上</p>
<div><pre class="hljs"><code>export JAVA_HOME=/opt/soft/jdk1.8.0_231
export KE_HOME=/opt/hmtt/kafka-eagle-web
export PATH=$PATH:$JAVA_HOME/bin:$KE_HOME/bin
</code></pre></div>
<p>保存配置</p>
<div><pre class="hljs"><code>source /etc/profile </code></pre></div>
<p>修改kafka-eagle配置</p>
<div><pre class="hljs"><code>vi /opt/hmtt/kafka-eagle-web/conf/system-config.properties</code></pre></div>
<p>配置如下:</p>
<div><pre class="hljs"><code><span class="hljs-meta">#</span><span class="language-bash"><span class="hljs-comment">#####################################</span></span>
<span class="hljs-meta"># </span><span class="language-bash">multi zookeeper &amp; kafka cluster list</span>
<span class="hljs-meta">#</span><span class="language-bash"><span class="hljs-comment">#####################################</span></span>
kafka.eagle.zk.cluster.alias=cluster1
cluster1.zk.list=192.168.85.143:2181
<span class="hljs-meta">#</span><span class="language-bash"><span class="hljs-comment">#####################################</span></span>
cluster1.kafka.eagle.broker.size=20
<span class="hljs-meta">#</span><span class="language-bash"><span class="hljs-comment">#####################################</span></span>
<span class="hljs-meta"># </span><span class="language-bash">zk client thread <span class="hljs-built_in">limit</span></span>
<span class="hljs-meta">#</span><span class="language-bash"><span class="hljs-comment">#####################################</span></span>
kafka.zk.limit.size=25
<span class="hljs-meta">#</span><span class="language-bash"><span class="hljs-comment">#####################################</span></span>
<span class="hljs-meta"># </span><span class="language-bash">kafka eagle webui port</span>
<span class="hljs-meta">#</span><span class="language-bash"><span class="hljs-comment">#####################################</span></span>
kafka.eagle.webui.port=8048
<span class="hljs-meta">#</span><span class="language-bash"><span class="hljs-comment">#####################################</span></span>
<span class="hljs-meta"># </span><span class="language-bash">kafka offset storage</span>
<span class="hljs-meta">#</span><span class="language-bash"><span class="hljs-comment">#####################################</span></span>
cluster1.kafka.eagle.offset.storage=kafka
<span class="hljs-meta">#</span><span class="language-bash"><span class="hljs-comment">#####################################</span></span>
<span class="hljs-meta"># </span><span class="language-bash">kafka metrics, 15 days by default</span>
<span class="hljs-meta">#</span><span class="language-bash"><span class="hljs-comment">#####################################</span></span>
kafka.eagle.metrics.charts=true
kafka.eagle.metrics.retain=15
<span class="hljs-meta">#</span><span class="language-bash"><span class="hljs-comment">#####################################</span></span>
<span class="hljs-meta"># </span><span class="language-bash">kafka sql topic records max</span>
<span class="hljs-meta">#</span><span class="language-bash"><span class="hljs-comment">#####################################</span></span>
kafka.eagle.sql.topic.records.max=5000
<span class="hljs-meta">#</span><span class="language-bash"><span class="hljs-comment">#####################################</span></span>
<span class="hljs-meta"># </span><span class="language-bash">delete kafka topic token</span>
<span class="hljs-meta">#</span><span class="language-bash"><span class="hljs-comment">#####################################</span></span>
kafka.eagle.topic.token=keadmin
<span class="hljs-meta"># </span><span class="language-bash">kafka mysql jdbc driver address</span>
<span class="hljs-meta">#</span><span class="language-bash"><span class="hljs-comment">#####################################</span></span>
kafka.eagle.driver=com.mysql.jdbc.Driver
kafka.eagle.url=jdbc:mysql://127.0.0.1:3306/ke?useUnicode=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull
kafka.eagle.username=root
kafka.eagle.password=root
</code></pre></div>
<h3 id="13-kafka快速入门">1.3 kafka快速入门</h3>
<h4 id="131-创建工程kafka-demo">1.3.1 创建工程kafka-demo</h4>
<p>创建kafka-demo工程，引入依赖</p>
<div><pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.kafka<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>kafka-clients<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div>
<h4 id="132-消息生产者">1.3.2 消息生产者</h4>
<p>官方文档:<a title="http://kafka.apache.org/21/documentation.html#producerapi" href="http://kafka.apache.org/21/documentation.html#producerapi">http://kafka.apache.org/21/documentation.html#producerapi</a></p>
<p>创建类：</p>
<p><img src="/_resources/001a81a8b88d4c068e28e847fe27229a.png" /></p>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.heima.kafka;

<span class="hljs-keyword">import</span> org.apache.kafka.clients.producer.KafkaProducer;
<span class="hljs-keyword">import</span> org.apache.kafka.clients.producer.Producer;
<span class="hljs-keyword">import</span> org.apache.kafka.clients.producer.ProducerConfig;
<span class="hljs-keyword">import</span> org.apache.kafka.clients.producer.ProducerRecord;
<span class="hljs-keyword">import</span> org.apache.kafka.common.serialization.StringSerializer;

<span class="hljs-keyword">import</span> java.util.Map;
<span class="hljs-keyword">import</span> java.util.Properties;
<span class="hljs-keyword">import</span> java.util.Random;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProducerTest</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">Properties</span> <span class="hljs-variable">props</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();
        <span class="hljs-comment">// 指定服务器地址</span>
        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="hljs-string">"192.168.85.143:9092"</span>);
        <span class="hljs-comment">// 构建生产者对象  指定配置属性\key的序列化器\value的序列化器</span>
        KafkaProducer&lt;String, String&gt; producer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">KafkaProducer</span>&lt;String, String&gt;(props, <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringSerializer</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringSerializer</span>());
        <span class="hljs-comment">// 指定要发送的主题的名称</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">topic</span> <span class="hljs-operator">=</span> <span class="hljs-string">"test_1"</span>;
        <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();
        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">"key"</span> + random.nextInt(<span class="hljs-number">100</span>);
        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-string">"value"</span> + random.nextInt(<span class="hljs-number">100</span>);
        <span class="hljs-comment">// 构建消息记录 指定发送的主题 发送的key 和  value</span>
        ProducerRecord&lt;String, String&gt; record = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProducerRecord</span>&lt;String, String&gt;(topic, key, value);
        <span class="hljs-comment">// 调用api发送消息</span>
        producer.send(record);
        System.out.println(<span class="hljs-string">"消息发送完成,key = "</span> + key + <span class="hljs-string">" ,value = "</span> + value);
        <span class="hljs-comment">// 关闭客户端</span>
        producer.close();
    }
}
</code></pre></div>
<h4 id="133-消息消费者">1.3.3 消息消费者</h4>
<p><a title="http://kafka.apache.org/21/documentation.html#consumerapi" href="http://kafka.apache.org/21/documentation.html#consumerapi">http://kafka.apache.org/21/documentation.html#consumerapi</a></p>
<p>创建消费者类：</p>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.heima.kafka;

<span class="hljs-keyword">import</span> org.apache.kafka.clients.consumer.ConsumerConfig;
<span class="hljs-keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecord;
<span class="hljs-keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecords;
<span class="hljs-keyword">import</span> org.apache.kafka.clients.consumer.KafkaConsumer;
<span class="hljs-keyword">import</span> org.apache.kafka.clients.producer.ProducerConfig;
<span class="hljs-keyword">import</span> org.apache.kafka.common.serialization.StringDeserializer;

<span class="hljs-keyword">import</span> java.time.Duration;
<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Collection;
<span class="hljs-keyword">import</span> java.util.List;
<span class="hljs-keyword">import</span> java.util.Properties;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsumerTest</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">Properties</span> <span class="hljs-variable">props</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();
        <span class="hljs-comment">// 指定服务器地址</span>
        props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="hljs-string">"192.168.85.143:9092"</span>);
        <span class="hljs-comment">// 指定消费者的分组</span>
        props.put(ConsumerConfig.GROUP_ID_CONFIG, <span class="hljs-string">"group-1"</span>);
        <span class="hljs-comment">// 构建生产者对象  指定配置属性\key的序列化器\value的序列化器</span>
        <span class="hljs-comment">// 构建消费者对象</span>
        KafkaConsumer&lt;String, String&gt; consumer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">KafkaConsumer</span>&lt;String, String&gt;(props, <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringDeserializer</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringDeserializer</span>());
        <span class="hljs-comment">// 指定需要订阅的主题</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">topic</span> <span class="hljs-operator">=</span> <span class="hljs-string">"test_1"</span>;
        <span class="hljs-comment">// 开启订阅主题</span>
        List&lt;String&gt; topics = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();
        topics.add(topic);
        consumer.subscribe(topics);

        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
            <span class="hljs-comment">// 调用api拉取消息 指定消息拉取的间隔 这里设置的是1秒</span>
            ConsumerRecords&lt;String, String&gt; consumerRecords = consumer.poll(Duration.ofSeconds(<span class="hljs-number">1</span>));
            <span class="hljs-comment">// 遍历结果</span>
            <span class="hljs-keyword">for</span> (ConsumerRecord&lt;String, String&gt; consumerRecord : consumerRecords) {
                System.out.println(<span class="hljs-string">"接收到消息,偏移量offset = "</span> + consumerRecord.offset()
                        + <span class="hljs-string">", key = "</span> + consumerRecord.key() + <span class="hljs-string">", value = "</span> + consumerRecord.value());
            }
        }
    }
}
</code></pre></div>
<h3 id="14-kafka消息可靠性">1.4 kafka消息可靠性</h3>
<h4 id="141-集群">1.4.1 集群</h4>
<p><strong>docker 中搭建集群</strong></p>
<p>搭建集群前先关闭单节点模式</p>
<div><pre class="hljs"><code>./close.sh</code></pre></div>
<div><pre class="hljs"><code>cd /opt/hmtt/kafka/cluster</code></pre></div>
<p>配置文件</p>
<div><pre class="hljs"><code><span class="hljs-attr">version:</span> <span class="hljs-string">'2'</span>
<span class="hljs-attr">services:</span>
  <span class="hljs-attr">zookeeper:</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">wurstmeister/zookeeper</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">"2181:2181"</span>
  <span class="hljs-attr">kafka:</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">wurstmeister/kafka:2.12-2.3.0</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">"9092"</span>
    <span class="hljs-attr">environment:</span>
      <span class="hljs-attr">KAFKA_ADVERTISED_HOST_NAME:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.85</span><span class="hljs-number">.143</span>
      <span class="hljs-attr">KAFKA_ZOOKEEPER_CONNECT:</span> <span class="hljs-string">zookeeper:2181</span>
    <span class="hljs-attr">volumes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">/var/run/docker.sock:/var/run/docker.sock</span></code></pre></div>
<p>这里没有配置指定端口,会自动分配端口</p>
<p>启动集群</p>
<div><pre class="hljs"><code>docker-compose up -d</code></pre></div>
<p>扩展集群</p>
<div><pre class="hljs"><code>docker-compose scale kafka=3</code></pre></div>
<p>停止集群</p>
<div><pre class="hljs"><code>docker-compose stop</code></pre></div>
<p>打开管理界面http://192.168.85.143:8048/</p>
<p><img src="/_resources/9358677a11374d77a5bf1c75a2054e3b.png" /></p>
<p><strong>集群特性:</strong></p>
<ul>
<li>
<p><strong>分区Partition</strong></p>
<p>主题可以被分为若干个分区（partition），同一个主题中的分区可以在一个机器上，有可能会部署在多个机器上，由此来实现 kafka 的伸缩性。topic中的数据分割为一个或多个partition。每个topic至少有一个partition。每个partition中的数据使用多个文件进行存储。partition中的数据是有序的，partition之间的数据是没有顺序的。如果topic有多个partition，消费数据时就不能保证数据的顺序。在需要严格保证消息的消费顺序的场景下，需要将partition数目设为1。</p>
<p><img src="/_resources/5993d75f92644530a87e80df55aa74ba.png" /></p>
</li>
<li>
<p>副本Replica</p>
<p>Kafka 中分区的备份叫做 副本（Replica），分区分布在不同的服务器上,分区可以配置一定数量的副本进行容错，每个分区都有一台服务器充当领导者（Leader ）及其他的副本称为追随者（Follower）；所有写请求都通过Leader路由，数据变更会广播给所有Follower，Follower与Leader保持数据同步。如果Leader失效，则从Follower中选举出一个新的Leader。当Follower与Leader断开、卡住或者同步太慢，leader会把这个follower从ISR列表（保持同步的副本列表）中删除，重新创建一个Follower。</p>
</li>
</ul>
<p>在管理界面中创建主题:</p>
<p><img src="/_resources/23c880a27b2c445dbf144be236f4b6a6.png" /></p>
<p><img src="/_resources/8738841a0291464e9c63f359a8597be5.png" /></p>
<p>生产者连集群</p>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.heima.kafka;

<span class="hljs-keyword">import</span> org.apache.kafka.clients.producer.KafkaProducer;
<span class="hljs-keyword">import</span> org.apache.kafka.clients.producer.Producer;
<span class="hljs-keyword">import</span> org.apache.kafka.clients.producer.ProducerConfig;
<span class="hljs-keyword">import</span> org.apache.kafka.clients.producer.ProducerRecord;
<span class="hljs-keyword">import</span> org.apache.kafka.common.serialization.StringSerializer;

<span class="hljs-keyword">import</span> java.util.Map;
<span class="hljs-keyword">import</span> java.util.Properties;
<span class="hljs-keyword">import</span> java.util.Random;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProducerTest</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">Properties</span> <span class="hljs-variable">props</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();
        <span class="hljs-comment">// 指定服务器地址</span>
        <span class="hljs-comment">// props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, "192.168.85.143:9092");</span>
        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="hljs-string">"192.168.85.143:32768,192.168.85.143:32769,192.168.85.143:32770"</span>);
        <span class="hljs-comment">// 构建生产者对象  指定配置属性\key的序列化器\value的序列化器</span>
        KafkaProducer&lt;String, String&gt; producer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">KafkaProducer</span>&lt;String, String&gt;(props, <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringSerializer</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringSerializer</span>());
        <span class="hljs-comment">// 指定要发送的主题的名称</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">topic</span> <span class="hljs-operator">=</span> <span class="hljs-string">"test_3"</span>;
        <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();
        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">"key"</span> + random.nextInt(<span class="hljs-number">100</span>);
        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-string">"value"</span> + random.nextInt(<span class="hljs-number">100</span>);
        <span class="hljs-comment">// 构建消息记录 指定发送的主题 发送的key 和  value</span>
        <span class="hljs-comment">// 如果有key,根据key做hash计算,分配到具体的分片</span>
        <span class="hljs-comment">// ProducerRecord&lt;String, String&gt; record = new ProducerRecord&lt;String, String&gt;(topic, key, value);</span>
        <span class="hljs-comment">// 如果不写key,默认多个分片轮询</span>
        ProducerRecord&lt;String, String&gt; record = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProducerRecord</span>&lt;String, String&gt;(topic, value);
        <span class="hljs-comment">// 保证顺序消费,往同一个分片发</span>
        <span class="hljs-comment">// ProducerRecord&lt;String, String&gt; record = new ProducerRecord&lt;String, String&gt;(topic, 0, key, value);</span>
        <span class="hljs-comment">// 调用api发送消息</span>
        producer.send(record);
        System.out.println(<span class="hljs-string">"消息发送完成,key = "</span> + key + <span class="hljs-string">" ,value = "</span> + value);
        <span class="hljs-comment">// 关闭客户端</span>
        producer.close();
    }
}</code></pre></div>
<p>消费者</p>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.heima.kafka;

<span class="hljs-keyword">import</span> org.apache.kafka.clients.consumer.ConsumerConfig;
<span class="hljs-keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecord;
<span class="hljs-keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecords;
<span class="hljs-keyword">import</span> org.apache.kafka.clients.consumer.KafkaConsumer;
<span class="hljs-keyword">import</span> org.apache.kafka.clients.producer.ProducerConfig;
<span class="hljs-keyword">import</span> org.apache.kafka.common.serialization.StringDeserializer;

<span class="hljs-keyword">import</span> java.time.Duration;
<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Collection;
<span class="hljs-keyword">import</span> java.util.List;
<span class="hljs-keyword">import</span> java.util.Properties;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsumerTest</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">Properties</span> <span class="hljs-variable">props</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();
        <span class="hljs-comment">// 指定服务器地址</span>
        <span class="hljs-comment">// props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, "192.168.85.143:9092");</span>
        props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="hljs-string">"192.168.85.143:32768,192.168.85.143:32769,192.168.85.143:32770"</span>);
        <span class="hljs-comment">// 指定消费者的分组</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-string">"group-1"</span>;
        props.put(ConsumerConfig.GROUP_ID_CONFIG, group);
        <span class="hljs-comment">// 构建生产者对象  指定配置属性\key的序列化器\value的序列化器</span>
        <span class="hljs-comment">// 构建消费者对象</span>
        KafkaConsumer&lt;String, String&gt; consumer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">KafkaConsumer</span>&lt;String, String&gt;(props, <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringDeserializer</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringDeserializer</span>());
        <span class="hljs-comment">// 指定需要订阅的主题</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">topic</span> <span class="hljs-operator">=</span> <span class="hljs-string">"test_3"</span>;
        <span class="hljs-comment">// 开启订阅主题</span>
        List&lt;String&gt; topics = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();
        topics.add(topic);
        consumer.subscribe(topics);
        System.out.println(group + <span class="hljs-string">" 开始消费..."</span>);
        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
            <span class="hljs-comment">// 调用api拉取消息 指定消息拉取的间隔 这里设置的是1秒</span>
            ConsumerRecords&lt;String, String&gt; consumerRecords = consumer.poll(Duration.ofSeconds(<span class="hljs-number">1</span>));
            <span class="hljs-comment">// 遍历结果</span>
            <span class="hljs-keyword">for</span> (ConsumerRecord&lt;String, String&gt; consumerRecord : consumerRecords) {
                System.out.println(<span class="hljs-string">"接收到消息,分区partition = "</span> + consumerRecord.partition() + <span class="hljs-string">",偏移量offset = "</span> + consumerRecord.offset()
                        + <span class="hljs-string">", key = "</span> + consumerRecord.key() + <span class="hljs-string">", value = "</span> + consumerRecord.value());
            }
        }
    }
}</code></pre></div>
<h4 id="142-生产者详解">1.4.2 生产者详解</h4>
<p>（1）发送消息的工作原理</p>
<p><img src="/_resources/027ed79888b84167b71d8a07a167d491.png" /></p>
<p>（2）发送类型</p>
<ul>
<li>
<p>发送并忘记（fire-and-forget）</p>
<p>把消息发送给服务器，并不关心它是否正常到达，大多数情况下，消息会正常到达，因为kafka是高可用的，而且生产者会自动尝试重发，使用这种方式有时候会丢失一些信息</p>
</li>
<li>
<p>同步发送</p>
<p>使用send()方法发送，它会返回一个Future对象，调用get()方法进行等待，就可以知道消息是否发送成功</p>
<div><pre class="hljs"><code><span class="hljs-comment">//发送消息</span>
<span class="hljs-keyword">try</span> {
    <span class="hljs-type">RecordMetadata</span> <span class="hljs-variable">recordMetadata</span> <span class="hljs-operator">=</span> producer.send(record).get();
    System.out.println(recordMetadata.offset());<span class="hljs-comment">//获取偏移量</span>
}<span class="hljs-keyword">catch</span> (Exception e){
    e.printStackTrace();
}</code></pre></div>
<p>如果服务器返回错误，get()方法会抛出异常，如果没有发生错误，我们就会得到一个RecordMetadata对象，可以用它来获取消息的偏移量</p>
</li>
<li>
<p>异步发送</p>
<p>调用send()方法，并指定一个回调函数，服务器在返回响应时调用函数。如下代码</p>
<div><pre class="hljs"><code><span class="hljs-comment">//发送消息</span>
<span class="hljs-keyword">try</span> {
    producer.send(record, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Callback</span>() {
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCompletion</span><span class="hljs-params">(RecordMetadata recordMetadata, Exception e)</span> {
            <span class="hljs-keyword">if</span>(e!=<span class="hljs-literal">null</span>){
                e.printStackTrace();
            }
            System.out.println(recordMetadata.offset());
        }
    });
}<span class="hljs-keyword">catch</span> (Exception e){
    e.printStackTrace();
}</code></pre></div>
<p>如果kafka返回一个错误，onCompletion()方法会抛出一个非空（non null）异常，可以根据实际情况处理，比如记录错误日志，或者把消息写入“错误消息”文件中，方便后期进行分析。</p>
</li>
</ul>
<p>（3）参数详解</p>
<p>到目前为止，我们只介绍了生产者的几个必要参数（bootstrap.servers、序列化器等）</p>
<p>生产者还有很多可配置的参数，可以在<code>ProducerConfig</code>中查看,在kafka官方文档中都有说明，<a title="http://kafka.apache.org/21/documentation.html#producerconfigs,%E5%A4%A7%E9%83%A8%E5%88%86%E9%83%BD%E6%9C%89%E5%90%88%E7%90%86%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC%EF%BC%8C%E6%89%80%E4%BB%A5%E6%B2%A1%E6%9C%89%E5%BF%85%E8%A6%81%E5%8E%BB%E4%BF%AE%E6%94%B9%E5%AE%83%E4%BB%AC%EF%BC%8C%E4%B8%8D%E8%BF%87%E6%9C%89%E5%87%A0%E4%B8%AA%E5%8F%82%E6%95%B0%E5%9C%A8%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%EF%BC%8C%E6%80%A7%E8%83%BD%E5%92%8C%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%96%B9%E6%B3%95%E5%AF%B9%E7%94%9F%E4%BA%A7%E8%80%85%E6%9C%89%E5%BD%B1%E5%93%8D" href="http://kafka.apache.org/21/documentation.html#producerconfigs,%E5%A4%A7%E9%83%A8%E5%88%86%E9%83%BD%E6%9C%89%E5%90%88%E7%90%86%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC%EF%BC%8C%E6%89%80%E4%BB%A5%E6%B2%A1%E6%9C%89%E5%BF%85%E8%A6%81%E5%8E%BB%E4%BF%AE%E6%94%B9%E5%AE%83%E4%BB%AC%EF%BC%8C%E4%B8%8D%E8%BF%87%E6%9C%89%E5%87%A0%E4%B8%AA%E5%8F%82%E6%95%B0%E5%9C%A8%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%EF%BC%8C%E6%80%A7%E8%83%BD%E5%92%8C%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%96%B9%E6%B3%95%E5%AF%B9%E7%94%9F%E4%BA%A7%E8%80%85%E6%9C%89%E5%BD%B1%E5%93%8D">http://kafka.apache.org/21/documentation.html#producerconfigs,大部分都有合理的默认值，所以没有必要去修改它们，不过有几个参数在内存使用，性能和可靠性方法对生产者有影响</a></p>
<ul>
<li>
<p>acks</p>
<p>指的是producer的消息发送确认机制,<code>properties.put(ProducerConfig.ACKS_CONFIG,"all");</code></p>
<ul>
<li>
<p>acks=0</p>
<p>生产者在成功写入消息之前不会等待任何来自服务器的响应，也就是说，如果当中出现了问题，导致服务器没有收到消息，那么生产者就无从得知，消息也就丢失了。不过，因为生产者不需要等待服务器的响应，所以它可以以网络能够支持的最大速度发送消息，从而达到很高的吞吐量。</p>
</li>
<li>
<p>acks=1</p>
<p>只要集群首领节点收到消息，生产者就会收到一个来自服务器的成功响应，如果消息无法到达首领节点，生产者会收到一个错误响应，为了避免数据丢失，生产者会重发消息。</p>
</li>
<li>
<p>acks=all</p>
<p>只有当所有参与赋值的节点全部收到消息时，生产者才会收到一个来自服务器的成功响应，这种模式是最安全的，它可以保证不止一个服务器收到消息，就算有服务器发生崩溃，整个集群仍然可以运行。不过他的延迟比acks=1时更高。</p>
</li>
</ul>
</li>
<li>
<p>retries</p>
<p>生产者从服务器收到的错误有可能是临时性错误，在这种情况下，retries参数的值决定了生产者可以重发消息的次数，如果达到这个次数，生产者会放弃重试返回错误，默认情况下，生产者会在每次重试之间等待100ms</p>
</li>
</ul>
<h4 id="143-消费者详解">1.4.3 消费者详解</h4>
<p>（1）消费者工作原理</p>
<p><img src="/_resources/ada0f7dea6ef4d60932c8c7d10eb3bb7.png" /></p>
<p>（2）参数详解</p>
<p>​	<a title="http://kafka.apache.org/21/documentation.html#consumerconfigs" href="http://kafka.apache.org/21/documentation.html#consumerconfigs">http://kafka.apache.org/21/documentation.html#consumerconfigs</a></p>
<ul>
<li>
<p>enable.auto.commit</p>
<p>该属性指定了消费者是否自动提交偏移量，默认值是true。为了尽量避免出现重复数据和数据丢失，可以把它设置为false，由自己控制何时提交偏移量。如果把它设置为true,还可以通过配置<code>auto.commit.interval.ms</code>属性来控制提交的频率。</p>
</li>
<li>
<p>auto.offset.reset</p>
<p>如果没有初始偏移量或者当前的偏移量在服务器上不存在时如何处理</p>
<ul>
<li>
<p>earliest</p>
<p>当各分区下有已提交的offset时，从提交的offset开始消费；无提交的offset时，从头开始消费</p>
</li>
<li>
<p>latest</p>
<p>当各分区下有已提交的offset时，从提交的offset开始消费；无提交的offset时，消费新产生的该分区下的数据</p>
</li>
<li>
<p>none</p>
<p>topic各分区都存在已提交的offset时，从offset后开始消费；只要有一个分区不存在已提交的offset，则抛出异常</p>
</li>
<li>
<p>anything  else</p>
<p>向consumer抛出异常</p>
</li>
</ul>
</li>
</ul>
<p>（3）提交和偏移量</p>
<p>每次调用poll()方法，它会返回由生产者写入kafka但还没有被消费者读取过来的记录，我们由此可以追踪到哪些记录是被群组里的哪个消费者读取的，kafka不会像其他JMS队列那样需要得到消费者的确认，这是kafka的一个独特之处，相反，消费者可以使用kafka来追踪消息在分区的位置（偏移量）</p>
<p>消费者会往一个叫做<code>_consumer_offset</code>的特殊主题发送消息，消息里包含了每个分区的偏移量。如果消费者一直处于运行状态，那么偏移量就没有什么用处。不过，如果消费者发生崩溃或有新的消费者加入群组，就会触发再均衡，完成再均衡之后，每个消费者可能分配到新的分区，消费者需要读取每个分区最后一次提交的偏移量，然后从偏移量指定的地方继续处理。</p>
<p>如果提交偏移量小于客户端处理的最后一个消息的偏移量，那么处于两个偏移量之间的消息就会被重复处理。</p>
<p>如下图：</p>
<p><img src="/_resources/26fd1092a5394ce9bc0b53c56ec5706b.png" /></p>
<p>如果提交的偏移量大于客户端的最后一个消息的偏移量，那么处于两个偏移量之间的消息将会丢失。</p>
<p>如下图：</p>
<p><img src="/_resources/66026c1062b24e25a64d66a42803938a.png" /></p>
<p>（4）自动提交偏移量</p>
<p>当<code>enable.auto.commit</code>被设置为true，提交方式就是让消费者自动提交偏移量，每隔5秒消费者会自动把从poll()方法接收的最大偏移量提交上去。提交时间间隔有<code>auto.commot.interval.ms</code>控制，默认值是5秒。</p>
<p>需要注意到，这种方式可能会导致消息重复消费。假如，某个消费者poll消息后，应用正在处理消息，在3秒后Kafka进行了重平衡，那么由于没有更新位移导致重平衡后这部分消息重复消费。</p>
<p>（5）提交当前偏移量（同步提交）</p>
<p>把<code>enable.auto.commit</code>设置为false,让应用程序决定何时提交偏移量。</p>
<div><pre class="hljs"><code>properties.put(<span class="hljs-string">"enable.auto.commit"</span>, <span class="hljs-string">"false"</span>);</code></pre></div>
<p>使用commitSync()提交偏移量，commitSync()将会提交poll返回的最新的偏移量，所以在处理完所有记录后要确保调用了commitSync()方法。否则还是会有消息丢失的风险。</p>
<p>只要没有发生不可恢复的错误，commitSync()方法会一直尝试直至提交成功，如果提交失败也可以记录到错误日志里。</p>
<div><pre class="hljs"><code><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>){
    ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="hljs-number">1000</span>));
    <span class="hljs-keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) {
        System.out.println(record.value());
        System.out.println(record.key());
    }
    <span class="hljs-keyword">try</span> {
        consumer.commitSync();<span class="hljs-comment">//同步提交当前最新的偏移量</span>
    }<span class="hljs-keyword">catch</span> (CommitFailedException e){
        System.out.println(<span class="hljs-string">"记录提交失败的异常："</span>+e);
    }
}</code></pre></div>
<p>（6）异步提交</p>
<p>手动提交有一个缺点，那就是当发起提交调用时应用会阻塞。当然我们可以减少手动提交的频率，但这个会增加消息重复的概率（和自动提交一样）。另外一个解决办法是，使用异步提交的API。</p>
<div><pre class="hljs"><code><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>){
    ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="hljs-number">1000</span>));
    <span class="hljs-keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) {
        System.out.println(record.value());
        System.out.println(record.key());
    }
    consumer.commitAsync(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OffsetCommitCallback</span>() {
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onComplete</span><span class="hljs-params">(Map&lt;TopicPartition, OffsetAndMetadata&gt; map, Exception e)</span> {
            <span class="hljs-keyword">if</span>(e!=<span class="hljs-literal">null</span>){
                System.out.println(<span class="hljs-string">"记录错误的提交偏移量："</span>+ map+<span class="hljs-string">",异常信息"</span>+e);
            }
        }
    });
}</code></pre></div>
<p>(7) 消费组和偏移量</p>
<p>修改消费组,并且将<code>auto.offset.reset</code>设置为<code>earliest</code></p>
<div><pre class="hljs"><code><span class="hljs-comment">// 设置消费的方式 从最早记录开始消费</span>
props.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, <span class="hljs-string">"earliest"</span>);
<span class="hljs-comment">// 指定消费者分组</span>
<span class="hljs-type">String</span> <span class="hljs-variable">groupId</span> <span class="hljs-operator">=</span> <span class="hljs-string">"group-5"</span>;
props.put(ConsumerConfig.GROUP_ID_CONFIG, groupId);</code></pre></div>
<p>可以看到消息被重新消费,并且重新计算这个组的偏移量</p>
<h3 id="15-spring-boot集成kafka收发消息">1.5 spring boot集成kafka收发消息</h3>
<h4 id="151-环境搭建">1.5.1 环境搭建</h4>
<p>（1）搭建工程kafka-spring-boot-demo  添加pom依赖，最终的依赖信息</p>
<div><pre class="hljs"><code><span class="hljs-comment">&lt;!-- 继承Spring boot工程 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.8.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">fastjson.version</span>&gt;</span>1.2.58<span class="hljs-tag">&lt;/<span class="hljs-name">fastjson.version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- kafkfa --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.kafka<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-kafka<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>${fastjson.version}<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div>
<p>（2）在resources下创建文件application.yml</p>
<div><pre class="hljs"><code><span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">8001</span>
<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">kafka:</span>
    <span class="hljs-attr">bootstrap-servers:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.85</span><span class="hljs-number">.143</span><span class="hljs-string">:9092</span>
    <span class="hljs-attr">producer:</span>
      <span class="hljs-attr">key-serializer:</span> <span class="hljs-string">org.apache.kafka.common.serialization.StringSerializer</span>
      <span class="hljs-attr">value-serializer:</span> <span class="hljs-string">org.apache.kafka.common.serialization.StringSerializer</span>
    <span class="hljs-attr">consumer:</span>
      <span class="hljs-attr">group-id:</span> <span class="hljs-string">web-group-1</span>
      <span class="hljs-attr">key-deserializer:</span> <span class="hljs-string">org.apache.kafka.common.serialization.StringDeserializer</span>
      <span class="hljs-attr">value-deserializer:</span> <span class="hljs-string">org.apache.kafka.common.serialization.StringDeserializer</span>
</code></pre></div>
<p>（3）引导类</p>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.heima.kafka;

<span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;
<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;

<span class="hljs-comment">/**
 * <span class="hljs-doctag">@author</span> mcm
 */</span>
<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebApp</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        SpringApplication.run(WebApp.class, args);
    }
}
</code></pre></div>
<h4 id="152-消息生产者">1.5.2 消息生产者</h4>
<p>新建controller</p>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.heima.kafka.controller;

<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;
<span class="hljs-keyword">import</span> org.springframework.http.ResponseEntity;
<span class="hljs-keyword">import</span> org.springframework.kafka.core.KafkaTemplate;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;

<span class="hljs-keyword">import</span> java.util.Date;
<span class="hljs-keyword">import</span> java.util.Random;

<span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@RequestMapping("/test")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestController</span> {

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> KafkaTemplate&lt;String, String&gt; kafkaTemplate;

    <span class="hljs-meta">@GetMapping("/send")</span>
    <span class="hljs-keyword">public</span> ResponseEntity <span class="hljs-title function_">send</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 指定要发送的主题的名称</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">topic</span> <span class="hljs-operator">=</span> <span class="hljs-string">"test_3"</span>;
        <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();
        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">"key"</span> + random.nextInt(<span class="hljs-number">100</span>);
        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-string">"value"</span> + random.nextInt(<span class="hljs-number">100</span>);
        kafkaTemplate.send(topic, key, value);
        <span class="hljs-keyword">return</span> ResponseEntity.ok(<span class="hljs-string">"发送完成"</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());
    }
}
</code></pre></div>
<h4 id="153-消息消费者">1.5.3 消息消费者</h4>
<p>新建监听类：</p>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.heima.kafka.listener;

<span class="hljs-keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecord;
<span class="hljs-keyword">import</span> org.springframework.kafka.annotation.KafkaListener;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Service;

<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestListener</span> {

    <span class="hljs-meta">@KafkaListener(topics = "test_3")</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(ConsumerRecord&lt;String, String&gt; consumerRecord)</span> {
        System.out.println(<span class="hljs-string">"接收到消息,分区partition = "</span> + consumerRecord.partition() + <span class="hljs-string">",偏移量offset = "</span> + consumerRecord.offset()
                + <span class="hljs-string">", key = "</span> + consumerRecord.key() + <span class="hljs-string">", value = "</span> + consumerRecord.value());
    }
}
</code></pre></div>
<p>项目结构:</p>
<p><img src="/_resources/92fb720643284883ace79458fc197eed.png" /></p>
<h2 id="2-自媒体端-文章上下架">2 自媒体端-文章上下架</h2>
<h3 id="21-需求分析">2.1 需求分析</h3>
<p><img src="/_resources/6826da2a4cad4ae2be62238e2e05090d.png" /></p>
<p><img src="/_resources/6a76bcaed4a049529460e411a7a9be1d.png" /></p>
<ul>
<li>
<p>当前已经发布（状态为9）的文章可以上架（enable = 1），也可以下架（enable = 0）</p>
</li>
<li>
<p>在上架和下架操作的同时，需要同步app端的文章配置信息，暂时不做，后期讲到审核文章的时候再优化</p>
</li>
</ul>
<h3 id="22-接口定义">2.2 接口定义</h3>
<ul>
<li>上下架</li>
</ul>
<p>在WmNewsController中添加方法</p>
<div><pre class="hljs"><code>    <span class="hljs-meta">@PutMapping("/down_or_up")</span>
    <span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title function_">downOrUp</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> WmNewsDto dto)</span> {
        <span class="hljs-keyword">return</span> wmNewsService.downOrUp(dto);
    }</code></pre></div>
<h3 id="23-业务层">2.3 业务层</h3>
<p>在IWmNewsService新增方法</p>
<div><pre class="hljs"><code>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IWmNewsService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IService</span>&lt;WmNews&gt; {

    ResponseResult <span class="hljs-title function_">downOrUp</span><span class="hljs-params">(WmNewsDto dto)</span>;
}
</code></pre></div>
<p>实现类：</p>
<div><pre class="hljs"><code>    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title function_">downOrUp</span><span class="hljs-params">(WmNewsDto dto)</span> {
        <span class="hljs-comment">// 根据id查询文章</span>
        <span class="hljs-type">WmNews</span> <span class="hljs-variable">wmNews</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getById(dto.getId());
        <span class="hljs-comment">// 判断文章是否存在</span>
        <span class="hljs-keyword">if</span> (wmNews == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span> ResponseResult.errorResult(AppHttpCodeEnum.DATA_NOT_EXIST);
        }
        <span class="hljs-comment">// 判断文章发布状态</span>
        <span class="hljs-keyword">if</span> (wmNews.getStatus() != <span class="hljs-number">9</span>) {
            <span class="hljs-keyword">return</span> ResponseResult.errorResult(AppHttpCodeEnum.DATA_CAN_NOT_UPDATE);
        }
        <span class="hljs-comment">// 修改文章的上下架状态</span>
        wmNews.setEnable(dto.getEnable() == <span class="hljs-number">0</span> ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span>);
        <span class="hljs-built_in">this</span>.updateById(wmNews);
        <span class="hljs-keyword">return</span> ResponseResult.okResult();
    }</code></pre></div>
<h3 id="24-发送消息">2.4 发送消息</h3>
<p>在common中添加kafka依赖</p>
<div><pre class="hljs"><code><span class="hljs-comment">&lt;!-- kafkfa --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.kafka<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-kafka<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>
<p>media服务添加kafka配置</p>
<div><pre class="hljs"><code><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">leadnews-media</span>
  <span class="hljs-attr">kafka:</span>
    <span class="hljs-attr">bootstrap-servers:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.85</span><span class="hljs-number">.143</span><span class="hljs-string">:9092</span>
    <span class="hljs-attr">producer:</span>
      <span class="hljs-attr">key-serializer:</span> <span class="hljs-string">org.apache.kafka.common.serialization.StringSerializer</span>
      <span class="hljs-attr">value-serializer:</span> <span class="hljs-string">org.apache.kafka.common.serialization.StringSerializer</span></code></pre></div>
<p>修改WmNewsServiceImpl中的downOrUp方法，发送消息</p>
<div><pre class="hljs"><code>    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> KafkaTemplate&lt;String,String&gt; kafkaTemplate;

    <span class="hljs-meta">@Value("${topic.upDownTopic}")</span>
    <span class="hljs-keyword">private</span> String upDownTopic;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title function_">downOrUp</span><span class="hljs-params">(WmNewsDto dto)</span> {
        <span class="hljs-comment">// 根据id查询文章</span>
        <span class="hljs-type">WmNews</span> <span class="hljs-variable">wmNews</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getById(dto.getId());
        <span class="hljs-comment">// 判断文章是否存在</span>
        <span class="hljs-keyword">if</span> (wmNews == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> ResponseResult.errorResult(AppHttpCodeEnum.DATA_NOT_EXIST);
        <span class="hljs-comment">// 判断文章是否已发布</span>
        <span class="hljs-keyword">if</span> (wmNews.getStatus() != <span class="hljs-number">9</span>) <span class="hljs-keyword">return</span> ResponseResult.errorResult(AppHttpCodeEnum.PARAM_INVALID);
        <span class="hljs-comment">// 更新文章的上下架状态</span>
        wmNews.setEnable(dto.getEnable() == <span class="hljs-number">1</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>);
        <span class="hljs-built_in">this</span>.updateById(wmNews);
        <span class="hljs-comment">// 同步最新状态到App端</span>
        <span class="hljs-comment">// 发送消息到kafka</span>
        kafkaTemplate.send(upDownTopic, wmNews.getArticleId().toString(), dto.getEnable() == <span class="hljs-number">1</span> ? <span class="hljs-string">"true"</span> : <span class="hljs-string">"false"</span>);
        <span class="hljs-keyword">return</span> ResponseResult.okResult();
    }</code></pre></div>
<p>添加上下架发送消息的topic</p>
<div><pre class="hljs"><code>topic:
  upDownTopic: wm_news_up_down_topic</code></pre></div>
<h3 id="25-文章服务监听消息">2.5 文章服务监听消息</h3>
<p>文章微服务需要接收消息</p>
<p>在application.yml文件中添加kafka消费者的配置</p>
<div><pre class="hljs"><code><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">leadnews-article</span>
  <span class="hljs-attr">kafka:</span>
    <span class="hljs-attr">bootstrap-servers:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.85</span><span class="hljs-number">.143</span><span class="hljs-string">:9092</span>
    <span class="hljs-attr">consumer:</span>
      <span class="hljs-attr">group-id:</span> <span class="hljs-string">${spring.application.name}-kafka-group</span>
      <span class="hljs-attr">key-deserializer:</span> <span class="hljs-string">org.apache.kafka.common.serialization.StringDeserializer</span>
      <span class="hljs-attr">value-deserializer:</span> <span class="hljs-string">org.apache.kafka.common.serialization.StringDeserializer</span>
<span class="hljs-attr">topic:</span>
  <span class="hljs-attr">upDownTopic:</span> <span class="hljs-string">wm_news_up_down_topic</span></code></pre></div>
<p>编写listener，如下：</p>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.heima.article.listener;

<span class="hljs-keyword">import</span> com.baomidou.mybatisplus.core.conditions.Wrapper;
<span class="hljs-keyword">import</span> com.baomidou.mybatisplus.core.conditions.update.LambdaUpdateWrapper;
<span class="hljs-keyword">import</span> com.heima.article.entity.ApArticle;
<span class="hljs-keyword">import</span> com.heima.article.service.IApArticleService;
<span class="hljs-keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecord;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;
<span class="hljs-keyword">import</span> org.springframework.kafka.annotation.KafkaListener;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Service;

<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UpDownListener</span> {

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> IApArticleService articleService;

    <span class="hljs-meta">@KafkaListener(topics = {"${topic.upDownTopic}"})</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(ConsumerRecord&lt;String, String&gt; record)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> record.key();
        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> record.value();
        <span class="hljs-comment">// 更新文章表的id_down</span>
        LambdaUpdateWrapper&lt;ApArticle&gt; update = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaUpdateWrapper</span>&lt;&gt;();
        update.eq(ApArticle::getId, key);
        update.set(ApArticle::getIsDown, value.equals(<span class="hljs-string">"true"</span>) ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span>);
        articleService.update(update);
    }
}
</code></pre></div>
<h2 id="3-关注用户">3 关注用户</h2>
<h3 id="31-需求分析">3.1 需求分析</h3>
<p><img src="/_resources/774d112a55d94c2f8bfc692881f7f8a7.png" /></p>
<p>如上效果：</p>
<p>当前登录后的用户可以关注作者，也可以取消关注作者</p>
<p>在文章详情中，当用户点击了关注作者按钮，需要记录当前行为到表中，目前只需要存储数据即可，后期会做实时的流式处理，根据这些基础数据做热点文章的计算。</p>
<h3 id="32-思路分析">3.2 思路分析</h3>
<p>一个用户关注了作者，作者是由用户实名认证以后开通的作者权限，才有了作者信息，作者肯定是app中的一个用户。</p>
<p>从用户的角度出发：一个用户可以关注其他多个作者</p>
<p>从作者的角度出发：一个用户（同是作者）也可以拥有很多个粉丝(用户)</p>
<p>实现步骤：</p>
<blockquote>
<p>1 前端传递作者id获取作者信息，最终获取到作者在当前app端的账号id</p>
<p>2 如果是关注操作，需要保存数据，用户保存关注的作者</p>
<p>2.1 异步记录关注行为（后面开发，为了推荐做准备）</p>
<p>3 如果是取消关注，删除用户关注的作者</p>
</blockquote>
<p>流程分析：</p>
<p><img src="/_resources/16e7cf400563443dbabbd84bc545673c.png" /></p>
<ul>
<li>
<p>app端关注信息表</p>
<p>记录了当前登录用户和关注人（作者）的关系，方便当前用户查看关注的作者</p>
</li>
</ul>
<p><img src="/_resources/0d64f6b1f2dc4c3d929b2773d0600ef7.png" /></p>
<ul>
<li>app用户表与app作者表是一对一关系，只有在用户认证以后才会有作者出现</li>
<li>app用户表与app用户关注表是一对多的关系，一个用户可以关注多个作者,也可以拥有多个粉丝</li>
</ul>
<p>ap_user_follow APP用户关注信息表</p>
<p><img src="/_resources/60a7f6638a464300b3ab1dfdbada08f9.png" /></p>
<h3 id="33-功能实现">3.3 功能实现</h3>
<h4 id="331-feign接口-文章微服务中获取作者数据">3.3.1 feign接口-文章微服务中获取作者数据</h4>
<p>(1)修改AuthorController中实现这个方法</p>
<div><pre class="hljs"><code>    <span class="hljs-comment">/**
     * 根据id查询作者
     * <span class="hljs-doctag">@param</span> id
     * <span class="hljs-doctag">@return</span>
     */</span>
    <span class="hljs-meta">@GetMapping("/{id}")</span>
    <span class="hljs-keyword">public</span> ResponseResult&lt;ApAuthor&gt; <span class="hljs-title function_">getAuthor</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable("id")</span> Integer id)</span>{
        <span class="hljs-type">ApAuthor</span> <span class="hljs-variable">apAuthor</span> <span class="hljs-operator">=</span> apAuthorService.getById(id);
        <span class="hljs-keyword">return</span> ResponseResult.okResult(apAuthor);
    }</code></pre></div>
<p>(2) 在用户微服务中的ArticleFeign接口中新增方法</p>
<div><pre class="hljs"><code>    <span class="hljs-comment">/**
     * 根据id查询作者
     * <span class="hljs-doctag">@param</span> id
     * <span class="hljs-doctag">@return</span>
     */</span>
    <span class="hljs-meta">@GetMapping("/api/v1/author/{id}")</span>
    <span class="hljs-keyword">public</span> ResponseResult&lt;ApAuthor&gt; <span class="hljs-title function_">getAuthor</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable("id")</span> Integer id)</span>;</code></pre></div>
<h4 id="332-获取用户id">3.3.2 获取用户ID</h4>
<p>业务层中需要使用到当前用户信息，所以需要设置filter来获取用户id，参考自媒体微服务</p>
<p>在common模块添加本地线程工具</p>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.heima.common.util;

<span class="hljs-keyword">import</span> com.heima.common.dto.User;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppThreadLocalUtil</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;User&gt; tl = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();

    <span class="hljs-comment">/**
     * 设置用户
     * <span class="hljs-doctag">@param</span> user
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(User user)</span>{
        tl.set(user);
    }

    <span class="hljs-comment">/**
     * 获取用户
     * <span class="hljs-doctag">@return</span>
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> User <span class="hljs-title function_">get</span><span class="hljs-params">()</span>{
        <span class="hljs-keyword">return</span> tl.get();
    }

    <span class="hljs-comment">/**
     * 删除用户  防止内存泄露
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span>{
        tl.remove();
    }
}
</code></pre></div>
<p>在user服务新建拦截器</p>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.heima.user.interceptor;

<span class="hljs-keyword">import</span> com.heima.common.dto.User;
<span class="hljs-keyword">import</span> com.heima.common.util.AppThreadLocalUtil;
<span class="hljs-keyword">import</span> org.springframework.util.StringUtils;
<span class="hljs-keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;
<span class="hljs-keyword">import</span> org.springframework.web.servlet.ModelAndView;

<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;
<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> {

    <span class="hljs-comment">/**
     * 前置过滤
     *
     * <span class="hljs-doctag">@param</span> request
     * <span class="hljs-doctag">@param</span> response
     * <span class="hljs-doctag">@param</span> handler
     * <span class="hljs-doctag">@return</span>
     * <span class="hljs-doctag">@throws</span> Exception
     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 从请求头中获取用户信息  userId</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">"userId"</span>);
        <span class="hljs-comment">// 将用户信息存入到ThreadLocal</span>
        <span class="hljs-keyword">if</span> (!StringUtils.isEmpty(userId)) {
            <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();
            user.setUserId(Integer.parseInt(userId));
            AppThreadLocalUtil.set(user);
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-comment">/**
     * 后置过滤
     *
     * <span class="hljs-doctag">@param</span> request
     * <span class="hljs-doctag">@param</span> response
     * <span class="hljs-doctag">@param</span> handler
     * <span class="hljs-doctag">@param</span> modelAndView
     * <span class="hljs-doctag">@throws</span> Exception
     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception {
        AppThreadLocalUtil.remove();
    }
}
</code></pre></div>
<p>添加配置类</p>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.heima.user.config;

<span class="hljs-keyword">import</span> com.heima.user.interceptor.UserInterceptor;
<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;
<span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;
<span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> {
        registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserInterceptor</span>())  <span class="hljs-comment">// 添加拦截器</span>
                .addPathPatterns(<span class="hljs-string">"/**"</span>);    <span class="hljs-comment">// 添加拦截的路径</span>
    }
}
</code></pre></div>
<h4 id="333-接口定义">3.3.3 接口定义</h4>
<p>ApUserController</p>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.heima.user.controller;

<span class="hljs-keyword">import</span> com.baomidou.mybatisplus.core.conditions.Wrapper;
<span class="hljs-keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
<span class="hljs-keyword">import</span> com.baomidou.mybatisplus.core.toolkit.StringUtils;
<span class="hljs-keyword">import</span> com.heima.common.dto.ResponseResult;
<span class="hljs-keyword">import</span> com.heima.user.dto.UserRelationDto;
<span class="hljs-keyword">import</span> io.swagger.annotations.Api;
<span class="hljs-keyword">import</span> io.swagger.annotations.ApiOperation;
<span class="hljs-keyword">import</span> io.swagger.annotations.ApiImplicitParam;
<span class="hljs-keyword">import</span> io.swagger.annotations.ApiImplicitParams;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.*;
<span class="hljs-keyword">import</span> com.baomidou.mybatisplus.core.metadata.IPage;
<span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.plugins.pagination.Page;
<span class="hljs-keyword">import</span> com.heima.user.service.IApUserService;

<span class="hljs-keyword">import</span> java.util.List;
<span class="hljs-keyword">import</span> java.util.Map;

<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;

<span class="hljs-comment">/**
 * &lt;p&gt;
 * APP用户信息表 前端控制器
 * &lt;/p&gt;
 *
 * <span class="hljs-doctag">@author</span> mcm
 * <span class="hljs-doctag">@since</span> 2021-05-19
 */</span>
<span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@RequestMapping("/api/v1/user")</span>
<span class="hljs-meta">@Api(tags = "APP用户信息表接口")</span>
<span class="hljs-meta">@CrossOrigin</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApUserController</span> {

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> IApUserService apUserService;

    <span class="hljs-comment">/**
     * 关注和取消关注
     * <span class="hljs-doctag">@param</span> dto
     * <span class="hljs-doctag">@return</span>
     */</span>
    <span class="hljs-meta">@PostMapping("/user_follow")</span>
    <span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title function_">follow</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> UserRelationDto dto)</span> {
        <span class="hljs-keyword">return</span> apUserService.follow(dto);
    }

}
</code></pre></div>
<p>UserRelationDto</p>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.heima.user.dto;

<span class="hljs-keyword">import</span> lombok.Data;

<span class="hljs-meta">@Data</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserRelationDto</span> {

    <span class="hljs-comment">// 文章作者ID</span>
    Integer authorId;

    <span class="hljs-comment">// 文章id</span>
    Long articleId;
    <span class="hljs-comment">/**
     * 操作方式
     * 0  关注
     * 1  取消
     */</span>
    Integer operation;
    <span class="hljs-comment">// 设备id</span>
    String equipmentId;
}</code></pre></div>
<h4 id="334-业务层">3.3.4 业务层</h4>
<p>业务层接口</p>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IApUserService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IService</span>&lt;ApUser&gt; {
    ResponseResult <span class="hljs-title function_">follow</span><span class="hljs-params">(UserRelationDto dto)</span>;
}</code></pre></div>
<p>实现类<code>ApUserServiceImpl</code>：</p>
<div><pre class="hljs"><code>    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> ArticleFeign articleFeign;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> IApUserFollowService followService;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title function_">follow</span><span class="hljs-params">(UserRelationDto dto)</span> {
        <span class="hljs-comment">// 构建关注表对象</span>
        <span class="hljs-type">ApUserFollow</span> <span class="hljs-variable">follow</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApUserFollow</span>();
        <span class="hljs-comment">// 从本地线程获取用户</span>
        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> AppThreadLocalUtil.get();
        <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span> ResponseResult.errorResult(AppHttpCodeEnum.NEED_LOGIN);
        }
        follow.setUserId(user.getUserId());
        <span class="hljs-type">ApUser</span> <span class="hljs-variable">apUser</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getById(user.getUserId());
        follow.setUserName(apUser.getName());
        <span class="hljs-comment">// 获取作者对应的user_id</span>
        ResponseResult&lt;ApAuthor&gt; authorResponseResult = articleFeign.getAuthor(dto.getAuthorId());
        <span class="hljs-keyword">if</span> (authorResponseResult.getCode().equals(AppHttpCodeEnum.SUCCESS.getCode())) {
            <span class="hljs-type">ApAuthor</span> <span class="hljs-variable">author</span> <span class="hljs-operator">=</span> authorResponseResult.getData();
            follow.setFollowId(author.getUserId());
            follow.setFollowName(author.getName());
        }
        follow.setLevel(<span class="hljs-number">1</span>);
        follow.setCreatedTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());
        <span class="hljs-comment">// 判断当前登录用户与关注作者是否已经有历史记录</span>
        LambdaQueryWrapper&lt;ApUserFollow&gt; query = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();
        query.eq(ApUserFollow::getUserId, user.getUserId());
        query.eq(ApUserFollow::getFollowId, follow.getFollowId());
        <span class="hljs-type">ApUserFollow</span> <span class="hljs-variable">one</span> <span class="hljs-operator">=</span> followService.getOne(query);
        <span class="hljs-keyword">if</span> (one == <span class="hljs-literal">null</span>) {
            <span class="hljs-comment">// 判断如果是关注,新增记录</span>
            <span class="hljs-keyword">if</span> (dto.getOperation() == <span class="hljs-number">0</span>) {
                <span class="hljs-comment">// 保存关注记录</span>
                followService.save(follow);
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 如果用户操作是取消关注,需要删除对应的记录</span>
            <span class="hljs-keyword">if</span> (dto.getOperation() == <span class="hljs-number">1</span>) {
                followService.remove(query);
            }
        }
     
        <span class="hljs-keyword">return</span> ResponseResult.okResult();
    }</code></pre></div>
<p>5.4 关注操作发送消息</p>
<h2 id="4-用户操作行为">4 用户操作行为</h2>
<p>用户行为数据的记录包括了关注、点赞、不喜欢、收藏、阅读等行为</p>
<p>这些行为与当前app端的功能实现没有任何关系，即使没有行为数据，功能也不耽误实现，那为什么要做行为数据的保存呢？</p>
<p>黑马头条项目整个项目开发涉及web展示和大数据分析来给用户推荐文章，如何找出哪些文章是热点文章进行针对性的推荐呢？这个时候需要进行大数据分析的准备工作，埋点。</p>
<p>所谓“埋点”，是数据采集领域（尤其是用户行为数据采集领域）的术语，指的是针对特定用户行为或事件进行捕获、处理和发送的相关技术及其实施过程。比如用户某个icon点击次数、阅读文章的时长，观看视频的时长等等。</p>
<h3 id="41-数据存储说明">4.1 数据存储说明</h3>
<p>用户的行为记录，需要给每一个用户都保存一份，数据量较大，要求加载速度快，通常这样的数据存储到MongoDB更合适，不建议直接存储到关系型数据库中.</p>
<p><img src="/_resources/d0d097e47dd244a7ae690fb8b4534363.png" /></p>
<h3 id="42-mongodb安装">4.2 MongoDB安装</h3>
<p>虚拟机中执行</p>
<div><pre class="hljs"><code>cd /opt/hmtt/nosql
./start.sh</code></pre></div>
<h3 id="43-行为微服务搭建">4.3 行为微服务搭建</h3>
<p>处理行为是一个量比较大的操作，所以专门创建一个微服务来处理行为相关操作</p>
<p>新建模块heima-leadnews-behavior</p>
<p><img src="/_resources/26dbdabf67784ef4bc005e4e84247e9b.png" /></p>
<p>添加依赖</p>
<div><pre class="hljs"><code>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div>
<p>application.yml</p>
<div><pre class="hljs"><code><span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">9005</span>
<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">leadnews-behavior</span>
  <span class="hljs-attr">data:</span>
    <span class="hljs-attr">mongodb:</span>
      <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.85</span><span class="hljs-number">.143</span>
      <span class="hljs-attr">port:</span> <span class="hljs-number">27017</span>
      <span class="hljs-attr">database:</span> <span class="hljs-string">leadnews_behavior</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">nacos:</span>
      <span class="hljs-attr">discovery:</span>
        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.85</span><span class="hljs-number">.143</span><span class="hljs-string">:8848</span>
</code></pre></div>
<p><strong>其他配置项请参考其他微服务：通用异常等</strong></p>
<h3 id="44-关注行为">4.4 关注行为</h3>
<p>在用户微服务中搭建kafka的环境，并且修改用户关注代码</p>
<p>kafka环境，在application.yml添加配置</p>
<div><pre class="hljs"><code><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">leadnews-user</span>
  <span class="hljs-attr">kafka:</span>
    <span class="hljs-attr">bootstrap-servers:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.85</span><span class="hljs-number">.143</span><span class="hljs-string">:9092</span>
    <span class="hljs-attr">producer:</span>
      <span class="hljs-attr">key-serializer:</span> <span class="hljs-string">org.apache.kafka.common.serialization.StringSerializer</span>
      <span class="hljs-attr">value-serializer:</span> <span class="hljs-string">org.apache.kafka.common.serialization.StringSerializer</span></code></pre></div>
<p>发送消息需要准备一个FollowBehaviorDto,进行数据的传递</p>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.heima.user.dto;

<span class="hljs-keyword">import</span> lombok.Data;

<span class="hljs-meta">@Data</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FollowBehaviorDto</span> {
    <span class="hljs-comment">/**
     * 关注id
     */</span>
    <span class="hljs-keyword">private</span> Integer followId;
    <span class="hljs-comment">/**
     * 设备id
     */</span>
    <span class="hljs-keyword">private</span> String equipmentId;
    <span class="hljs-comment">/**
     * 用户id
     */</span>
    <span class="hljs-keyword">private</span> Integer userId;

    <span class="hljs-comment">/**
     * 操作类型 0  关注  1 取消关注
     */</span>
    <span class="hljs-keyword">private</span> Integer operation;

}</code></pre></div>
<p>新建配置，发送关注行为消息的topic</p>
<div><pre class="hljs"><code><span class="hljs-attr">topic:</span>
  <span class="hljs-attr">followBehaviorTopic:</span> <span class="hljs-string">follow_behavior_topic</span></code></pre></div>
<p>修改follow方法，添加发送消息的代码</p>
<p>需要在当前类中注入<code>KafkaTemplate</code></p>
<p>发送消息</p>
<div><pre class="hljs"><code>    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> ArticleFeign articleFeign;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> IApUserFollowService followService;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title function_">follow</span><span class="hljs-params">(UserRelationDto dto)</span> {
        <span class="hljs-comment">// 构建关注表对象</span>
        <span class="hljs-type">ApUserFollow</span> <span class="hljs-variable">follow</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApUserFollow</span>();
        <span class="hljs-comment">// 从本地线程获取用户</span>
        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> AppThreadLocalUtil.get();
        <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span> ResponseResult.errorResult(AppHttpCodeEnum.NEED_LOGIN);
        }
        follow.setUserId(user.getUserId());
        <span class="hljs-type">ApUser</span> <span class="hljs-variable">apUser</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getById(user.getUserId());
        follow.setUserName(apUser.getName());
        <span class="hljs-comment">// 获取作者对应的user_id</span>
        ResponseResult&lt;ApAuthor&gt; authorResponseResult = articleFeign.getAuthor(dto.getAuthorId());
        <span class="hljs-keyword">if</span> (authorResponseResult.getCode().equals(AppHttpCodeEnum.SUCCESS.getCode())) {
            <span class="hljs-type">ApAuthor</span> <span class="hljs-variable">author</span> <span class="hljs-operator">=</span> authorResponseResult.getData();
            follow.setFollowId(author.getUserId());
            follow.setFollowName(author.getName());
        }
        follow.setLevel(<span class="hljs-number">1</span>);
        follow.setCreatedTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());
        <span class="hljs-comment">// 判断当前登录用户与关注作者是否已经有历史记录</span>
        LambdaQueryWrapper&lt;ApUserFollow&gt; query = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();
        query.eq(ApUserFollow::getUserId, user.getUserId());
        query.eq(ApUserFollow::getFollowId, follow.getFollowId());
        <span class="hljs-type">ApUserFollow</span> <span class="hljs-variable">one</span> <span class="hljs-operator">=</span> followService.getOne(query);
        <span class="hljs-keyword">if</span> (one == <span class="hljs-literal">null</span>) {
            <span class="hljs-comment">// 判断如果是关注,新增记录</span>
            <span class="hljs-keyword">if</span> (dto.getOperation() == <span class="hljs-number">0</span>) {
                <span class="hljs-comment">// 保存关注记录</span>
                followService.save(follow);
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 如果用户操作是取消关注,需要删除对应的记录</span>
            <span class="hljs-keyword">if</span> (dto.getOperation() == <span class="hljs-number">1</span>) {
                followService.remove(query);
            }
        }
        <span class="hljs-comment">// 发送消息到kafka</span>
        <span class="hljs-type">FollowBehaviorDto</span> <span class="hljs-variable">followBehaviorDto</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FollowBehaviorDto</span>();
        followBehaviorDto.setUserId(user.getUserId());
        followBehaviorDto.setFollowId(follow.getFollowId());
        followBehaviorDto.setOperation(dto.getOperation());
        followBehaviorDto.setEquipmentId(dto.getEquipmentId());
        <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> JSON.toJSONString(followBehaviorDto);
        kafkaTemplate.send(followBehaviorTopic, json);
        <span class="hljs-keyword">return</span> ResponseResult.okResult();
    }

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> KafkaTemplate&lt;String, String&gt; kafkaTemplate;

    <span class="hljs-meta">@Value("${topic.followBehaviorTopic}")</span>
    <span class="hljs-keyword">private</span> String followBehaviorTopic;</code></pre></div>
<h3 id="44-行为微服务记录">4.4 行为微服务记录</h3>
<p>实体类 ApFollowBehavior</p>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.heima.behavior.entity;

<span class="hljs-keyword">import</span> java.util.Date;
<span class="hljs-keyword">import</span> java.io.Serializable;
<span class="hljs-keyword">import</span> io.swagger.annotations.ApiModel;
<span class="hljs-keyword">import</span> io.swagger.annotations.ApiModelProperty;
<span class="hljs-keyword">import</span> lombok.Data;
<span class="hljs-keyword">import</span> lombok.EqualsAndHashCode;
<span class="hljs-keyword">import</span> org.springframework.data.annotation.Id;
<span class="hljs-keyword">import</span> org.springframework.data.mongodb.core.mapping.Document;

<span class="hljs-comment">/**
 * &lt;p&gt;
 * APP关注行为表
 * &lt;/p&gt;
 *
 * <span class="hljs-doctag">@author</span> mcm
 * <span class="hljs-doctag">@since</span> 2022-03-17
 */</span>
<span class="hljs-meta">@Data</span>
<span class="hljs-meta">@EqualsAndHashCode(callSuper = false)</span>
<span class="hljs-meta">@Document("ap_follow_behavior")</span>
<span class="hljs-meta">@ApiModel(description="APP关注行为表")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApFollowBehavior</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;

    <span class="hljs-meta">@Id</span>
    <span class="hljs-keyword">private</span> String id;

    <span class="hljs-comment">/**
     * 用户ID
     */</span>
    <span class="hljs-meta">@ApiModelProperty(value = "用户ID")</span>
    <span class="hljs-keyword">private</span> Integer userId;

    <span class="hljs-comment">/**
     * 设备ID
     */</span>
    <span class="hljs-meta">@ApiModelProperty(value = "设备ID")</span>
    <span class="hljs-keyword">private</span> String equipmentId;

    <span class="hljs-comment">/**
     * 关注用户ID
     */</span>
    <span class="hljs-meta">@ApiModelProperty(value = "关注用户ID")</span>
    <span class="hljs-keyword">private</span> Integer followId;

    <span class="hljs-comment">/**
     * 操作类型: 0 关注 1 取消关注
     */</span>
    <span class="hljs-meta">@ApiModelProperty(value = "操作类型: 0 关注 1 取消关注")</span>
    <span class="hljs-keyword">private</span> Integer operation;

    <span class="hljs-comment">/**
     * 登录时间
     */</span>
    <span class="hljs-meta">@ApiModelProperty(value = "登录时间")</span>
    <span class="hljs-keyword">private</span> Date createdTime;


}

</code></pre></div>
<p>关注行为业务层接口</p>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.heima.behavior.service;

<span class="hljs-keyword">import</span> com.heima.behavior.dto.FollowBehaviorDto;
<span class="hljs-keyword">import</span> com.heima.behavior.entity.ApFollowBehavior;

<span class="hljs-comment">/**
 * &lt;p&gt;
 * APP关注行为表 服务类
 * &lt;/p&gt;
 *
 * <span class="hljs-doctag">@author</span> mcm
 * <span class="hljs-doctag">@since</span> 2021-09-07
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IApFollowBehaviorService</span> {

    <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveFollow</span><span class="hljs-params">(FollowBehaviorDto behaviorDto)</span>;
}
</code></pre></div>
<p>实现类：</p>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.heima.behavior.service.impl;

<span class="hljs-keyword">import</span> com.heima.behavior.dto.FollowBehaviorDto;
<span class="hljs-keyword">import</span> com.heima.behavior.entity.ApFollowBehavior;
<span class="hljs-keyword">import</span> com.heima.behavior.service.IApFollowBehaviorService;
<span class="hljs-keyword">import</span> org.springframework.beans.BeanUtils;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;
<span class="hljs-keyword">import</span> org.springframework.data.mongodb.core.MongoTemplate;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Service;

<span class="hljs-keyword">import</span> java.util.Date;

<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApFollowBehaviorServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IApFollowBehaviorService</span> {

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> MongoTemplate mongoTemplate;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveFollow</span><span class="hljs-params">(FollowBehaviorDto dto)</span> {
        <span class="hljs-type">ApFollowBehavior</span> <span class="hljs-variable">followBehavior</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApFollowBehavior</span>();
        BeanUtils.copyProperties(dto, followBehavior);
        followBehavior.setCreatedTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());
        mongoTemplate.save(followBehavior);
    }
}
</code></pre></div>
<p>(4)在行为微服务中集成kafka，并且创建监听</p>
<div><pre class="hljs"><code><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">leadnews-behavior</span>
  <span class="hljs-attr">kafka:</span>
    <span class="hljs-attr">bootstrap-servers:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.85</span><span class="hljs-number">.143</span><span class="hljs-string">:9092</span>
    <span class="hljs-attr">consumer:</span>
      <span class="hljs-attr">group-id:</span> <span class="hljs-string">${spring.application.name}</span>
      <span class="hljs-attr">key-deserializer:</span> <span class="hljs-string">org.apache.kafka.common.serialization.StringDeserializer</span>
      <span class="hljs-attr">value-deserializer:</span> <span class="hljs-string">org.apache.kafka.common.serialization.StringDeserializer</span></code></pre></div>
<p>添加队列配置</p>
<div><pre class="hljs"><code><span class="hljs-attr">topic:</span>
  <span class="hljs-attr">followBehaviorTopic:</span> <span class="hljs-string">follow_behavior_topic</span></code></pre></div>
<p>消息监听类：</p>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.heima.behavior.listener;

<span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;
<span class="hljs-keyword">import</span> com.heima.behavior.dto.FollowBehaviorDto;
<span class="hljs-keyword">import</span> com.heima.behavior.service.IApFollowBehaviorService;
<span class="hljs-keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecord;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;
<span class="hljs-keyword">import</span> org.springframework.kafka.annotation.KafkaListener;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Service;

<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FollowListener</span> {

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> IApFollowBehaviorService followBehaviorService;

    <span class="hljs-meta">@KafkaListener(topics = "${topic.followBehaviorTopic}")</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(ConsumerRecord&lt;String, String&gt; record)</span> {
        System.out.println(<span class="hljs-string">"接收到消息:  value = "</span> + record.value());
        <span class="hljs-comment">// 将JSON消息转换成dto</span>
        <span class="hljs-type">FollowBehaviorDto</span> <span class="hljs-variable">dto</span> <span class="hljs-operator">=</span> JSON.parseObject(record.value(), FollowBehaviorDto.class);
        followBehaviorService.saveFollow(dto);
    }
}
</code></pre></div>
<p>(3) 测试</p>
<p>在app端文章详情中，当点击关注按钮的时候，会往ap_follow_behavior表中插入数据。</p>
</div>
      </article>
    </div>
  </body>
</html>
