<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta http-equiv="X-UA-Compatible" content="ie=edge" />
<link rel="stylesheet" href="/_assets/main.css" />

    <title>day5-Collection、Iterator、泛型、数据结构 - zblog</title>
  <link rel="stylesheet" href="/_markdown_plugin_assets/highlight.js/atom-one-light.css" /></head>
  <body>
    <div class="main">
      <nav class="navigation">
        <a href="/">zblog</a>
      </nav>
      <article>
        <header>
          <h1 class="article-title">day5-Collection、Iterator、泛型、数据结构</h1>
          <div class="article-info">
            <div>
              <span
                >Created At：<time datetime="1637833692997"
                  >2021-11-25 17:48</time
                ></span
              >
              <span
                >Updated At：<time datetime="1638180109165"
                  >2021-11-29 18:01</time
                ></span
              >
            </div>
            
          </div>
        </header>
        <div class="article-content markdown-body"><nav class="table-of-contents"><ul><li><a href="#学习目标">学习目标</a></li><li><a href="#第一章-collection集合">第一章 Collection集合</a><ul><li><a href="#1集合和数组的区别">1.集合和数组的区别</a></li><li><a href="#2集合常用类的继承体系">2.集合常用类的继承体系</a></li><li><a href="#3collection常用功能重点">3.Collection常用功能(重点)</a></li></ul></li><li><a href="#第二章-iterator迭代器">第二章 Iterator迭代器</a><ul><li><a href="#1迭代器的概述">1.迭代器的概述</a></li><li><a href="#2迭代器的基本使用重点">2.迭代器的基本使用(重点)</a></li><li><a href="#3迭代器的执行原理了解">3.迭代器的执行原理(了解)</a></li><li><a href="#4迭代器的并发修改异常了解-面试">4.迭代器的并发修改异常(了解-面试)</a></li><li><a href="#6增强for循环重点">6.增强for循环(重点)</a></li></ul></li><li><a href="#第三章-泛型">第三章 泛型</a><ul><li><a href="#1泛型的概述">1.泛型的概述</a></li><li><a href="#2使用泛型的好处">2.使用泛型的好处</a></li><li><a href="#3定义和使用含有泛型的类">3.定义和使用含有泛型的类</a></li><li><a href="#4定义和使用含有泛型的方法重点">4.定义和使用含有泛型的方法(重点)</a></li><li><a href="#5定义和使用含有泛型的接口">5.定义和使用含有泛型的接口</a></li><li><a href="#6泛型的通配符">6.泛型的通配符</a></li></ul></li><li><a href="#第四章-数据结构">第四章 数据结构</a><ul><li><a href="#1数据结构_栈先进后出">1.数据结构_栈:先进后出</a></li><li><a href="#2数据结构_队列先进先出">2.数据结构_队列:先进先出</a></li><li><a href="#3数据结构_数组查询快增删慢">3.数据结构_数组:查询快,增删慢</a></li><li><a href="#4数据结构_链表查询慢增删快">4.数据结构_链表:查询慢,增删快</a></li><li><a href="#5数据结构_红黑树查询的速度特别快">5.数据结构_红黑树:查询的速度特别快</a></li></ul></li></ul></nav><h1 id="学习目标">学习目标</h1>
<div><pre class="hljs"><code>能够说出集合与数组的区别
    数组:
        <span class="hljs-number">1.</span>是引用数据类型的一种,可以存储多个元素
        <span class="hljs-number">2.</span>数组的长度是固定的 <span class="hljs-type">int</span>[] arr1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];  <span class="hljs-type">int</span>[] arr2 = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>};
        <span class="hljs-number">3.</span>数组即可以存储基本类型的数据,又可以存储引用数据类型的数据
            <span class="hljs-type">int</span>[],<span class="hljs-type">double</span>[],String[],Student[]
    集合:
        <span class="hljs-number">1.</span>是引用数据类型的一种,可以存储多个元素
        <span class="hljs-number">2.</span>集合的长度是可以变化的(可以往集合中添加元素,删除集合中的元素)
        <span class="hljs-number">3.</span>只能存储引用数据类型的数据
            ArrayList&lt;<span class="hljs-type">int</span>&gt; 错误	ArrayList&lt;Integer&gt;	ArrayList&lt;Student&gt;
能够使用Collection集合的常用功能(重点)
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> ： 把给定的对象添加到当前集合中 。
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(E e)</span> : 把给定的对象在当前集合中删除。
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object obj)</span> : 判断当前集合中是否包含给定的对象。
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> : 判断当前集合是否为空。
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> : 返回集合中元素的个数。
    <span class="hljs-keyword">public</span> Object[] toArray() : 把集合中的元素，存储到数组中
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> :清空集合中所有的元素。
能够使用迭代器对集合进行取元素(重点)
    <span class="hljs-comment">//创建集合对象</span>
    Collection&lt;String&gt; coll = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
    coll.add(<span class="hljs-string">"西施"</span>);
    coll.add(<span class="hljs-string">"貂蝉"</span>);
    coll.add(<span class="hljs-string">"王昭君"</span>);
    coll.add(<span class="hljs-string">"杨贵妃"</span>);
    <span class="hljs-comment">//1.使用Collection接口中的方法iterator获取迭代器的实现类对象</span>
    Iterator&lt;String&gt; it = coll.iterator();
    <span class="hljs-comment">//2.使用迭代器Iterator中的方法hasNext判断集合中是否还有元素</span>
    <span class="hljs-keyword">while</span> (it.hasNext()){
        <span class="hljs-comment">//3.集合中有元素,使用迭代器Iterator中的方法next取出元素</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> it.next();
        System.out.println(s);
    }	
能够使用增强<span class="hljs-keyword">for</span>循环遍历集合和数组(重点)
    <span class="hljs-keyword">for</span>(集合|数组中元素的数据类型 变量名: 集合|数组){
        sout(变量名);
    }
    <span class="hljs-type">int</span>[] arr = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>};
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : arr){
        sout(i);
    }
    ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
    list.add(<span class="hljs-string">"a"</span>);
    list.add(<span class="hljs-string">"b"</span>);
    <span class="hljs-keyword">for</span>(String s : list){
        sout(s);
    }
能够理解泛型上下限
    泛型的上限限定: ? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">E</span> ==&gt;传递的未知类型?只能是E的子类或者本身
    泛型的下限限定: ? <span class="hljs-type">super</span> <span class="hljs-variable">E</span>   <span class="hljs-operator">=</span>=&gt;传递的未知类型?只能是E的父类或者本身
能够阐述泛型通配符的作用
    泛型的通配符: ?  可以接收任意的数据类型
能够说出常见的数据结构
    栈,队列,数组,链表,红黑树
能够说出数组结构特点
    查询快,增删慢
能够说出栈结构特点
    先进后出
能够说出队列结构特点
    先进先出
能够说出单向(双向)链表结构特点
    查询慢,增删快
    单向:是一个无序
    双向:是一个有序</code></pre></div>
<h1 id="第一章-collection集合">第一章 Collection集合</h1>
<h2 id="1集合和数组的区别">1.集合和数组的区别</h2>
<p>数组:</p>
<ol>
<li>
<p>是引用数据类型的一种,可以存储多个元素</p>
</li>
<li>
<p>数组的长度是固定的 int[] arr1 = new int[10];  int[] arr2 = {1,2,3};</p>
</li>
<li>
<p>数组即可以存储基本数据类型的数据,又可以存储引用数据类型的数据 int[] double[] String[] Student[]</p>
</li>
</ol>
<p>集合:</p>
<ol>
<li>
<p>是引用数据类型的一种,可以存储多个元素</p>
</li>
<li>
<p>集合的长度是可以变化的(添加元素,删除集合中的元素)</p>
</li>
<li>
<p>集合只能存储引用数据类型的数据</p>
</li>
</ol>
<p><code>ArrayList&lt;int&gt; 错误  ArrayList&lt;Integer&gt;  ArrayList&lt;Student&gt; ArrayList&lt;String&gt;正确</code></p>
<h2 id="2集合常用类的继承体系">2.集合常用类的继承体系</h2>
<p><img src="/_resources/2c65d9dc7905400989b2ed2e51b45d00.png" /></p>
<h2 id="3collection常用功能重点">3.Collection常用功能(重点)</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo01Collection;

<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Collection;
<span class="hljs-keyword">import</span> java.util.HashSet;
<span class="hljs-keyword">import</span> java.util.LinkedList;

<span class="hljs-comment">/*
    Collection常用功能(重点)
    public boolean add(E e) ： 把给定的对象添加到当前集合中 。
    public boolean remove(E e) : 把给定的对象在当前集合中删除。
    public boolean contains(Object obj) : 判断当前集合中是否包含给定的对象。
    public boolean isEmpty() : 判断当前集合是否为空。
    public int size() : 返回集合中元素的个数。
    public Object[] toArray() : 把集合中的元素，存储到数组中
    public void clear() :清空集合中所有的元素。
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01Collection</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">//1.使用多态的方式创建集合对象  接口 = 实现类对象   父类=子类对象</span>
        Collection&lt;String&gt; coll = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        <span class="hljs-comment">//Collection&lt;String&gt; coll = new LinkedList&lt;&gt;();</span>
        <span class="hljs-comment">//Collection&lt;String&gt; coll = new HashSet&lt;&gt;();</span>
        
        System.out.println(coll.isEmpty());<span class="hljs-comment">//true</span>
        <span class="hljs-comment">/*
            public boolean add(E e) :往集合的末尾追加元素
            返回值:boolean
                添加成功,返回true
                添加失败,返回false
         */</span>
        <span class="hljs-type">boolean</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> coll.add(<span class="hljs-string">"张三"</span>);
        System.out.println(<span class="hljs-string">"b1:"</span>+b1);
        coll.add(<span class="hljs-string">"李四"</span>);
        coll.add(<span class="hljs-string">"张三"</span>);
        coll.add(<span class="hljs-string">"王五"</span>);
        coll.add(<span class="hljs-string">"赵六"</span>);
        coll.add(<span class="hljs-string">"田七"</span>);
        System.out.println(coll);<span class="hljs-comment">//[张三, 李四, 张三, 王五, 赵六, 田七]</span>
        <span class="hljs-comment">/*
            public boolean remove(E e) 移除集合中指定的元素
            返回值:boolean
                集合中有指定元素,移除成功,返回true
                集合中没有指定的元素,移除失败,返回false
            注意:
                集合中有重复的元素,只移除第一个
         */</span>
        <span class="hljs-type">boolean</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> coll.remove(<span class="hljs-string">"张三"</span>);
        System.out.println(<span class="hljs-string">"b2:"</span>+b2);<span class="hljs-comment">//b2:true</span>
        System.out.println(coll);<span class="hljs-comment">//[李四, 张三, 王五, 赵六, 田七]</span>

        <span class="hljs-type">boolean</span> <span class="hljs-variable">b3</span> <span class="hljs-operator">=</span> coll.remove(<span class="hljs-string">"赵四"</span>);
        System.out.println(<span class="hljs-string">"b3:"</span>+b3);<span class="hljs-comment">//b3:false</span>
        System.out.println(coll);<span class="hljs-comment">//[李四, 张三, 王五, 赵六, 田七]</span>

        <span class="hljs-comment">/*
            contains:包含
            public boolean contains(Object obj) : 判断当前集合中是否包含给定的对象。
            返回值:boolean
                集合中有指定元素,返回true
                集合中没有指定的元素,返回false
         */</span>
        <span class="hljs-type">boolean</span> <span class="hljs-variable">b4</span> <span class="hljs-operator">=</span> coll.contains(<span class="hljs-string">"田七"</span>);
        System.out.println(<span class="hljs-string">"b4:"</span>+b4);<span class="hljs-comment">//b4:true</span>
        <span class="hljs-type">boolean</span> <span class="hljs-variable">b5</span> <span class="hljs-operator">=</span> coll.contains(<span class="hljs-string">"胡歌"</span>);
        System.out.println(<span class="hljs-string">"b5:"</span>+b5);<span class="hljs-comment">//b5:false</span>

        <span class="hljs-comment">/*
            Empty:空的
            public boolean isEmpty() : 判断当前集合是否为空。
            返回值:boolean
                集合是空的,里边没有元素,返回true
                集合不是空的,里边有元素,返回false
         */</span>
        <span class="hljs-type">boolean</span> <span class="hljs-variable">b6</span> <span class="hljs-operator">=</span> coll.isEmpty();
        System.out.println(<span class="hljs-string">"b6:"</span>+b6);<span class="hljs-comment">//b6:false</span>

        <span class="hljs-comment">/*
            public int size() : 返回集合中元素的个数。集合长度
         */</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> coll.size();
        System.out.println(<span class="hljs-string">"size:"</span>+size);

        <span class="hljs-comment">/*
            public Object[] toArray() : 把集合中的元素，存储到数组中
         */</span>
        Object[] arr = coll.toArray();
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
            System.out.println(arr[i]);
        }

        <span class="hljs-comment">/*
            clear:清除
            public void clear() :清空集合中所有的元素。
            注意:
                此方法仅仅是清空集合中的元素,集合对象还可以使用
         */</span>
        coll.clear();
        System.out.println(coll);<span class="hljs-comment">//[]</span>
        coll.add(<span class="hljs-string">"itheima"</span>);
        System.out.println(coll);<span class="hljs-comment">//[itheima]</span>
    }
}</code></pre></div>
<h1 id="第二章-iterator迭代器">第二章 Iterator迭代器</h1>
<h2 id="1迭代器的概述">1.迭代器的概述</h2>
<p><strong>迭代器:遍历集合</strong></p>
<div><pre class="hljs"><code><span class="hljs-comment">/*
    迭代器:是一种通用取出集合中元素的方式
    迭代器的由来:
        集合有很多种,每种集合的数据结构不同(数组,链表,哈希表...),集合取出元素的方式也不同
        我们不可能为每种集合都定义一种取出元素的方式,浪费
        所以我们可以使用迭代器,是集合通用的取出元素的方式
    迭代器的原理:
        判断集合中还有没有元素,有就取出来;
        再判断集合中还有没有元素,有再取出来;
        一直判断到集合中没有元素为止,这种取出元素的方式叫迭代
    ------------------------------------------------------------------------------------
    java.util.Iterator&lt;E&gt;接口:对 collection 进行迭代的迭代器。
    Iterator接口的常用方法:
        boolean hasNext() 如果仍有元素可以迭代，则返回 true。
            判断集合中还没有没有元素;有返回true,没有返回false
        E next() 返回迭代的下一个元素。 取出集合中的元素
    ------------------------------------------------------------------------------------
    Iterator是一个接口无法创建对象使用,使用Iterator接口的实现类对象,Iterator接口的实现类对象是每个集合的内部类(了解)
    我们可以使用Collection接口中的方法iterator获取迭代器Iterator接口的实现类对象
        Iterator&lt;E&gt; iterator() 返回在此 collection 的元素上进行迭代的迭代器。
    注意:
        我们无需关注iterator方法返回的是接口的哪个实现类对象,我们只需要会使用Iterator接口来接收这个实现类对象即可(多态)
 */</span></code></pre></div>
<h2 id="2迭代器的基本使用重点">2.迭代器的基本使用(重点)</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo02Iterator;

<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Collection;
<span class="hljs-keyword">import</span> java.util.Iterator;

<span class="hljs-comment">/*
    迭代器的基本使用(重点)
    1.使用Collection接口中的方法iterator获取迭代器的实现类对象
    2.使用迭代器Iterator中的方法hasNext判断集合中是否还有元素
    3.集合中有元素,使用迭代器Iterator中的方法next取出元素
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01Iterator</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">//创建集合对象</span>
        Collection&lt;String&gt; coll = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        coll.add(<span class="hljs-string">"西施"</span>);
        coll.add(<span class="hljs-string">"貂蝉"</span>);
        coll.add(<span class="hljs-string">"王昭君"</span>);
        coll.add(<span class="hljs-string">"杨贵妃"</span>);
        <span class="hljs-comment">//1.使用Collection接口中的方法iterator获取迭代器的实现类对象</span>
        <span class="hljs-comment">//迭代器也是有泛型的,迭代器的泛型跟着集合走,集合是什么泛型,迭代器就是什么泛型</span>
        <span class="hljs-comment">//多态  接口 = 实现类对象</span>
        Iterator&lt;String&gt; it = coll.iterator();

        <span class="hljs-comment">/*
            我们发现,使用迭代器取出集合中的元素,是一个重复的过程
            我们不知道集合中有多少元素,也就不知道循环多少次,所以使用while循环
            循环结束的条件 it.hasNext方法返回false
         */</span>
        <span class="hljs-comment">//2.使用迭代器Iterator中的方法hasNext判断集合中是否还有元素</span>
        <span class="hljs-keyword">while</span> (it.hasNext()){
            <span class="hljs-comment">//3.集合中有元素,使用迭代器Iterator中的方法next取出元素</span>
            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> it.next();
            System.out.println(s);
        }
        System.out.println(<span class="hljs-string">"------------------------------------"</span>);
        <span class="hljs-comment">//迭代器对象,只能使用一次;想再次遍历集合,需要重新获取一个迭代器对象</span>
        Iterator&lt;String&gt; it2 = coll.iterator();
        <span class="hljs-keyword">while</span> (it2.hasNext()){
            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> it2.next();
            System.out.println(s);
        }
        System.out.println(<span class="hljs-string">"------------------------------------"</span>);
        <span class="hljs-keyword">for</span> (Iterator&lt;String&gt; it3 = coll.iterator();it3.hasNext();){
            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> it3.next();
            System.out.println(s);
        }
    }

    <span class="hljs-comment">/*
        //2.使用迭代器Iterator中的方法hasNext判断集合中是否还有元素
        boolean b = it.hasNext();
        System.out.println(b);//true

        //3.集合中有元素,使用迭代器Iterator中的方法next取出元素
        String s = it.next();
        System.out.println(s);//西施

        b = it.hasNext();
        System.out.println(b);//true
        s = it.next();
        System.out.println(s);//貂蝉

        b = it.hasNext();
        System.out.println(b);//true
        s = it.next();
        System.out.println(s);//王昭君

        b = it.hasNext();
        System.out.println(b);//true
        s = it.next();
        System.out.println(s);//杨贵妃

        b = it.hasNext();
        System.out.println(b);//false
        s = it.next();//NoSuchElementException:没有这个元素异常 没有元素了,就不能在取了
     */</span>
}
</code></pre></div>
<h2 id="3迭代器的执行原理了解">3.迭代器的执行原理(了解)</h2>
<p><img src="/_resources/e10b303ae2ea4216bdfde97dfc2225f3.png" /></p>
<h2 id="4迭代器的并发修改异常了解-面试">4.迭代器的并发修改异常(了解-面试)</h2>
<p><img src="/_resources/fcba6bf20bd8463cabdb4f67c09631f8.png" /></p>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo02Iterator;

<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Iterator;
<span class="hljs-keyword">import</span> java.util.ListIterator;

<span class="hljs-comment">/*
    迭代器的并发修改异常:在使用迭代器遍历集合的过程中,对集合长度进行了修改,迭代器就会抛出并发修改异常
    ConcurrentModificationException
    注意:
        1.并发:遍历和修改同时进行
        2.修改:修改集合的长度(添加元素,删除元素)
    解决方案:
        1.遍历集合的同时,不修改集合的长度
        2.在Iterator迭代器接口中,有一个方法叫remove
            void remove() 移除迭代器it.next方法取出的元素
            使用此方法移除元素,迭代器不会抛出并发修改异常了
        3.Iterator接口有一个子接口叫ListIterator
            在ListIterator接口定义了往集合中添加元素的方法
                public interface ListIterator&lt;E&gt;extends Iterator&lt;E&gt;
                void add(E e)  迭代器中往集合添加元素的方法
                void remove() 删除的是next方法取出的元素
       注意:
        1.如果使用迭代器中的add|remove方法,往集合中添加|删除元素
            就相当于集合和迭代器商量好了,可以往集合中添加|删除元素,迭代器就不会抛出并发修改异常了
        2.ListIterator迭代器只能遍历List接口下的集合(ArrayList,LinkedList),不能遍历Set接口下的集合(HashSet,LinkedHashSet)
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo02Iterator</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">//创建集合对象,往集合中添加元素</span>
        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        list.add(<span class="hljs-string">"aaa"</span>);
        list.add(<span class="hljs-string">"bbb"</span>);
        list.add(<span class="hljs-string">"ccc"</span>);
        list.add(<span class="hljs-string">"ddd"</span>);
        list.add(<span class="hljs-string">"eee"</span>);
        <span class="hljs-comment">//使用迭代器遍历list集合</span>
        <span class="hljs-comment">//使用集合中的方法iterator获取迭代器接口的实现类对象</span>
        Iterator&lt;String&gt; it = list.iterator();
        <span class="hljs-comment">//使用Iterator迭代器中的方法hasNext和next遍历集合</span>
        <span class="hljs-keyword">while</span> (it.hasNext()){
            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> it.next();
            System.out.println(s);

             <span class="hljs-comment">/*
                需求:增加一个判断,如果取出的元素是"ccc"
                就给集合添加一个新的元素"itcast"
                编程技巧:使用equals方法判断的时候,一般都把已知的值写在前边,防止空指针异常
             */</span>
             <span class="hljs-comment">/*if("ccc".equals(s)){
                 list.add("itcast");
             }*/</span>

             <span class="hljs-comment">/*
                需求:增加一个判断,如果取出的元素是"ccc"
                就删除"ccc"
              */</span>
             <span class="hljs-comment">/*if("ccc".equals(s)){
                 //list.remove("ccc");//使用集合删除元素的方法,会抛出并发修改异常
                 it.remove();//使用迭代器删除元素的方法,不会抛出并发修改异常
             }*/</span>
        }
        System.out.println(list);<span class="hljs-comment">//[aaa, bbb, ddd, eee]</span>
        System.out.println(<span class="hljs-string">"-----------------------------------"</span>);
        <span class="hljs-comment">//获取List接口下的迭代器</span>
        ListIterator&lt;String&gt; lit = list.listIterator();
        <span class="hljs-keyword">while</span> (lit.hasNext()){
            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> lit.next();
            System.out.println(s);
             <span class="hljs-comment">/*
                需求:增加一个判断,如果取出的元素是"ccc"
                就给集合添加一个新的元素"itcast"
                编程技巧:使用equals方法判断的时候,一般都把已知的值写在前边,防止空指针异常
             */</span>
             <span class="hljs-keyword">if</span>(<span class="hljs-string">"ccc"</span>.equals(s)){
                 <span class="hljs-comment">//list.add("itcast");//使用集合的添加方法,会抛出ConcurrentModificationException</span>
                 lit.add(<span class="hljs-string">"itcast"</span>);<span class="hljs-comment">//使用迭代器的添加方法,不会抛出ConcurrentModificationException</span>
             }
        }
        System.out.println(list);<span class="hljs-comment">//[aaa, bbb, ccc, itcast, ddd, eee]</span>
    }
}
</code></pre></div>
<h2 id="6增强for循环重点">6.增强for循环(重点)</h2>
<p><strong>注意:</strong></p>
<p>​	<strong>增强for循环底层是一个迭代器,所以在使用增强for循环遍历的时候,不能对集合的长度进行修改,否则会抛出并发修改异常</strong></p>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo03forEach;

<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Collection;

<span class="hljs-comment">/*
    增强for循环(重点)
        增强for循环底层就是一个迭代器,只是使用了for循环的方式对迭代器进行了封装,简化了迭代器的代码
        是JDK1.5之后出现的
    注意:
        在使用增强for循环遍历集合的过程中,不能修改集合的长度,会抛出迭代器的并发修改异常
    格式:
        for(数据类型 变量名 : 集合名|数组名){
            sout(变量名);
        }
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01ForEach</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        show03();
    }

    <span class="hljs-comment">/*
        普通for循环快捷键:集合名.fori
        增强for循环快捷键:集合名.for
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show03</span><span class="hljs-params">()</span> {
        ArrayList&lt;Student&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">"张三"</span>,<span class="hljs-number">18</span>));
        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">"李四"</span>,<span class="hljs-number">18</span>));
        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">"王五"</span>,<span class="hljs-number">18</span>));
        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">"赵六"</span>,<span class="hljs-number">18</span>));
        <span class="hljs-keyword">for</span> (Student s : list) {
            System.out.println(s);
        }
    }

    <span class="hljs-comment">/*
        使用增强for循环遍历集合
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show02</span><span class="hljs-params">()</span> {
        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        list.add(<span class="hljs-string">"aaa"</span>);
        list.add(<span class="hljs-string">"bbb"</span>);
        list.add(<span class="hljs-string">"ccc"</span>);
        list.add(<span class="hljs-string">"ddd"</span>);
        <span class="hljs-keyword">for</span>(String s : list){
            <span class="hljs-comment">//list.add("eeee");//ConcurrentModificationException 遍历过程中,不能修改集合长度</span>
            System.out.println(s);
        }
    }

    <span class="hljs-comment">/*
        使用增强for循环遍历数组
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show01</span><span class="hljs-params">()</span> {
        <span class="hljs-type">int</span>[] arr = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>};
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : arr){
            System.out.println(i);
        }
    }
}
</code></pre></div>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo03forEach;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> {
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> {
    }

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> {
        <span class="hljs-built_in">this</span>.name = name;
        <span class="hljs-built_in">this</span>.age = age;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Student{"</span> +
                <span class="hljs-string">"name='"</span> + name + <span class="hljs-string">'\''</span> +
                <span class="hljs-string">", age="</span> + age +
                <span class="hljs-string">'}'</span>;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> {
        <span class="hljs-built_in">this</span>.name = name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> age;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> {
        <span class="hljs-built_in">this</span>.age = age;
    }
}
</code></pre></div>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo03forEach;

<span class="hljs-comment">/*
    增强for循环:原理
    好处:
        格式简单
    弊端:
        只能遍历,不能修改数组|集合中元素的值
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo02ForEach</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">int</span>[] arr1 = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>};
        <span class="hljs-comment">//使用普通for循环遍历数组</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr1.length; i++) {
            arr1[i]*=<span class="hljs-number">2</span>;
            System.out.println(arr1[i]);
        }
        System.out.println(<span class="hljs-string">"arr1[0]:"</span>+arr1[<span class="hljs-number">0</span>]);
        System.out.println(<span class="hljs-string">"---------------------------"</span>);
        <span class="hljs-type">int</span>[] arr2 = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>};
        <span class="hljs-comment">//使用增强for循环遍历数组</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> s : arr2) {
            s *= <span class="hljs-number">2</span>;
            System.out.println(s);
        }
        System.out.println(<span class="hljs-string">"arr2[0]:"</span>+arr2[<span class="hljs-number">0</span>]);
    }
}
</code></pre></div>
<p><img src="/_resources/1bce237bf92642288906cba5cc19aa43.png" /></p>
<h1 id="第三章-泛型">第三章 泛型</h1>
<h2 id="1泛型的概述">1.泛型的概述</h2>
<p><strong>面试:什么是泛型,一种未知的数据类型,当我们不知道使用什么类型的时候,就可以使用泛型</strong></p>
<p><img src="/_resources/26f19f7d42084b9fa8f1157611adc99f.png" /></p>
<h2 id="2使用泛型的好处">2.使用泛型的好处</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo04Generic;

<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Iterator;

<span class="hljs-comment">/*
    使用泛型的好处
    注意:了解==&gt;反射
        java中的泛型是一种伪泛型,在.java文件中有泛型的概念,在生成的.class文件中是没有泛型的
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01Generic</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        show02();
    }

    <span class="hljs-comment">/*
        创建集合对象,使用泛型
        好处:
            存储的数据是什么类型,取出的也是什么类型,不需要强转,就可以使用元素特有的方法
        弊端:
            集合使用什么类型,泛型就是什么类型,就只能存储什么类型的数据
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show02</span><span class="hljs-params">()</span> {
        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        list.add(<span class="hljs-string">"abc"</span>);
        <span class="hljs-comment">//list.add(1);</span>
        Iterator&lt;String&gt; it = list.iterator();
        <span class="hljs-keyword">while</span> (it.hasNext()){
            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> it.next();
            System.out.println(s+<span class="hljs-string">"==&gt;"</span>+s.length());
        }
    }

    <span class="hljs-comment">/*
        创建集合对象,不使用泛型
        好处:
            集合的泛型默认就是Object类型,什么类型的数据都可以存储
        弊端:
            取出的元素默认是Object类型,无法使用元素特有的方法
            需要向下转型,为了防止类型转换异常,增加判断
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show01</span><span class="hljs-params">()</span> {
        <span class="hljs-type">ArrayList</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();
        list.add(<span class="hljs-string">"abc"</span>);
        list.add(<span class="hljs-number">1</span>);
        <span class="hljs-comment">//使用迭代器遍历集合</span>
        <span class="hljs-type">Iterator</span> <span class="hljs-variable">it</span> <span class="hljs-operator">=</span> list.iterator();
        <span class="hljs-keyword">while</span> (it.hasNext()){
            <span class="hljs-type">Object</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> it.next();<span class="hljs-comment">//多态 Object s = "abc";  Object s = 1;</span>
            System.out.println(s);

            <span class="hljs-comment">//想使用String类型特有的方法,获取字符串的长度</span>
            <span class="hljs-keyword">if</span>(s <span class="hljs-keyword">instanceof</span> String){
                <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> (String)s;
                System.out.println(str.length());
            }
        }
    }
}</code></pre></div>
<p>通过反编译软件,查看的class文件中,没有泛型</p>
<p><img src="/_resources/ae687d58ce674377ab94b2d377d578f8.png" /></p>
<h2 id="3定义和使用含有泛型的类">3.定义和使用含有泛型的类</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo05GenericClass;

<span class="hljs-comment">/*
    定义和使用含有泛型的类
    什么是泛型,一种未知的数据类型,当我们不知道使用什么类型的时候,就可以使用泛型
    定义格式:
       public class 类名&lt;泛型&gt;{
            类中所有使用数据类型的地方,都可以使用类上定义的泛型
       }
    当我们创建对象的时候,可以给泛型赋值,确定泛型的数据类型
    Person&lt;C,D,E,F,W&gt;:定义多个泛型
    泛型的名字可以是任意的名字
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&lt;C&gt; {
    <span class="hljs-keyword">private</span> C name;

    <span class="hljs-keyword">public</span> C <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(C name)</span> {
        <span class="hljs-built_in">this</span>.name = name;
    }
}</code></pre></div>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo05GenericClass;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01Person</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">//没有给泛型赋值,默认就是Object类型</span>
        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();
        p.setName(<span class="hljs-number">11</span>);
        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> p.getName();
        System.out.println(obj);

        Person&lt;String&gt; p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>&lt;&gt;();
        p2.setName(<span class="hljs-string">"aaa"</span>);
        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> p2.getName();
        System.out.println(name);

        Person&lt;Double&gt; p3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>&lt;&gt;();
        p3.setName(<span class="hljs-number">1.1</span>);
        <span class="hljs-type">Double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> p3.getName();
        System.out.println(d);
    }
}</code></pre></div>
<p><img src="/_resources/9d32a2ddd1244b719db4596ce391145a.png" /></p>
<h2 id="4定义和使用含有泛型的方法重点">4.定义和使用含有泛型的方法(重点)</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo06GenericMethod;

<span class="hljs-comment">/*
    定义和使用含有泛型的方法(重点)
    方法上的泛型:定义在修饰符和返回值类型之间
    定义格式:
        修饰符 &lt;定义泛型&gt; 返回值类型 方法名(参数列表){
            方法体
        }
        方法的参数的类型和方法的返回值类型,就可以使用方法上定义的泛型
    什么时候确定泛型的数据类型:
        调用方法的时候,传递的数据是什么类型,方法上的泛型就是什么类型
        泛型:都是引用数据类型
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
    <span class="hljs-comment">//定义一个含有泛型的方法</span>
    <span class="hljs-keyword">public</span> &lt;M&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">show01</span><span class="hljs-params">(M m)</span>{
        System.out.println(m);
    }

    <span class="hljs-comment">//定义一个含有泛型的静态方法</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;S&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">show02</span><span class="hljs-params">(S s)</span>{
        System.out.println(s);
    }

    <span class="hljs-comment">//定义一个含有泛型,返回值类型使用泛型的静态方法</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;V&gt; V <span class="hljs-title function_">show03</span><span class="hljs-params">(V v)</span>{
        <span class="hljs-keyword">return</span> v;
    }
}</code></pre></div>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo06GenericMethod;

<span class="hljs-keyword">import</span> java.util.ArrayList;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01Person</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();
        p.show01(<span class="hljs-number">100</span>);
        p.show01(<span class="hljs-string">"aaa"</span>);
        p.show01(<span class="hljs-literal">true</span>);
        p.show01(<span class="hljs-number">1.1</span>);
        p.show01(<span class="hljs-string">'#'</span>);
        <span class="hljs-type">int</span>[] arr = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>};
        p.show01(arr);
        System.out.println(<span class="hljs-string">"---------------------------------"</span>);
        <span class="hljs-comment">//通过类名.方法名,可以集合调用静态方法</span>
        Person.show02(<span class="hljs-number">100</span>);
        Person.show02(<span class="hljs-string">"aaa"</span>);
        Person.show02(<span class="hljs-literal">true</span>);
        Person.show02(<span class="hljs-number">1.1</span>);
        Person.show02(<span class="hljs-string">'#'</span>);
        System.out.println(<span class="hljs-string">"---------------------------------"</span>);
        <span class="hljs-type">Integer</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> Person.show03(<span class="hljs-number">10</span>);
        System.out.println(in);
        <span class="hljs-type">String</span> <span class="hljs-variable">aaa</span> <span class="hljs-operator">=</span> Person.show03(<span class="hljs-string">"aaa"</span>);
        System.out.println(aaa);
        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        list.add(<span class="hljs-string">"aa"</span>);
        list.add(<span class="hljs-string">"bb"</span>);
        ArrayList&lt;String&gt; list2 = Person.show03(list);
        System.out.println(list2);
    }
}</code></pre></div>
<p><img src="/_resources/0bffe3c7fe0b47d7b6369aba86942e3a.png" /></p>
<h2 id="5定义和使用含有泛型的接口">5.定义和使用含有泛型的接口</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo07GenericInterface;

<span class="hljs-comment">/*
    定义和使用含有泛型的接口
    定义格式:
        public interface 接口名&lt;定义泛型&gt;{
            接口中的方法的参数和返回值类型都可以使用泛型
        }
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInter</span>&lt;I&gt; {
    <span class="hljs-comment">//抽象方法</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(I i)</span>;
}</code></pre></div>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo07GenericInterface;

<span class="hljs-comment">/*
    含有泛型的接口的第一种使用方式
        定义一个实现类,实现接口,并直接指定接口中泛型的数据类型
    格式:
        public class MyInterImpl1 implements MyInter&lt;String&gt;{
            @Override
            public void show(String s) {}
        }
        public class MyInterImpl1 implements MyInter&lt;Integer&gt;{
            @Override
            public void show(Integer in) {}
        }
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInterImpl1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MyInter</span>&lt;Integer&gt;{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(Integer in)</span> {
        System.out.println(in);
    }
}</code></pre></div>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo07GenericInterface;

<span class="hljs-comment">/*
    含有泛型的接口的第二种使用方式
        接口使用什么泛型,实现类就使用什么泛型,跟着接口走
    格式:
        public class MyInterImpl2&lt;I&gt; implements MyInter&lt;I&gt;{
            @Override
            public void show(I i) {
                System.out.println(i);
            }
        }
    就相当于一个含有泛型的类,创建对象的时候,确定泛型的数据类型
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInterImpl2</span>&lt;I&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MyInter</span>&lt;I&gt;{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(I i)</span> {
        System.out.println(i);
    }
}</code></pre></div>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo07GenericInterface;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">//创建接口的实现类对象</span>
        <span class="hljs-type">MyInterImpl1</span> <span class="hljs-variable">my01</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyInterImpl1</span>();
        my01.show(<span class="hljs-number">10</span>);
        
        MyInterImpl2&lt;String&gt; my02 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyInterImpl2</span>&lt;&gt;();
        my02.show(<span class="hljs-string">"aaa"</span>);

        MyInterImpl2&lt;Boolean&gt; my03 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyInterImpl2</span>&lt;&gt;();
        my03.show(<span class="hljs-literal">true</span>);
    }
}</code></pre></div>
<h2 id="6泛型的通配符">6.泛型的通配符</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo08Generic;

<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Collection;
<span class="hljs-keyword">import</span> java.util.Iterator;

<span class="hljs-comment">/*
    泛型的通配符
    ?:就是泛型的通配符,可以作为方法集合参数的类型使用,可以接收任意的数据类型
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01Generic</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        ArrayList&lt;Integer&gt; list01 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        list01.add(<span class="hljs-number">10</span>);
        list01.add(<span class="hljs-number">20</span>);
        ArrayList&lt;String&gt; list02 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        list02.add(<span class="hljs-string">"aaa"</span>);
        list02.add(<span class="hljs-string">"bbb"</span>);
        printCollection(list01);
        printCollection(list02);
        <span class="hljs-comment">//?只能作为参数中集合的数据类型使用,不能定义集合的时候使用</span>
        <span class="hljs-comment">//ArrayList&lt;?&gt; list03 = new ArrayList&lt;&gt;();</span>
        <span class="hljs-comment">//list03.add("aa");</span>
    }

    <span class="hljs-comment">/*
        需求:
            定义一个方法,方法的参数可以接收任意数据类型的集合
            在方法中对集合进行遍历
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printCollection</span><span class="hljs-params">(Collection&lt;?&gt; coll)</span>{
        <span class="hljs-comment">//使用迭代器遍历集合</span>
        Iterator&lt;?&gt; it = coll.iterator();
        <span class="hljs-keyword">while</span> (it.hasNext()){
            <span class="hljs-comment">//it.next方法取出元素是什么类型Object:中有Object类型可以接收任意的数据类型</span>
            <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> it.next();
            System.out.println(obj);
        }
    }
}</code></pre></div>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> com.itheima.demo08Generic;

<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Collection;

<span class="hljs-comment">/*
    泛型通配符的高级使用
    泛型的通配符: ? 代表可以接收任意数据类型的数据
    泛型的上限限定: ? extends E==&gt;传递的未知类型?只能使用E的子类或者是E本身
        ? extends Person:代表传递的未知的类型只能是Person或者Person的子类
    泛型的下限限定: ? super E==&gt;传递的未知类型?只能使用E的父类或者是E本身
        ? super Person:代表传递的未知的类型只能是Person或者Person的父类
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo02Generic</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        Collection&lt;Integer&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();
        Collection&lt;String&gt; list2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();
        Collection&lt;Number&gt; list3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Number&gt;();
        Collection&lt;Object&gt; list4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Object&gt;();

        <span class="hljs-comment">/*
            Integer extends Number extends Object
            String exntends Object
         */</span>

        getElement1(list1);
        <span class="hljs-comment">//getElement1(list2);//报错 String和Number没有关系</span>
        getElement1(list3);
        <span class="hljs-comment">//getElement1(list4);//报错 Object类型是Number的父类,需要Number子类</span>

        <span class="hljs-comment">//getElement2(list1);//报错 Integer是Number的子类,需要Number的父类</span>
        <span class="hljs-comment">//getElement2(list2);//报错 String和Number没有关系</span>
        getElement2(list3);
        getElement2(list4);
    }

        <span class="hljs-comment">// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getElement1</span><span class="hljs-params">(Collection&lt;? extends Number&gt; coll)</span>{}

        <span class="hljs-comment">// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getElement2</span><span class="hljs-params">(Collection&lt;? <span class="hljs-built_in">super</span> Number&gt; coll)</span>{}
}</code></pre></div>
<h1 id="第四章-数据结构">第四章 数据结构</h1>
<h2 id="1数据结构_栈先进后出">1.数据结构_栈:先进后出</h2>
<h2 id="2数据结构_队列先进先出">2.数据结构_队列:先进先出</h2>
<p><img src="/_resources/d57cea82bbae4085aa0ebebaccdfcdba.png" /></p>
<h2 id="3数据结构_数组查询快增删慢">3.数据结构_数组:查询快,增删慢</h2>
<p><img src="/_resources/1ee0da0736e940dfaec92f8613590bc8.png" /></p>
<h2 id="4数据结构_链表查询慢增删快">4.数据结构_链表:查询慢,增删快</h2>
<p><img src="/_resources/972710bbaafb4ebc9c1b1975dae7672b.png" /></p>
<h2 id="5数据结构_红黑树查询的速度特别快">5.数据结构_红黑树:查询的速度特别快</h2>
<p><img src="/_resources/6152d135cfbd4b63831c5088abcfe728.png" /></p>
</div>
      </article>
    </div>
  </body>
</html>
