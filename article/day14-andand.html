<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta http-equiv="X-UA-Compatible" content="ie=edge" />
<link rel="stylesheet" href="/_assets/main.css" />

    <title>day14-反射&amp;注解&amp;动态代理 - zblog</title>
  <link rel="stylesheet" href="/_markdown_plugin_assets/highlight.js/atom-one-light.css" /></head>
  <body>
    <div class="main">
      <nav class="navigation">
        <a href="/">zblog</a>
      </nav>
      <article>
        <header>
          <h1 class="article-title">day14-反射&amp;注解&amp;动态代理</h1>
          <div class="article-info">
            <div>
              <span
                >Created At：<time datetime="1618535186688"
                  >2021-04-16 09:06</time
                ></span
              >
              <span
                >Updated At：<time datetime="1635774259787"
                  >2021-11-01 21:44</time
                ></span
              >
            </div>
            
          </div>
        </header>
        <div class="article-content markdown-body"><nav class="table-of-contents"><ul><li><a href="#一-反射">一、反射</a><ul><li><a href="#什么是反射">什么是反射：</a></li><li><a href="#反射的作用">反射的作用：</a></li><li><a href="#类的加载">类的加载:</a></li><li><a href="#获取class对象的三种方式">获取Class对象的三种方式：</a><ul><li><a href="#2-获取成员属性并调用">2、获取成员属性并调用：</a></li><li><a href="#3-获取成员方法并调用">3、获取成员方法并调用：</a></li></ul></li><li><a href="#二-注解">二、注解</a><ul><li><a href="#什么是注解">.什么是注解：</a></li><li><a href="#作用">.作用：</a></li><li><a href="#模拟一下test注解">模拟一下@Test注解。</a></li><li><a href="#定义注解">定义注解：</a></li><li><a href="#元注解">元注解：</a></li><li><a href="#注解解析器">注解解析器</a></li><li><a href="#定义注解的属性">定义注解的属性：</a></li></ul></li><li><a href="#三-动态代理">三、动态代理</a><ul><li><a href="#代理模式在不修改原类代码的前提下为原类的方法进行增强">代理模式：在不修改原类代码的前提下，为原类的方法进行增强。</a></li></ul></li></ul></li></ul></nav><p>day14-反射&amp;注解&amp;动态代理</p>
<h1 id="一-反射">一、反射</h1>
<ol>
<li>
<h2 id="什么是反射">什么是反射：</h2>
<p>它是Java类库中的一种操作类，创建对象的一种方式。这种技术可以让我们的程序在运行期间，而且在不知道一个类的具体内部结构的前提下：可以动态的创建这个类的对象，并且调用他的的属性和方法（包括私有的）。</p>
</li>
<li>
<h2 id="反射的作用">反射的作用：</h2>
</li>
</ol>
<p>解开类和类之间的“耦合”。</p>
<ol start="3">
<li>
<h2 id="类的加载">类的加载:</h2>
</li>
<li>
<h2 id="获取class对象的三种方式">获取Class对象的三种方式：</h2>
<p>对象.getClass()：在创建对象后，通过此方法可以获取此类Class对象。</p>
<p>类型.class属性：任何类型(包括类、数组、基本类型)都有一个静态的属性：class，可以创建/获取本类的Class对象。 Class c1 = Student.class;//OK的</p>
</li>
</ol>
<div><pre class="hljs"><code>    ​ Student stu = <span class="hljs-keyword">new</span> Student(); ​ <span class="hljs-keyword">Class</span> c2 = stu.<span class="hljs-keyword">class</span>;<span class="hljs-comment">//不可以，class属性不能通过对象调用。 </span></code></pre></div>
<pre><code>Class.forName(“全类名”):创建/获取参数类的Class对象。【常用】

### 1、获取结构方法并调用：Constructor
</code></pre>
<blockquote>
<p>1）批量获取：(了解)</p>
<ul>
<li>public Constructor[] getConstructors()：获取此类的所有公有构造方法。</li>
<li>public Constructor[] getDeclaredConstructors()：获取此类的所有构造方法，包括公有、受保护、默认、私有</li>
</ul>
<p>2）获取单个：</p>
<ul>
<li>public Constructor getConstructor(Class…params)：获取具有某个参数的"公有"构造方法。</li>
<li>public Constructor getDeclaredConstructor(Class … params)：获取具有某种参数的"构造方法"，可以公有、受保护、默认、私有</li>
</ul>
<p>3).创建对象：Constructor–&gt;newInstance(Object … params)： 注意：如果没有访问权限，需要设置暴力访问： Constructor–&gt;setAccessible(true)</p>
</blockquote>
<h3 id="2-获取成员属性并调用">2、获取成员属性并调用：</h3>
<blockquote>
<p>批量获取：(了解)</p>
<ul>
<li>public Field[] getFields()：获取此类的所有公有成员属性。</li>
<li>public Field[] getDeclaredFields()：获取此类的所有成员属性，包括公有、受保护、默认、私有</li>
</ul>
<p>获取单个：</p>
<ul>
<li>public Field getField(String fieldName)：获取某个名字的、公有成员属性</li>
<li>public Field getDeclaredField(String fieldName)：获取具有某个名字的成员属性，可以公有、受保护、默认、私有</li>
</ul>
</blockquote>
<p>设置属性的值：必须要先创建对象 Field–&gt;set(Object target,Object value)</p>
<p>获取属性的值： Filed–&gt;get(Object target)</p>
<p>​ 【注意】如果没有权限访问属性，可以设置暴力访问： ​ Field–&gt;setAccessible(true);</p>
<h3 id="3-获取成员方法并调用">3、获取成员方法并调用：</h3>
<p>1).批量获取：(了解)</p>
<blockquote>
<p>public Method[] getMethods()：获取此类的所有公有成员方法。</p>
<p>public Method[] getDeclaredMethods()：获取此类的所有成员方法，包括公有、受保护、默认、私有</p>
</blockquote>
<p>2).获取单个：</p>
<blockquote>
<p>public Method getMethod(String methodName,Class…params)：获取某个名字、参数的公有成员方法。</p>
<p>public Method getDeclaredMethod(String methodName,Class … params)：获取具有某个名字、参数的成员方法，可以公有、受保护、默认、私有</p>
</blockquote>
<p>2).调用方法： Method–&gt;invoke(Object target , Object … params) 注意，如果没有访问权限，要设置暴力访问 Method–&gt;setAccessible(true)</p>
<h2 id="二-注解">二、注解</h2>
<ol>
<li>
<h3 id="什么是注解">.什么是注解：</h3>
<p>我们之前看到的：@Override，@FunctionalInterface，@Test这些都是"注解"。 这些注解本质上就是一个特殊的"类"，需要有一个独立的文件来定义的。</p>
</li>
<li>
<h3 id="作用">.作用：</h3>
<p>用在"源码"中，对代码做一下"标记"，告诉"注解解析器"下面的代码怎么编译、运行。 编译的，例如：@Override，告诉"注解解析器"下面的方法是重写父类的，如果重写格式错误，直接编译错误； @FunctionalInterface 运行的，例如：@Test，告诉"注解解析器"下面的方法就是测试方法，可以运行。</p>
</li>
<li>
<h3 id="模拟一下test注解">模拟一下@Test注解。</h3>
</li>
</ol>
<div><pre class="hljs"><code><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;
<span class="hljs-keyword">import</span> java.lang.annotation.Retention;
<span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;
<span class="hljs-keyword">import</span> java.lang.annotation.Target;

<span class="hljs-meta">@Target({ElementType.METHOD})</span>
<span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyTest {

}
</code></pre></div>
<hr />
<div><pre class="hljs"><code><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;
<span class="hljs-keyword">import</span> java.lang.reflect.Method;
<span class="hljs-keyword">import</span> java.util.Arrays;

<span class="hljs-comment">/*
    自定义注解：

    此类Demo08，来模拟一个"注解解析器"
    自定类，编写main()方法，使用"反射"加载使用了注解的类，
    然后判断哪个方法上使用了咱们的注解，
    然后就反射，执行这个方法。
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo08</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">//1.获取Student类的Class</span>
        <span class="hljs-type">Class</span> <span class="hljs-variable">stuClass</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">"com.itheima.demo08.Student"</span>);
        <span class="hljs-comment">//2.创建对象</span>
        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> stuClass.getConstructor().newInstance();
        <span class="hljs-comment">//3.获取所有公有方法</span>
        Method[] methods = stuClass.getMethods();
        Arrays.sort(methods,(m1, m2)-&gt;m1.getName().compareTo(m2.getName()));

        <span class="hljs-comment">//4.遍历数组</span>
        <span class="hljs-keyword">for</span> (Method method : methods) {
            <span class="hljs-comment">//判断方法上是否使用了@MyTest注解</span>
            <span class="hljs-keyword">if</span>(method.isAnnotationPresent(MyTest.class)){
                <span class="hljs-comment">//执行这个方法</span>
                method.invoke(obj);
            }
        }

    }
}
</code></pre></div>
<ol start="4">
<li>
<h3 id="定义注解">定义注解：</h3>
</li>
</ol>
<div><pre class="hljs"><code>        <span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> 注解名{
        
        }
        自定义注解，并使用后，会发现<span class="hljs-number">2</span>个问题：
        <span class="hljs-number">1</span>).我们的注解没有任何作用——注解解析器
        <span class="hljs-number">2</span>).我们的注解可以用在几乎类的任何位置——这似乎也不太正常——解决：用<span class="hljs-string">"元注解"</span></code></pre></div>
<ol start="5">
<li>
<h3 id="元注解">元注解：</h3>
</li>
</ol>
<p>1).什么是"元注解"：是Java类库中预定义好的注解，用在"定义新注解"的上面。</p>
<p>作用：</p>
<blockquote>
<ul>
<li>可以约束新注解的使用位置：@Target</li>
<li>可以约束新注解的生命周期；(根据注解的功能，确定生命周期)：@Retension</li>
</ul>
</blockquote>
<p>2).@Target 可选值：</p>
<blockquote>
<ul>
<li>ElementType.TYPE，类，接口</li>
<li>ElementType.FIELD, 成员变量</li>
<li>ElementType.METHOD, 成员方法</li>
<li>ElementType.PARAMETER, 方法参数</li>
<li>ElementType.CONSTRUCTOR, 构造方法</li>
<li>ElementType.LOCAL_VARIABLE, 局部变量</li>
</ul>
</blockquote>
<p>3).@Retension 可选值：</p>
<blockquote>
<ul>
<li>RetensionPolicy.SOURCE：此注解只出现在源码中，编译后，不会生成到Class文件中。例如：@Override</li>
<li>RetensionPolicy.CLASS：此注解会出现在源码、class文件中。</li>
<li>RetensionPolicy.RUNTIME：此注解会出现在源码、class文件中、运行时内存中。例如：@Test</li>
</ul>
</blockquote>
<ol start="6">
<li>
<h3 id="注解解析器">注解解析器</h3>
<p>自定类，编写main()方法，使用"反射"加载使用了注解的类，然后判断哪个方法上使用了咱们的注解，然后就反射，执行这个方法。</p>
</li>
<li>
<h3 id="定义注解的属性">定义注解的属性：</h3>
<p>注解中可以定义属性：类似于类中的"成员变量"。</p>
<p>属性的作用：可以对注解的作用，进行更详细的划分。</p>
</li>
</ol>
<div><pre class="hljs"><code>    格式：<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> 注解名{ 
                数据类型名 属性名() [<span class="hljs-keyword">default</span> 值]; 
           } 
           </code></pre></div>
<div><pre class="hljs"><code>     数据类型：四类八种的基本类型、<span class="hljs-keyword">String</span>、<span class="hljs-keyword">Class</span>、枚举类型、注解类型，以上各种类型的数组类型。 </code></pre></div>
<pre><code>注意：如果注解中只有一个属性，或者其他属性都有默认值，而且这个属性的名叫：value，在使用这个注解时，为这个属性赋值时，可以省略 属性名。
</code></pre>
<div><pre class="hljs"><code>                <span class="hljs-meta">@Target( ElementType.METHOD)</span>
                <span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span>
                <span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyTest {
                    <span class="hljs-comment">//定义一个属性：index</span>
                    <span class="hljs-comment">//int index() default 1 ;</span>
                    <span class="hljs-type">int</span> <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">1</span>;
                }
                <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> {
                    <span class="hljs-meta">@MyTest(2)</span>
                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show1</span><span class="hljs-params">()</span>{
                        System.out.println(<span class="hljs-string">"show1()..."</span>);
                    }
                    <span class="hljs-meta">@MyTest(1)</span>
                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show2</span><span class="hljs-params">()</span>{
                        System.out.println(<span class="hljs-string">"show2()..."</span>);
                    }		
                    <span class="hljs-meta">@MyTest(0)</span>
                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show13</span><span class="hljs-params">()</span>{
                        System.out.println(<span class="hljs-string">"show3()..."</span>);
                    }
    
                    <span class="hljs-meta">@MyTest(-1)</span>
                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show4</span><span class="hljs-params">()</span>{
                        System.out.println(<span class="hljs-string">"show4()..."</span>);
                    }
            }</code></pre></div>
<h2 id="三-动态代理">三、动态代理</h2>
<ol>
<li>
<h3 id="代理模式在不修改原类代码的前提下为原类的方法进行增强">代理模式：在不修改原类代码的前提下，为原类的方法进行增强。</h3>
</li>
<li>
<p>定义一个蔡徐坤类：</p>
</li>
</ol>
<div><pre class="hljs"><code>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CXK</span> {
                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sing</span><span class="hljs-params">()</span>{
                    System.out.println(<span class="hljs-string">"蔡徐坤唱歌..."</span>);
                }
            }</code></pre></div>
<p>2.定义一个代理类：</p>
<div><pre class="hljs"><code>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CXKProxy</span> {
                <span class="hljs-comment">//1.被代理对象</span>
                <span class="hljs-keyword">private</span> <span class="hljs-type">CXK</span> <span class="hljs-variable">cxk</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CXK</span>();			
            <span class="hljs-comment">//2.提供一个唱歌的方法</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sing</span><span class="hljs-params">()</span>{
                System.out.println(<span class="hljs-string">"谈时间！"</span>);
                System.out.println(<span class="hljs-string">"谈价格！"</span>);
                <span class="hljs-comment">//调用被代理的原方法</span>
                cxk.sing();

                System.out.println(<span class="hljs-string">"总结"</span>);
                System.out.println(<span class="hljs-string">"开庆功会！分钱！！"</span>);
            }
        }</code></pre></div>
<ol start="3">
<li>测试类</li>
</ol>
<div><pre class="hljs"><code>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo10</span> {
                <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
                    <span class="hljs-comment">/*CXK cxk = new CXK();
                    cxk.sing();*/</span>
                    
                    <span class="hljs-type">CXKProxy</span> <span class="hljs-variable">cxkProxy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CXKProxy</span>();
                    cxkProxy.sing();
                }
            }</code></pre></div>
</div>
      </article>
    </div>
  </body>
</html>
