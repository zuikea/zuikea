<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta http-equiv="X-UA-Compatible" content="ie=edge" />
<link rel="stylesheet" href="/_assets/main.css" />

    <title>day8-线程安全 - zblog</title>
  <link rel="stylesheet" href="/_markdown_plugin_assets/highlight.js/atom-one-light.css" /></head>
  <body>
    <div class="main">
      <nav class="navigation">
        <a href="/">zblog</a>
      </nav>
      <article>
        <header>
          <h1 class="article-title">day8-线程安全</h1>
          <div class="article-info">
            <div>
              <span
                >Created At：<time datetime="1617843877841"
                  >2021-04-08 09:04</time
                ></span
              >
              <span
                >Updated At：<time datetime="1638180115468"
                  >2021-11-29 18:01</time
                ></span
              >
            </div>
            
          </div>
        </header>
        <div class="article-content markdown-body"><nav class="table-of-contents"><ul><li><a href="#一-线程的安全性问题">一、线程的安全性问题：</a><ul><li><a href="#a变量的可见性问题">​ A)变量的：“可见性”问题：</a></li><li><a href="#b代码的有序性问题">​ B)代码的：”有序性问题“：</a></li><li><a href="#c变量访问的原子性问题">​ C)变量访问的：“原子性”问题：</a></li></ul></li><li><a href="#二-volatile关键字">二、volatile关键字</a><ul><li><a href="#1可以解决可见性问题">​ 1）可以解决“可见性”问题：</a></li><li><a href="#2可以解决有序性问题">​ 2）可以解决“有序性”问题：</a></li><li><a href="#3不能解决原子性问题">​ 3）不能解决“原子性”问题：</a></li></ul></li><li><a href="#三-使用原子类解决变量的原子性还可以解决有序性-可见性">三、使用“原子类“解决变量的”原子性“，还可以解决”有序性“、”可见性“：</a><ul><li><a href="#1变量的原子类-concurrent并发-atomic原子的">​ 1）变量的原子类： concurrent：并发 atomic原子的</a></li><li><a href="#2数组的原子类">​ 2）数组的原子类</a></li><li><a href="#3集合的原子类">​ 3）集合的原子类：</a><ul><li><a href="#1list集合-我们之前学习的arraylist-linkedlist都是线程不安全的">​ 1）List集合： 我们之前学习的ArrayList、LinkedList都是线程不安全的。</a></li><li><a href="#2set集合">​ 2）Set集合：</a></li><li><a href="#3map集合">​ 3)Map集合：</a></li></ul></li></ul></li><li><a href="#四-如果要对一段代码做原子操作一个线程在执行这段代码时其他线程需要等待需要一个关键字synchronized关键字-synchronized同步">四、如果要对一段代码做原子操作——一个线程在执行这段代码时，其他线程需要等待，需要一个关键字：synchronized关键字 synchronized：同步</a><ul><li><a href="#1同步代码块少用">​ 1）同步代码块：（少用）</a></li><li><a href="#2同步方法常用">​ 2）同步方法：（常用）</a></li></ul></li><li><a href="#五lock锁jdk15新增的一个新锁">五：Lock锁：JDK1.5新增的一个新“锁”</a></li></ul></nav><h1 id="一-线程的安全性问题"><strong>一、线程的安全性问题：</strong></h1>
<p>多个线程无序的访问同一资源（便令、数组、对象、数据库中的数据、文件…），由于多线程的内存访问机制问题，会导致最终的结果不正确。</p>
<h2 id="a变量的可见性问题">​ <strong>A)变量的：“可见性”问题：</strong></h2>
<p>两个线程共同访问同一个变量，一个线程将这个变量的值更改，另一个线程由于访问速度过快，无法看到这个变量被更改。</p>
<p>​ demo01,图：01</p>
<p>​</p>
<h2 id="b代码的有序性问题">​ <strong>B)代码的：”有序性问题“：</strong></h2>
<p>指编译器在编译某些代码时，为了提高编译效率，在不改变最终结果的前提下，可能会将代码”重排”——多线程情况下是不希望这样的</p>
<p>​ 例如：</p>
<p>​ int a = 10;</p>
<p>​ int b = 20;</p>
<p>​ int c = a + b;</p>
<p>​ 编译时：</p>
<p>​ int b = 20;</p>
<p>​ int a = 10;//代码重排</p>
<p>​ int c = a + b;</p>
<p>​ 在多线程情况下，我们通常不希望编译器对代码进行重排，可能会引发最终结果的不正确。</p>
<h2 id="c变量访问的原子性问题">​ <strong>C)变量访问的：“原子性”问题：</strong></h2>
<p>多个线程访问同一资源（变量、数组、集合…）导致被访问的资源没有“原子性”，导致最终的结果不正确。</p>
<h1 id="二-volatile关键字"><strong>二、volatile关键字</strong></h1>
<p>使主线程复制的静态属性失效，必须重新获取</p>
<h2 id="1可以解决可见性问题">​ <strong>1）可以解决“可见性”问题：</strong></h2>
<p>​ public static volatile boolean b = true;</p>
<h2 id="2可以解决有序性问题">​ <strong>2）可以解决“有序性”问题：</strong></h2>
<p>​ volatile int a = 10;</p>
<p>​ volatile int b = 20;</p>
<p>​ int c = a + b ;</p>
<p>​ 编译时，可以保证：</p>
<p>​ int a = 10;</p>
<p>​ int b = 20;</p>
<p>​ int c = a + b;</p>
<h2 id="3不能解决原子性问题">​ <strong>3）不能解决“原子性”问题：</strong></h2>
<h1 id="三-使用原子类解决变量的原子性还可以解决有序性-可见性"><strong>三、使用“原子类“解决变量的”原子性“，还可以解决”有序性“、”可见性“：</strong></h1>
<p>​ 从JDK1.5开始，Java类库提供了JUC包（java.util.concurrent)，这个包提供了很多的线程安全的一些工具类：</p>
<h2 id="1变量的原子类-concurrent并发-atomic原子的">​ <strong>1）变量的原子类：</strong> concurrent：并发 atomic原子的</h2>
<blockquote>
<p>​ 1）java.util.concurrent.atomic.AtomicInteger:对int变量进行了原子访问的工具类。它内部可以存储一个int值，此类可以保证多个线程范文此类</p>
<p>​ 2）java.util.concurrent.atomic.AtomicLong：对long变量</p>
<p>​ 3）java.util.concurretn.atomic.AtomicBoolean：对boolean</p>
<p>​ 4）java.util.concurrent.atomic.AtomicReference：对一个“对象”数组访问的多线程安全的工具类。</p>
</blockquote>
<h2 id="2数组的原子类">​ <strong>2）数组的原子类</strong></h2>
<blockquote>
<p>​ 1）java.util.concurrent.atomic.AtomicIntegerArray：对int[]数组操作的原子类</p>
<p>​ 2）java.util.concurrent.atomic.AtomicLongArray：对long[]数组操作的原子类</p>
<p>​ 3）java.util.concurrent.atomic.AtomicReferenceArray：对引用类型的数组操作</p>
</blockquote>
<h2 id="3集合的原子类">​ <strong>3）集合的原子类：</strong></h2>
<h3 id="1list集合-我们之前学习的arraylist-linkedlist都是线程不安全的">​ <strong>1）List集合：</strong> 我们之前学习的ArrayList、LinkedList都是线程不安全的。</h3>
<p>​ 改用：java.util.concurrent.CopyOnWriteArrayList:</p>
<h3 id="2set集合">​ <strong>2）Set集合：</strong></h3>
<p>​ 使用：java.util.concurrent.CopyOnWriteArraySet:</p>
<h3 id="3map集合">​ <strong>3)Map集合：</strong></h3>
<p>​ 使用：java.util.concurrent.ConcurrentHashMap:</p>
<h1 id="四-如果要对一段代码做原子操作一个线程在执行这段代码时其他线程需要等待需要一个关键字synchronized关键字-synchronized同步"><strong>四、如果要对一段代码做原子操作——一个线程在执行这段代码时，其他线程需要等待，需要一个关键字：synchronized关键字</strong> synchronized：同步</h1>
<h2 id="1同步代码块少用">​ <strong>1）同步代码块：（少用）</strong></h2>
<p>​</p>
<div><pre class="hljs"><code>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();
    下面的锁对象就是obj
    <span class="hljs-comment">//private static String str = "呵呵";</span>
   	<span class="hljs-comment">//此时，下面的锁对象就是str</span>
        
    
    锁对象可以是任何
    语法：<span class="hljs-keyword">synchronized</span>(锁对象){
        <span class="hljs-comment">//被同步的代码</span>
    }</code></pre></div>
<h2 id="2同步方法常用">​ <strong>2）同步方法：（常用）</strong></h2>
<div><pre class="hljs"><code>    语法：在方法中添加<span class="hljs-keyword">synchronized</span>关键字（抽取操作变量的过程，作为方法，需要以下操作之一）
        注意：
        <span class="hljs-number">1</span>）普通的同步方法，锁对象：本对象(<span class="hljs-built_in">this</span>)
        	要想使用，实现Runnable接口，main方法创建
        		 <span class="hljs-type">MyRunnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();
        	 	 <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r);
                <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r);
                <span class="hljs-type">Thread</span> <span class="hljs-variable">thread3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r);
        <span class="hljs-number">2</span>）静态的同步方法，锁对象：本类的Class对象——任何类在方法区都会有，且只有一个这个类的Class对象，存储这个类的信息
            要想使用，
            	抽取的方法使用 <span class="hljs-keyword">static</span> 修饰</code></pre></div>
<h1 id="五lock锁jdk15新增的一个新锁"><strong>五：Lock锁：JDK1.5新增的一个新“锁”</strong></h1>
<div><pre class="hljs"><code>    <span class="hljs-type">Lock</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> 子类对象();(<span class="hljs-type">Lock</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>())
    l.lock();<span class="hljs-comment">//加锁</span>
    <span class="hljs-keyword">try</span>{
        <span class="hljs-comment">//同步代码(上面抽取的方法)</span>
    }<span class="hljs-keyword">finally</span>{
        l.unlock();<span class="hljs-comment">//释放锁（防止程序异常，无法解锁，所以用finally修饰）</span>
    }



    说明：
    Lock锁在枷锁后，如果出现异常， ，所以必须使用<span class="hljs-keyword">finally</span>释放锁
    </code></pre></div>
</div>
      </article>
    </div>
  </body>
</html>
